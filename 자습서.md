# 목차

1. **RESTful API**
2. **동기와 비동기**
3. **async/await**
   1. **RxJS**
   2. **데이터의 스트림 형태**
   3. **yield, 제너레이터(python)**
4. **Promise**
5. **CICD**
6. **좀비프로세스**
7. **TCP, UDP**
8. **npm**
   1. **SemVer**
9. **npm install**
10. **db 관계형 비관계형 차이**

## RESTful API

RESTful API는 Representational State Transfer(REST) 원칙을 따르는 웹 서비스 인터페이스입니다. REST는 클라이언트와 서버 간의 상호작용을 정의하는 아키텍처 스타일로, 다음과 같은 주요 개념이 있습니다:

1. **자원(Resource)**

   REST API는 URI(Uniform Resource Identifier)를 사용하여 자원을 식별합니다. 각 자원은 고유한 URI로 접근할 수 있습니다.

2. **HTTP 메서드**

   REST API는 다음과 같은 HTTP 메서드를 사용하여 자원에 대한 작업을 수행합니다:

   1. **GET**: 자원 조회

   2. **POST**: 새로운 자원 생성

   3. **PUT**: 자원 전체 업데이트

   4. **PATCH**: 자원 부분 업데이트

   5. **DELETE**: 자원 삭제

3. **상태 비저장성(Stateless)**

   REST API의 각 요청은 독립적이며, 서버는 클라이언트의 상태를 저장하지 않습니다. 모든 필요한 정보는 클라이언트가 요청에 포함시켜야 합니다.

4. **표현(Representation)**

   자원은 다양한 형식(예: JSON, XML)으로 표현될 수 있습니다. 클라이언트는 원하는 형식을 서버에 요청할 수 있습니다.

5. **캐싱(Caching)**

   REST는 응답을 캐시할 수 있는 기능을 제공하여 성능을 향상시킬 수 있습니다.

6. **계층화(Layered System)**

   REST 아키텍처는 여러 계층으로 구성될 수 있으며, 클라이언트는 중간 서버의 존재를 알지 못합니다.

   - **예시**: 간단한 RESTful API의 예시는 다음과 같습니다:

     - **GET /api/users**: 모든 사용자 조회

     - **GET /api/users/1**: 특정 사용자 조회

     - **POST /api/users**: 새로운 사용자 생성

     - **PUT /api/users/1**: 특정 사용자 정보 업데이트

     - **DELETE /api/users/1**: 특정 사용자 삭제

이와 같은 RESTful API는 클라이언트와 서버 간의 상호작용을 간결하고 일관성 있게 만들어줍니다.

## 동기와 비동기

통신에서 동기(Synchronous)와 비동기(Asynchronous) 처리는 데이터 전송 및 응답을 처리하는 방식에 대한 개념입니다. 각각의 차이점을 살펴보면 다음과 같습니다:

1. **동기(Synchronous)**

   - **정의**

     요청을 보낸 후, 응답을 받을 때까지 기다리는 방식입니다. 즉, 다음 작업을 수행하기 전에 반드시 응답을 받아야 합니다.

   - **특징**

     코드의 흐름이 요청과 응답에 따라 직선적으로 진행됩니다.
     사용자가 기다리는 동안 UI가 정지할 수 있습니다(특히 브라우저의 경우).
     구현이 간단하고 이해하기 쉬운 경우가 많습니다.

   - **예시**

     JavaScript의 XMLHttpRequest를 사용할 때 async를 false로 설정하면 동기 방식으로 요청이 처리됩니다.

2. **비동기(Asynchronous)**

   - **정의**

     요청을 보낸 후, 응답을 기다리지 않고 다음 작업을 수행하는 방식입니다. 응답은 나중에 받을 수 있으며, 일반적으로 콜백이나 프로미스를 사용하여 처리합니다.

   - **특징**

     코드의 흐름이 요청과 응답과 독립적입니다. 사용자가 기다리는 동안 UI가 정상적으로 작동하며, 더 나은 사용자 경험을 제공합니다. 복잡한 비즈니스 로직을 구현할 때 유용합니다.

## async/await

- **Promise**

  JavaScript의 기본 비동기 처리 방법입니다. then()과 catch() 메서드를 사용하여 비동기 작업의 결과를 처리합니다.

- **콜백 함수**

  전통적인 방식으로, 비동기 작업이 완료된 후 호출되는 함수를 정의하여 결과를 처리합니다. 하지만 콜백 헬(callback hell) 문제로 코드 가독성이 떨어질 수 있습니다.

- **RxJS**

  Reactive Programming 라이브러리로, 스트림을 통해 비동기 데이터를 처리할 수 있습니다. 복잡한 비동기 로직을 간결하게 표현할 수 있습니다.

- **Generator 함수(python)**

  function\* 문법을 사용하여 제너레이터를 생성하고, yield 키워드를 통해 비동기 처리를 할 수 있습니다. co 라이브러리와 함께 사용하면 비동기 코드 작성이 더 수월해질 수 있습니다.

- **EventEmitter**

  Node.js의 이벤트 기반 프로그래밍 패턴을 사용하여 이벤트가 발생할 때 비동기 처리를 수행할 수 있습니다.

### RxJS

RxJS (Reactive Extensions for JavaScript)는 비동기 데이터 흐름을 처리하기 위한 라이브러리로, 옵저버블 패턴을 사용하여 데이터를 스트림 형태로 다룹니다. 이를 통해 이벤트, AJAX 요청, 사용자 입력 등 다양한 비동기 작업을 쉽게 처리할 수 있습니다.

1. **주요 개념**

   1. **옵저버블 (Observable)**

      데이터 스트림을 나타내며, 데이터를 발행하는 주체입니다. 옵저버블은 여러 구독자(옵저버)를 가질 수 있습니다.

   2. **옵저버 (Observer)**

      옵저버블을 구독하고, 데이터가 발행될 때마다 알림을 받는 객체입니다.

   3. **구독 (Subscription)**

      옵저버블을 구독하는 행위로, 데이터가 발행되면 콜백이 실행됩니다.

   4. **연산자 (Operators)**

      옵저버블을 변환하거나 조작하는 함수들입니다. 예를 들어, map, filter, merge, switchMap 등의 연산자가 있습니다.

2. **기본 사용법**

   RxJS를 사용하기 위해선 먼저 라이브러리를 설치해야 합니다.

   ```bash
   npm install rxjs
   ```

   ```js
   import { Observable } from "rxjs";

   // 옵저버블 생성
   const myObservable = new Observable((subscriber) => {
     subscriber.next("Hello");
     subscriber.next("World");
     subscriber.complete(); // 스트림 종료
   });

   const myObserver = {
     next: (value) => console.log(value),
     error: (err) => console.error(err),
     complete: () => console.log("Done"),
   };

   // 옵저버블 구독
   myObervable.subscribe(myObserver);
   ```

3. **연산자 사용 예제**

   ```js
   import { of } from "rxjs";
   import { map, filter } from "rxjs/operators";

   const numbers = of(1, 2, 3, 4, 5);

   // 연산자를 사용한 예제
   const processedNumbers = numbers.pipe(
     filter((x) => x % 2 === 0), // 짝수만 통과
     map((x) => x * 10) // 각 숫자에 10 곱하기
   );

   processedNumbers.subscribe(console.log); // 20, 40
   ```

4. **장점**

   1. **비동기 처리**

      콜백 지옥을 피하고, 비동기 작업을 더 쉽게 관리할 수 있습니다.

   2. **구성 가능성**

      연산자 체이닝을 통해 복잡한 비즈니스 로직을 간단하게 표현할 수 있습니다.

   3. **응답성**

      다양한 데이터 소스를 통합하고, 응답성을 유지할 수 있습니다.

### 데이터의 스트림 형태

데이터의 스트림 형태는 데이터를 연속적으로 생성하고 처리하는 방식을 나타냅니다. 이는 주로 비동기적이고 이벤트 기반의 프로그래밍에서 중요합니다. RxJS와 같은 라이브러리를 통해 이 스트림을 쉽게 다룰 수 있습니다.

1. **스트림의 기본 개념**

   1. **스트림**

      데이터의 연속적인 흐름을 나타냅니다. 스트림은 시간에 따라 변화하는 데이터 시퀀스를 의미합니다. 예를 들어, 사용자 입력, 웹 소켓 메시지, AJAX 요청 등이 있습니다.

   2. **발행자 (Publisher)**

      데이터를 생성하고 스트림에 발행하는 주체입니다. 이는 옵저버블 형태로 구현됩니다.

   3. **구독자 (Subscriber)**

      스트림의 데이터를 소비하고 반응하는 주체입니다. 구독자는 발행자가 발행하는 데이터에 대해 반응합니다.

   4. **변환 및 조작**

      스트림의 데이터를 변환하거나 필터링하는 연산자들이 사용됩니다. 이들은 데이터 흐름을 제어하는 데 도움을 줍니다.

2. **스트림의 종류**

   1. **단방향 스트림**

      데이터가 한 반향으로만 흐릅니다. 예를 들어, 이벤트 스트림(클릭, 입력 등)이 있습니다.

   2. **양방향 스트림**

      데이터가 양 방향으로 흐를 수 있습니다. 예를 들어, 웹 소켓 통신이 있습니다.

3. **스트림 처리의 장점**

   1. **비동기 처리**

   데이터가 준비되는 대로 처리할 수 있어 응답성이 향상됩니다.

   2. **조합 가능성**

   여러 데이터 소스를 하나의 스트림으로 결합하여 복잡한 데이터 흐름을 관리할 수 있습니다.

   3. **지연 평가**

   필요할 때만 데이터를 처리하므로 효율성을 높일 수 있습니다.

4. **예시**

   여기 사용자 클릭 이벤트를 처리하는 간단한 예제가 있습니다.

   ```js
   import { fromEvent } from "rxjs";
   import { map } from "rxjs/operators";

   // 버튼 클릭 이벤트 스트림 생성
   const button = document.getElementById("myButton");
   const clicks = fromEvent(button, "click");

   // 클릭 이벤트를 처리하여 좌표를 로그에 남김
   const positions = clicks.pipe(
     map((event) => ({ x: event.clientX, y: event.clientY }))
   );

   positions.subscribe((pos) => console.log(`X: ${pos.x}, Y: ${pos.y}`));
   ```

   위의 예제에서 fromEvent는 버튼 클릭 이벤트를 옵저버블로 변환하고, 클릭할 때마다 좌표를 로그에 남깁니다. 스트림은 사용자가 버튼을 클릭할 때마다 데이터(좌표)를 발행합니다.

### yield, 제너레이터(python)

yield 키워드는 python에서 제너레이터를 만들기 위해 사용됩니다. 제너레이터는 이터레이터의 일종으로, 값을 한 번에 하나씩 생성할 수 있게 해줍니다. yield를 사용하면 함수의 상태를 유지하면서 반복적으로 값을 반환할 수 있습니다.

1. **제너레이터의 기본 사용법**

   1. **제너레이터 함수 정의**

      yield를 사용하여 제너레이터 함수를 정의합니다.

   2. **제너레이터 객체 생성**

      함수를 호출하면 제너레이터 객체가 생성됩니다.

   3. **값 생성**

      next() 함수를 사용하여 다음 값을 얻거나, for 루프를 통해 반복할 수 있습니다.

   4. **예제**

      ```python
      def countdown(n):
            while n > 0:
               yield n
               n -= 1

      # 제너레이터 객체 생성
      gen = countdown(5)

      # 값 생성
      for number in gen:
         print(number)
      ```

   이 예제에서 countdown 함수는 5부터 1까지의 값을 생성합니다. yield 키워드 덕분에 함수는 값을 반환한 후 상태를 유지할 수 있어, 다음 호출 시 중단한 지점부터 실행됩니다.

2. **제너레이터의 장점**

   1. **메모리 효율성**

      모든 값을 한 번에 메모리에 저장하지 않기 때문에 큰 데이터셋을 처리할 때 유용합니다.

   2. **지연 평가**

      필요할 때만 값을 생성하여 성능을 최적화할 수 있습니다.

## Promise

Promise는 JavaScript에서 비동기 작업을 처리하기 위한 객체입니다. 주로 비동기 연산의 성공 또는 실패 결과를 다루기 위해 사용됩니다. Promise는 세 가지 상태를 가집니다.

1. **대기(pending)**

   초기 상태로, 비동기 작업이 아직 완료되지 않은 상태입니다.

2. **이행(fulfilled)**

   비동기 작업이 성공적으로 완료되었을 떄의 상태입니다. 이 경우, 결과 값을 반환합니다.

3. **거부(rejected)**

   비동기 작업이 실패했을 때의 상태입니다. 이 경우, 오류 이유를 반환합니다.

## CICD

CI/CD는 소프트웨어 개발 프로세스를 자동화하는 중요한 개념입니다. 각각의 의미는 다음과 같습니다:

1. **CI (Continuous Integration)**

   - **지속적 통합**

     개발자들이 코드를 자주 (보통 하루에 여러 번) 통합하는 방법입니다. 각 코드 변경 사항은 자동으로 빌드되고 테스트되어, 통합 후 발생할 수 있는 문제를 빠르게 발견할 수 있습니다. 이를 통해 코드 품질을 높이고, 팀의 협업을 원활하게 합니다.

2. **CD (Continuous Delivery / Continuous Deployment)**

   CI의 확장으로, 코드 변경 사항이 자동으로 프로덕션 환경에 배포되는 프로세스입니다.

   - **Continuous Delivery**

     모든 코드 변경이 테스트를 통과하면 언제든지 배포할 준비가 되어 있는 상태입니다. 배포는 수동으로 진행됩니다.

   - **Continuous Deployment**

     코드 변경이 자동으로 프로덕션 환경에 배포됩니다. 모든 테스트가 통과하면 추가적인 승인 없이 배포가 이루어집니다.

3. **장점**

   - **빠른 피드백**

     개발자가 코드를 변경할 때마다 자동으로 테스트가 이루어져, 문제를 조기에 발견할 수 있습니다.

   - **일관된 품질**

     자동화된 테스트와 빌드를 통해 품질이 일관되게 유지됩니다.

   - **신속한 배포**

     새로운 기능이나 수정 사항을 신속하게 사용자에게 제공할 수 있습니다.

   - **효율적인 협업**

     팀원 간의 코드 충돌을 줄이고, 통합 과정에서 발생할 수 있는 문제를 조기에 해결합니다.

## 좀비프로세스

좀비 프로세스(zombie process)는 운영 체제에서 종료된 프로세스이지만, 여전히 프로세스 테이블에 남아 있는 상태를 말합니다. 이는 부모 프로세스가 자식 프로세스의 종료 상태를 수집하지 않았기 때문에 발생합니다.

1. **좀비 프로세스의 특징**

   1. **종료 상태 유지**

      좀비 프로세스는 이미 실행을 마친 상태지만, 종료 코드와 같은 정보를 보유하고 있습니다.

   2. **부모 프로세스 필요**

      자식 프로세스가 종료되면, 부모 프로세스가 wait() 시스템 호출을 통해 종료 상태를 수집해야 합니다. 이를 수행하지 않으면 자식 프로세스는 좀비 상태로 남게 됩니다.

   3. **자원 소모**

      좀비 프로세스는 메모리와 같은 자원을 차지하지 않지만, 프로세스 테이블 항목을 차지하므로, 시스템에 좀비 프로세스가 너무 많아지면 새로운 프로세스를 생성하는 데 문제가 발생할 수 있습니다.

2. **좀비 프로세스 해결 방법**

   1. **부모 프로세스 수정**

      부모 프로세스에서 자식 프로세스의 종료 상태를 적절히 수집하도록 코드를 수정합니다. 일반적으로 wait() 또는 waitpid() 함수를 사용합니다.

   2. **부모 프로세스가 종료**

      부모 프로세스가 종료되면, 좀비 프로세스는 init 프로세스(또는 시스템의 첫 번째 프로세스)로 대체되어, 해당 프로세스가 종료 상태를 수집합니다.

좀비 프로세스는 일반적으로 시스템의 안정성에 영향을 미치지 않지만, 너무 많이 쌓이면 리소스 문제를 일으킬 수 있으므로 관리가 필요합니다.

## TCP, UDP

TCP(Transmission Control Protocol)와 UDP(User Datagram Protocol)는 인터넷 프로토콜 스위트의 두 가지 주요 전송 프로토콜로, 데이터 전송 방식이 다릅니다.

1. **TCP (Transmission Control Protocol)**

   1. **연결 지향**: 데이터 전송 전에 송신자와 수신자 간의 연결을 설정합니다.

   2. **신뢰성**: 데이터가 손실되지 않도록 확인하는 기능이 있습니다. 전송된 데이터 패킷에 대한 응답을 받고, 손실된 패킷을 재전송합니다.

   3. **순서 보장**: 데이터 패킷이 전송된 순서대로 수신되도록 보장합니다.

   4. **흐름 제어**: 수신자가 데이터를 처리할 수 있는 속도로 송신자가 전송하도록 조절합니다.

   5. **사용 예**: 웹 페이지 로딩(HTTP/HTTPS), 파일 전송(FTP), 이메일(SMTP) 등 신뢰성이 중요한 경우에 사용됩니다.

2. **UDP (User Datagram Protocol)**

   1. **비연결 지향**: 데이터 전송 전에 연결을 설정하지 않습니다. 패킷을 독립적으로 전송합니다.

   2. **신뢰성 없음**: 데이터 전송의 성공 여부를 확인하지 않으며, 손실된 패킷을 재전송하지 않습니다.

   3. **순서 보장 없음**: 데이터 패킷이 수신된 순서와 관계없이 도착할 수 있습니다.

   4. **흐름 제어 없음**: 송신 속도를 조절하지 않으며, 수신자가 처리할 수 있는 속도를 고려하지 않습니다.

   5. **사용 예**: 실시간 게임, 비디오 스트리밍, 음성 통화(VoIP) 등 신뢰성보다 속도가 중요한 경우에 사용됩니다.

3. **요약**

   - **TCP**: 신뢰성과 순서 보장이 필요한 데이터 전송에 적합합니다.

   - **UDP**: 빠른 전송 속도가 필요한 경우에 적합합니다.

## npm

package.json은 Node.js 프로젝트의 메타데이터를 포함하는 파일로, 프로젝트의 설정, 의존성, 스크립트 등을 관리합니다. 주요 내용은 다음과 같습니다:

1. **주요 구성 요소**

   - **name**: 프로젝트의 이름. npm에서 패키지를 식별하는 데 사용됩니다.

   - **version**: 프로젝트의 버전. 주로 semver(Semantic Versioning) 형식으로 작성됩니다.

   - **description**: 프로젝트에 대한 간단한 설명.

   - **main**: 애플리케이션의 진입점 파일. 일반적으로 index.js와 같은 파일을 지정합니다.

   - **scripts**: 프로젝트에서 자주 사용하는 명령어를 정의할 수 있는 섹션입니다. 예를 들어, npm start를 사용해 서버를 시작하는 스크립트를 설정할 수 있습니다.

   - **dependencies**: 애플리케이션이 실행되기 위해 필요한 패키지를 나열합니다.

   - **devDependencies**: 개발 과정에서만 필요한 패키지를 나열합니다. 예를 들어 테스트 도구나 빌드 도구 등이 포함됩니다.

   - **keywords**: 프로젝트와 관련된 키워드 목록. npm 레지스트리에서 검색할 때 유용합니다.

   - **author**: 프로젝트 작성자의 이름.

   - **license**: 프로젝트의 라이센스 정보. 예를 들어 MIT, Apache-2.0 등.

### SemVer

Semantic Versioning (세마틱 버저닝)은 소프트웨어의 버전 번호를 체계적으로 관리하기 위한 규칙입니다. 일반적으로 "SemVer"라고도 불리는 이 규칙은 소프트웨어의 버전을 다음과 같은 형식으로 정의합니다:

```
MAJOR.MINOR.PATCH
```

1. 각 부분의 의미는 다음과 같습니다:

   1. **MAJOR (주 버전)**:

      1. 주요 변경사항이 있을 때 증가합니다.

      2. 이 변경사항은 보통 하위 호환성을 깨트리는 변경(예: API의 변경이나 제거)을 포함합니다.

   2. **MINOR (부 버전)**:

      1. 새로운 기능이 추가되거나 기존 기능이 개선되지만 하위 호환성이 유지될 때 증가합니다.

      2. 이 변경사항은 기존 사용자에게 새로운 기능을 제공하면서도 기존 코드에 영향을 미치지 않도록 합니다.

   3. **PATCH (수정 버전)**:

      1. 버그 수정이나 작은 변경사항이 있을 때 증가합니다.

      2. 이 버전은 기능 추가 없이 버그를 수정하여 소프트웨어의 안정성을 개선합니다.

2. **예시**

   - **1.0.0**: 첫 번째 안정적인 릴리스.

   - **1.1.0**: 새로운 기능이 추가되었으나 기존 기능은 여전히 호환됨.

   - **2.0.0**: 하위 호환성을 깨트리는 큰 변경사항이 포함됨.

   - **2.0.1**: 버그가 수정된 패치 버전.

3. **장점**

   1. **명확한 의미 전달**: 버전 번호를 통해 변경사항의 성격을 쉽게 이해할 수 있습니다.

   2. **호환성 관리**: 소프트웨어의 사용자는 각 버전의 변경사항에 따라 얼마나 영향을 받을지 예측할 수 있습니다.

   3. **자동화**: CI/CD 파이프라인에서 버전 관리를 자동화하는 데 유용합니다.

4. **사용 사례**

   세마틱 버저닝은 오픈 소스 프로젝트, 라이브러리, API 등 다양한 소프트웨어 개발에서 널리 사용됩니다. 이를 통해 개발자와 사용자 간의 소통을 원활하게 하고, 소프트웨어의 안정성을 높일 수 있습니다.

## npm install

1. **package.json 확인**

   명령어를 실행하면, 현재 디렉토리에서 package.json 파일을 찾아서 의존성 목록을 확인합니다. 이 파일에는 설치해야 할 패키지와 그 버전 정보가 포함되어 있습니다.

2. **의존성 다운로드**

   dependencies 및 devDependencies에 나열된 패키지를 npm 또는 Yarn 레지스트리에서 다운로드합니다. 각 패키지의 버전은 package.json에 지정된 대로 설치됩니다.
   패키지가 다른 패키지에 의존하는 경우, 해당 의존성도 자동으로 다운로드됩니다.

3. **package-lock.json 또는 yarn.lock 생성/업데이트**

   - **npm**: npm install을 실행하면 package-lock.json 파일이 생성되거나 업데이트됩니다. 이 파일은 설치된 패키지의 정확한 버전 및 의존성 트리를 기록하여, 이후 동일한 패키지 설치 시 일관성을 보장합니다.

   - **Yarn**: yarn install을 실행하면 yarn.lock 파일이 생성되거나 업데이트됩니다. 이 파일 역시 의존성 버전과 트리를 기록하여, 일관된 설치를 보장합니다.

4. **노드 모듈 설치**:
   의존성 패키지는 node_modules 디렉토리에 설치됩니다. 이 디렉토리는 프로젝트의 루트 디렉토리에 생성되며, 다운로드된 모든 패키지가 이곳에 위치하게 됩니다.

5. **스크립트 실행 (선택 사항)**:
   package.json의 scripts 섹션에 정의된 postinstall 스크립트가 있는 경우, 설치가 완료된 후 자동으로 해당 스크립트가 실행됩니다. 이는 패키지 설치 후 추가적인 설정이나 구성을 위해 사용될 수 있습니다.

6. **캐시 사용**:
   npm과 Yarn 모두 의존성을 다운로드할 때, 로컬 캐시를 활용하여 이미 다운로드된 패키지를 재사용합니다. 이는 설치 시간을 단축시킵니다.

## db 관계형 비관계형 차이

관계형 데이터베이스(RDBMS)와 비관계형 데이터베이스(NoSQL)는 데이터 저장 및 관리 방식에서 큰 차이를 보이는 두 가지 유형의 데이터베이스입니다.

1. **관계형 데이터베이스 (RDBMS)**

   - **구조화된 데이터**: 데이터가 테이블 형식(행과 열)으로 구성되며, 각 테이블은 명확한 스키마(데이터 구조)를 갖습니다.

   - **SQL 사용**: 데이터 쿼리와 조작을 위해 SQL(Structured Query Language)을 사용합니다.

   - **관계**: 테이블 간에 관계를 설정할 수 있으며, 이를 통해 데이터의 무결성을 유지합니다. 예를 들어, 외래 키(foreign key)를 사용하여 테이블 간의 관계를 정의합니다.

   - **ACID 특성**: 원자성(Atomicity), 일관성(Consistency), 고립성(Isolation), 내구성(Durability)을 지원하여 데이터의 안정성과 무결성을 보장합니다.

     - **ACID**

       1. **A(Atomicity)**: 트랜잭션은 모든 작업이 성공적으로 완료되거나 전혀 수행되지 않아야 합니다. 즉, 트랜잭션 내의 모든 작업이 완료되지 않으면, 시스템은 이전 상태로 롤백됩니다.

       2. **C(Consistency)**: 트랜잭션이 수행되기 전과 후에 데이터베이스의 일관성이 유지되어야 합니다. 모든 트랜잭션은 데이터베이스를 유효한 상태에서 유효한 상태로 변환해야 합니다.

       3. **I(Isolation)**: 동시에 수행되는 트랜잭션들은 서로 독립적으로 실행되어야 하며, 하나의 트랜잭션이 다른 트랜잭션에 영향을 미치지 않도록 보장합니다. 이는 트랜잭션의 중간 결과가 외부에 노출되지 않도록 합니다.

       4. **D(Durability)**: 트랜잭션이 완료된 후, 그 결과는 시스템 장애가 발생하더라도 영구적으로 저장되어야 합니다. 즉, 성공적으로 수행된 트랜잭션의 결과는 항상 데이터베이스에 남아야 합니다.

   - **예시**: MySQL, PostgreSQL, Oracle, Microsoft SQL Server 등이 있습니다.

2. **비관계형 데이터베이스 (NoSQL)**

   - **비구조화된 데이터**: 데이터가 테이블 형식이 아닌 다양한 형식(문서, 키-값, 그래프 등)으로 저장될 수 있습니다. 스키마가 유연하여 데이터 구조가 변화해도 쉽게 대응할 수 있습니다.

   - **쿼리 언어**: SQL 대신 각 데이터베이스에 맞는 API 또는 쿼리 언어를 사용합니다.

   - **수평 확장성**: 데이터베이스를 여러 서버에 분산하여 저장할 수 있어 대량의 데이터를 쉽게 처리할 수 있습니다.

   - **CAP 이론**: 일관성(Consistency), 가용성(Availability), 파티션 허용성(Partition Tolerance) 중 두 가지를 동시에 만족하기 어려운 상황을 설명합니다. 대부분의 NoSQL 데이터베이스는 가용성과 파티션 허용성을 우선시합니다.

   - **CAP이론**

     - **C(Consistency)**: 모든 노드가 동일한 데이터를 유지하는 것을 의미합니다. 즉, 어떤 노드에서 데이터가 변경되면, 모든 노드가 즉시 업데이트되어야 합니다.

     - **A(Availability)**: 모든 요청에 대해 응답을 보장하는 것입니다. 시스템이 작동 중일 때, 사용자는 항상 응답을 받을 수 있어야 합니다.

     - **P(Partition Tolerance)**: 네트워크 파티션이 발생하더라도 시스템이 계속해서 운영될 수 있는 능력을 의미합니다. 즉, 일부 노드가 서로 통신할 수 없더라도 시스템이 기능을 유지해야 합니다.

   - **예시**: MongoDB(문서 기반), Redis(키-값 저장소), Cassandra(열 기반), Neo4j(그래프 데이터베이스) 등이 있습니다.

3. **요약**

   - **관계형 데이터베이스**: 구조화된 데이터, 엄격한 스키마, SQL 사용, ACID 특성을 가진 데이터베이스로, 금융, 기업 데이터 등 신뢰성과 무결성이 중요한 경우에 적합합니다.

   - **비관계형 데이터베이스**: 비구조화된 데이터, 유연한 스키마, 수평 확장성을 갖춘 데이터베이스로, 소셜 미디어, 실시간 분석, 빅데이터 등 다양한 데이터 유형을 처리하는 데 적합합니다.
