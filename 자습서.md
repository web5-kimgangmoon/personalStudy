# 목차

1. **RESTful API**
   1. **REST**
2. **동기와 비동기**
3. **async/await**
   1. **RxJS**
   2. **데이터의 스트림 형태**
   3. **yield, 제너레이터(python)**
4. **Promise**
5. **CICD**
6. **좀비프로세스**
7. **TCP, UDP**
8. **npm**
   1. **SemVer**
9. **npm install**
10. **db 관계형 비관계형 차이**
11. **HTTP와 HTTPS의 차이**
    1. **SSL/TLS**
12. **브라우저 엔진은?**
13. **JIT**
14. **컴파일**
15. **Docker**
    1. **컨테이너**
    2. **컨테이너의 가상화**
16. **Typescript 쓰는 이유**
17. **ECMA**
    1. **하위 호환성**
18. **클라이언트 서버 구조**
    1. **클라이언트 서버 모델의 특징**
19. **세션, 쿠키, 캐시**
20. **웹 보안**
    1. **MFA**
    2. **IDP/IPS (Intrusion Detection System / Intrusion Prevention System)**
21. **성능 최적화 방법**
    1. **정규화 (Normal Form)**
    2. **CDN(Content Delivery Network)**
    3. **스케일 업(Scale Up)**
    4. **스케일 아웃(Scale Out)**
22. **db의 종류**
23. **백엔드 프레임워크의 종류**
    1. **AOP**
    2. **프레임워크(JS 기반)**

## RESTful API

RESTful API는 Representational State Transfer(REST) 원칙을 따르는 웹 서비스 인터페이스입니다. REST는 클라이언트와 서버 간의 상호작용을 정의하는 아키텍처 스타일로, 다음과 같은 주요 개념이 있습니다:

1. **자원(Resource)**

   REST API는 URI(Uniform Resource Identifier)를 사용하여 자원을 식별합니다. 각 자원은 고유한 URI로 접근할 수 있습니다.

2. **HTTP 메서드**

   REST API는 다음과 같은 HTTP 메서드를 사용하여 자원에 대한 작업을 수행합니다:

   1. **GET**: 자원 조회

   2. **POST**: 새로운 자원 생성

   3. **PUT**: 자원 전체 업데이트

   4. **PATCH**: 자원 부분 업데이트

   5. **DELETE**: 자원 삭제

3. **상태 비저장성(Stateless)**

   REST API의 각 요청은 독립적이며, 서버는 클라이언트의 상태를 저장하지 않습니다. 모든 필요한 정보는 클라이언트가 요청에 포함시켜야 합니다.

4. **표현(Representation)**

   자원은 다양한 형식(예: JSON, XML)으로 표현될 수 있습니다. 클라이언트는 원하는 형식을 서버에 요청할 수 있습니다.

5. **캐싱(Caching)**

   REST는 응답을 캐시할 수 있는 기능을 제공하여 성능을 향상시킬 수 있습니다.

6. **계층화(Layered System)**

   REST 아키텍처는 여러 계층으로 구성될 수 있으며, 클라이언트는 중간 서버의 존재를 알지 못합니다.

   - **예시**: 간단한 RESTful API의 예시는 다음과 같습니다:

     - **GET /api/users**: 모든 사용자 조회

     - **GET /api/users/1**: 특정 사용자 조회

     - **POST /api/users**: 새로운 사용자 생성

     - **PUT /api/users/1**: 특정 사용자 정보 업데이트

     - **DELETE /api/users/1**: 특정 사용자 삭제

이와 같은 RESTful API는 클라이언트와 서버 간의 상호작용을 간결하고 일관성 있게 만들어줍니다.

### REST

REST(Representational State Transfer)는 웹 서비스 설계 원칙으로, 다음과 같은 특징이 있습니다.

1. **무상태성**: 각 요청은 독립적이며, 서버는 클라이언트의 상태를 저장하지 않습니다. 클라이언트는 모든 필요한 정보를 요청에 포함해야 합니다.

2. **자원 지향**: 모든 자원은 URI(Uniform Resource Identifier)로 식별되며, 클라이언트는 이 URI를 통해 자원에 접근합니다.

3. **표현**: 자원은 다양한 형식(예:JSON, XML)으로 표현될 수 있으며, 클라이언트는 원하는 형식을 요청할 수 있습니다.

4. **HTTP 메서드**: CRUD(Create, Read, Update, Delete) 작업은 HTTP 메서드(GET, POST, PUT, DELETE 등)를 사용하여 수행됩니다.

5. **계층화 시스템**: 클라이언트는 서버와 직접 통신하는 것이 아니라, 중간 서버(프록시, 게이트웨이 등)를 통해 통신할 수 있습니다.

## 동기와 비동기

통신에서 동기(Synchronous)와 비동기(Asynchronous) 처리는 데이터 전송 및 응답을 처리하는 방식에 대한 개념입니다. 각각의 차이점을 살펴보면 다음과 같습니다:

1. **동기(Synchronous)**

   - **정의**

     요청을 보낸 후, 응답을 받을 때까지 기다리는 방식입니다. 즉, 다음 작업을 수행하기 전에 반드시 응답을 받아야 합니다.

   - **특징**

     코드의 흐름이 요청과 응답에 따라 직선적으로 진행됩니다.
     사용자가 기다리는 동안 UI가 정지할 수 있습니다(특히 브라우저의 경우).
     구현이 간단하고 이해하기 쉬운 경우가 많습니다.

   - **예시**

     JavaScript의 XMLHttpRequest를 사용할 때 async를 false로 설정하면 동기 방식으로 요청이 처리됩니다.

2. **비동기(Asynchronous)**

   - **정의**

     요청을 보낸 후, 응답을 기다리지 않고 다음 작업을 수행하는 방식입니다. 응답은 나중에 받을 수 있으며, 일반적으로 콜백이나 프로미스를 사용하여 처리합니다.

   - **특징**

     코드의 흐름이 요청과 응답과 독립적입니다. 사용자가 기다리는 동안 UI가 정상적으로 작동하며, 더 나은 사용자 경험을 제공합니다. 복잡한 비즈니스 로직을 구현할 때 유용합니다.

## async/await

- **Promise**

  JavaScript의 기본 비동기 처리 방법입니다. then()과 catch() 메서드를 사용하여 비동기 작업의 결과를 처리합니다.

- **콜백 함수**

  전통적인 방식으로, 비동기 작업이 완료된 후 호출되는 함수를 정의하여 결과를 처리합니다. 하지만 콜백 헬(callback hell) 문제로 코드 가독성이 떨어질 수 있습니다.

- **RxJS**

  Reactive Programming 라이브러리로, 스트림을 통해 비동기 데이터를 처리할 수 있습니다. 복잡한 비동기 로직을 간결하게 표현할 수 있습니다.

- **Generator 함수(python)**

  function\* 문법을 사용하여 제너레이터를 생성하고, yield 키워드를 통해 비동기 처리를 할 수 있습니다. co 라이브러리와 함께 사용하면 비동기 코드 작성이 더 수월해질 수 있습니다.

- **EventEmitter**

  Node.js의 이벤트 기반 프로그래밍 패턴을 사용하여 이벤트가 발생할 때 비동기 처리를 수행할 수 있습니다.

### RxJS

RxJS (Reactive Extensions for JavaScript)는 비동기 데이터 흐름을 처리하기 위한 라이브러리로, 옵저버블 패턴을 사용하여 데이터를 스트림 형태로 다룹니다. 이를 통해 이벤트, AJAX 요청, 사용자 입력 등 다양한 비동기 작업을 쉽게 처리할 수 있습니다.

1. **주요 개념**

   1. **옵저버블 (Observable)**

      데이터 스트림을 나타내며, 데이터를 발행하는 주체입니다. 옵저버블은 여러 구독자(옵저버)를 가질 수 있습니다.

   2. **옵저버 (Observer)**

      옵저버블을 구독하고, 데이터가 발행될 때마다 알림을 받는 객체입니다.

   3. **구독 (Subscription)**

      옵저버블을 구독하는 행위로, 데이터가 발행되면 콜백이 실행됩니다.

   4. **연산자 (Operators)**

      옵저버블을 변환하거나 조작하는 함수들입니다. 예를 들어, map, filter, merge, switchMap 등의 연산자가 있습니다.

2. **기본 사용법**

   RxJS를 사용하기 위해선 먼저 라이브러리를 설치해야 합니다.

   ```bash
   npm install rxjs
   ```

   ```js
   import { Observable } from "rxjs";

   // 옵저버블 생성
   const myObservable = new Observable((subscriber) => {
     subscriber.next("Hello");
     subscriber.next("World");
     subscriber.complete(); // 스트림 종료
   });

   const myObserver = {
     next: (value) => console.log(value),
     error: (err) => console.error(err),
     complete: () => console.log("Done"),
   };

   // 옵저버블 구독
   myObervable.subscribe(myObserver);
   ```

3. **연산자 사용 예제**

   ```js
   import { of } from "rxjs";
   import { map, filter } from "rxjs/operators";

   const numbers = of(1, 2, 3, 4, 5);

   // 연산자를 사용한 예제
   const processedNumbers = numbers.pipe(
     filter((x) => x % 2 === 0), // 짝수만 통과
     map((x) => x * 10) // 각 숫자에 10 곱하기
   );

   processedNumbers.subscribe(console.log); // 20, 40
   ```

4. **장점**

   1. **비동기 처리**

      콜백 지옥을 피하고, 비동기 작업을 더 쉽게 관리할 수 있습니다.

   2. **구성 가능성**

      연산자 체이닝을 통해 복잡한 비즈니스 로직을 간단하게 표현할 수 있습니다.

   3. **응답성**

      다양한 데이터 소스를 통합하고, 응답성을 유지할 수 있습니다.

### 데이터의 스트림 형태

데이터의 스트림 형태는 데이터를 연속적으로 생성하고 처리하는 방식을 나타냅니다. 이는 주로 비동기적이고 이벤트 기반의 프로그래밍에서 중요합니다. RxJS와 같은 라이브러리를 통해 이 스트림을 쉽게 다룰 수 있습니다.

1. **스트림의 기본 개념**

   1. **스트림**

      데이터의 연속적인 흐름을 나타냅니다. 스트림은 시간에 따라 변화하는 데이터 시퀀스를 의미합니다. 예를 들어, 사용자 입력, 웹 소켓 메시지, AJAX 요청 등이 있습니다.

   2. **발행자 (Publisher)**

      데이터를 생성하고 스트림에 발행하는 주체입니다. 이는 옵저버블 형태로 구현됩니다.

   3. **구독자 (Subscriber)**

      스트림의 데이터를 소비하고 반응하는 주체입니다. 구독자는 발행자가 발행하는 데이터에 대해 반응합니다.

   4. **변환 및 조작**

      스트림의 데이터를 변환하거나 필터링하는 연산자들이 사용됩니다. 이들은 데이터 흐름을 제어하는 데 도움을 줍니다.

2. **스트림의 종류**

   1. **단방향 스트림**

      데이터가 한 반향으로만 흐릅니다. 예를 들어, 이벤트 스트림(클릭, 입력 등)이 있습니다.

   2. **양방향 스트림**

      데이터가 양 방향으로 흐를 수 있습니다. 예를 들어, 웹 소켓 통신이 있습니다.

3. **스트림 처리의 장점**

   1. **비동기 처리**

   데이터가 준비되는 대로 처리할 수 있어 응답성이 향상됩니다.

   2. **조합 가능성**

   여러 데이터 소스를 하나의 스트림으로 결합하여 복잡한 데이터 흐름을 관리할 수 있습니다.

   3. **지연 평가**

   필요할 때만 데이터를 처리하므로 효율성을 높일 수 있습니다.

4. **예시**

   여기 사용자 클릭 이벤트를 처리하는 간단한 예제가 있습니다.

   ```js
   import { fromEvent } from "rxjs";
   import { map } from "rxjs/operators";

   // 버튼 클릭 이벤트 스트림 생성
   const button = document.getElementById("myButton");
   const clicks = fromEvent(button, "click");

   // 클릭 이벤트를 처리하여 좌표를 로그에 남김
   const positions = clicks.pipe(
     map((event) => ({ x: event.clientX, y: event.clientY }))
   );

   positions.subscribe((pos) => console.log(`X: ${pos.x}, Y: ${pos.y}`));
   ```

   위의 예제에서 fromEvent는 버튼 클릭 이벤트를 옵저버블로 변환하고, 클릭할 때마다 좌표를 로그에 남깁니다. 스트림은 사용자가 버튼을 클릭할 때마다 데이터(좌표)를 발행합니다.

### yield, 제너레이터(python)

yield 키워드는 python에서 제너레이터를 만들기 위해 사용됩니다. 제너레이터는 이터레이터의 일종으로, 값을 한 번에 하나씩 생성할 수 있게 해줍니다. yield를 사용하면 함수의 상태를 유지하면서 반복적으로 값을 반환할 수 있습니다.

1. **제너레이터의 기본 사용법**

   1. **제너레이터 함수 정의**

      yield를 사용하여 제너레이터 함수를 정의합니다.

   2. **제너레이터 객체 생성**

      함수를 호출하면 제너레이터 객체가 생성됩니다.

   3. **값 생성**

      next() 함수를 사용하여 다음 값을 얻거나, for 루프를 통해 반복할 수 있습니다.

   4. **예제**

      ```python
      def countdown(n):
            while n > 0:
               yield n
               n -= 1

      # 제너레이터 객체 생성
      gen = countdown(5)

      # 값 생성
      for number in gen:
         print(number)
      ```

   이 예제에서 countdown 함수는 5부터 1까지의 값을 생성합니다. yield 키워드 덕분에 함수는 값을 반환한 후 상태를 유지할 수 있어, 다음 호출 시 중단한 지점부터 실행됩니다.

2. **제너레이터의 장점**

   1. **메모리 효율성**

      모든 값을 한 번에 메모리에 저장하지 않기 때문에 큰 데이터셋을 처리할 때 유용합니다.

   2. **지연 평가**

      필요할 때만 값을 생성하여 성능을 최적화할 수 있습니다.

## Promise

Promise는 JavaScript에서 비동기 작업을 처리하기 위한 객체입니다. 주로 비동기 연산의 성공 또는 실패 결과를 다루기 위해 사용됩니다. Promise는 세 가지 상태를 가집니다.

1. **대기(pending)**

   초기 상태로, 비동기 작업이 아직 완료되지 않은 상태입니다.

2. **이행(fulfilled)**

   비동기 작업이 성공적으로 완료되었을 떄의 상태입니다. 이 경우, 결과 값을 반환합니다.

3. **거부(rejected)**

   비동기 작업이 실패했을 때의 상태입니다. 이 경우, 오류 이유를 반환합니다.

## CICD

CI/CD는 소프트웨어 개발 프로세스를 자동화하는 중요한 개념입니다. 각각의 의미는 다음과 같습니다:

1. **CI (Continuous Integration)**

   - **지속적 통합**

     개발자들이 코드를 자주 (보통 하루에 여러 번) 통합하는 방법입니다. 각 코드 변경 사항은 자동으로 빌드되고 테스트되어, 통합 후 발생할 수 있는 문제를 빠르게 발견할 수 있습니다. 이를 통해 코드 품질을 높이고, 팀의 협업을 원활하게 합니다.

2. **CD (Continuous Delivery / Continuous Deployment)**

   CI의 확장으로, 코드 변경 사항이 자동으로 프로덕션 환경에 배포되는 프로세스입니다.

   - **Continuous Delivery**

     모든 코드 변경이 테스트를 통과하면 언제든지 배포할 준비가 되어 있는 상태입니다. 배포는 수동으로 진행됩니다.

   - **Continuous Deployment**

     코드 변경이 자동으로 프로덕션 환경에 배포됩니다. 모든 테스트가 통과하면 추가적인 승인 없이 배포가 이루어집니다.

3. **장점**

   - **빠른 피드백**

     개발자가 코드를 변경할 때마다 자동으로 테스트가 이루어져, 문제를 조기에 발견할 수 있습니다.

   - **일관된 품질**

     자동화된 테스트와 빌드를 통해 품질이 일관되게 유지됩니다.

   - **신속한 배포**

     새로운 기능이나 수정 사항을 신속하게 사용자에게 제공할 수 있습니다.

   - **효율적인 협업**

     팀원 간의 코드 충돌을 줄이고, 통합 과정에서 발생할 수 있는 문제를 조기에 해결합니다.

## 좀비프로세스

좀비 프로세스(zombie process)는 운영 체제에서 종료된 프로세스이지만, 여전히 프로세스 테이블에 남아 있는 상태를 말합니다. 이는 부모 프로세스가 자식 프로세스의 종료 상태를 수집하지 않았기 때문에 발생합니다.

1. **좀비 프로세스의 특징**

   1. **종료 상태 유지**

      좀비 프로세스는 이미 실행을 마친 상태지만, 종료 코드와 같은 정보를 보유하고 있습니다.

   2. **부모 프로세스 필요**

      자식 프로세스가 종료되면, 부모 프로세스가 wait() 시스템 호출을 통해 종료 상태를 수집해야 합니다. 이를 수행하지 않으면 자식 프로세스는 좀비 상태로 남게 됩니다.

   3. **자원 소모**

      좀비 프로세스는 메모리와 같은 자원을 차지하지 않지만, 프로세스 테이블 항목을 차지하므로, 시스템에 좀비 프로세스가 너무 많아지면 새로운 프로세스를 생성하는 데 문제가 발생할 수 있습니다.

2. **좀비 프로세스 해결 방법**

   1. **부모 프로세스 수정**

      부모 프로세스에서 자식 프로세스의 종료 상태를 적절히 수집하도록 코드를 수정합니다. 일반적으로 wait() 또는 waitpid() 함수를 사용합니다.

   2. **부모 프로세스가 종료**

      부모 프로세스가 종료되면, 좀비 프로세스는 init 프로세스(또는 시스템의 첫 번째 프로세스)로 대체되어, 해당 프로세스가 종료 상태를 수집합니다.

좀비 프로세스는 일반적으로 시스템의 안정성에 영향을 미치지 않지만, 너무 많이 쌓이면 리소스 문제를 일으킬 수 있으므로 관리가 필요합니다.

## TCP, UDP

TCP(Transmission Control Protocol)와 UDP(User Datagram Protocol)는 인터넷 프로토콜 스위트의 두 가지 주요 전송 프로토콜로, 데이터 전송 방식이 다릅니다.

1. **TCP (Transmission Control Protocol)**

   1. **연결 지향**: 데이터 전송 전에 송신자와 수신자 간의 연결을 설정합니다.

   2. **신뢰성**: 데이터가 손실되지 않도록 확인하는 기능이 있습니다. 전송된 데이터 패킷에 대한 응답을 받고, 손실된 패킷을 재전송합니다.

   3. **순서 보장**: 데이터 패킷이 전송된 순서대로 수신되도록 보장합니다.

   4. **흐름 제어**: 수신자가 데이터를 처리할 수 있는 속도로 송신자가 전송하도록 조절합니다.

   5. **사용 예**: 웹 페이지 로딩(HTTP/HTTPS), 파일 전송(FTP), 이메일(SMTP) 등 신뢰성이 중요한 경우에 사용됩니다.

2. **UDP (User Datagram Protocol)**

   1. **비연결 지향**: 데이터 전송 전에 연결을 설정하지 않습니다. 패킷을 독립적으로 전송합니다.

   2. **신뢰성 없음**: 데이터 전송의 성공 여부를 확인하지 않으며, 손실된 패킷을 재전송하지 않습니다.

   3. **순서 보장 없음**: 데이터 패킷이 수신된 순서와 관계없이 도착할 수 있습니다.

   4. **흐름 제어 없음**: 송신 속도를 조절하지 않으며, 수신자가 처리할 수 있는 속도를 고려하지 않습니다.

   5. **사용 예**: 실시간 게임, 비디오 스트리밍, 음성 통화(VoIP) 등 신뢰성보다 속도가 중요한 경우에 사용됩니다.

3. **요약**

   - **TCP**: 신뢰성과 순서 보장이 필요한 데이터 전송에 적합합니다.

   - **UDP**: 빠른 전송 속도가 필요한 경우에 적합합니다.

## npm

package.json은 Node.js 프로젝트의 메타데이터를 포함하는 파일로, 프로젝트의 설정, 의존성, 스크립트 등을 관리합니다. 주요 내용은 다음과 같습니다:

1. **주요 구성 요소**

   - **name**: 프로젝트의 이름. npm에서 패키지를 식별하는 데 사용됩니다.

   - **version**: 프로젝트의 버전. 주로 semver(Semantic Versioning) 형식으로 작성됩니다.

   - **description**: 프로젝트에 대한 간단한 설명.

   - **main**: 애플리케이션의 진입점 파일. 일반적으로 index.js와 같은 파일을 지정합니다.

   - **scripts**: 프로젝트에서 자주 사용하는 명령어를 정의할 수 있는 섹션입니다. 예를 들어, npm start를 사용해 서버를 시작하는 스크립트를 설정할 수 있습니다.

   - **dependencies**: 애플리케이션이 실행되기 위해 필요한 패키지를 나열합니다.

   - **devDependencies**: 개발 과정에서만 필요한 패키지를 나열합니다. 예를 들어 테스트 도구나 빌드 도구 등이 포함됩니다.

   - **keywords**: 프로젝트와 관련된 키워드 목록. npm 레지스트리에서 검색할 때 유용합니다.

   - **author**: 프로젝트 작성자의 이름.

   - **license**: 프로젝트의 라이센스 정보. 예를 들어 MIT, Apache-2.0 등.

### SemVer

Semantic Versioning (세마틱 버저닝)은 소프트웨어의 버전 번호를 체계적으로 관리하기 위한 규칙입니다. 일반적으로 "SemVer"라고도 불리는 이 규칙은 소프트웨어의 버전을 다음과 같은 형식으로 정의합니다:

```
MAJOR.MINOR.PATCH
```

1. 각 부분의 의미는 다음과 같습니다:

   1. **MAJOR (주 버전)**:

      1. 주요 변경사항이 있을 때 증가합니다.

      2. 이 변경사항은 보통 하위 호환성을 깨트리는 변경(예: API의 변경이나 제거)을 포함합니다.

   2. **MINOR (부 버전)**:

      1. 새로운 기능이 추가되거나 기존 기능이 개선되지만 하위 호환성이 유지될 때 증가합니다.

      2. 이 변경사항은 기존 사용자에게 새로운 기능을 제공하면서도 기존 코드에 영향을 미치지 않도록 합니다.

   3. **PATCH (수정 버전)**:

      1. 버그 수정이나 작은 변경사항이 있을 때 증가합니다.

      2. 이 버전은 기능 추가 없이 버그를 수정하여 소프트웨어의 안정성을 개선합니다.

2. **예시**

   - **1.0.0**: 첫 번째 안정적인 릴리스.

   - **1.1.0**: 새로운 기능이 추가되었으나 기존 기능은 여전히 호환됨.

   - **2.0.0**: 하위 호환성을 깨트리는 큰 변경사항이 포함됨.

   - **2.0.1**: 버그가 수정된 패치 버전.

3. **장점**

   1. **명확한 의미 전달**: 버전 번호를 통해 변경사항의 성격을 쉽게 이해할 수 있습니다.

   2. **호환성 관리**: 소프트웨어의 사용자는 각 버전의 변경사항에 따라 얼마나 영향을 받을지 예측할 수 있습니다.

   3. **자동화**: CI/CD 파이프라인에서 버전 관리를 자동화하는 데 유용합니다.

4. **사용 사례**

   세마틱 버저닝은 오픈 소스 프로젝트, 라이브러리, API 등 다양한 소프트웨어 개발에서 널리 사용됩니다. 이를 통해 개발자와 사용자 간의 소통을 원활하게 하고, 소프트웨어의 안정성을 높일 수 있습니다.

## npm install

1. **package.json 확인**

   명령어를 실행하면, 현재 디렉토리에서 package.json 파일을 찾아서 의존성 목록을 확인합니다. 이 파일에는 설치해야 할 패키지와 그 버전 정보가 포함되어 있습니다.

2. **의존성 다운로드**

   dependencies 및 devDependencies에 나열된 패키지를 npm 또는 Yarn 레지스트리에서 다운로드합니다. 각 패키지의 버전은 package.json에 지정된 대로 설치됩니다.
   패키지가 다른 패키지에 의존하는 경우, 해당 의존성도 자동으로 다운로드됩니다.

3. **package-lock.json 또는 yarn.lock 생성/업데이트**

   - **npm**: npm install을 실행하면 package-lock.json 파일이 생성되거나 업데이트됩니다. 이 파일은 설치된 패키지의 정확한 버전 및 의존성 트리를 기록하여, 이후 동일한 패키지 설치 시 일관성을 보장합니다.

   - **Yarn**: yarn install을 실행하면 yarn.lock 파일이 생성되거나 업데이트됩니다. 이 파일 역시 의존성 버전과 트리를 기록하여, 일관된 설치를 보장합니다.

4. **노드 모듈 설치**:
   의존성 패키지는 node_modules 디렉토리에 설치됩니다. 이 디렉토리는 프로젝트의 루트 디렉토리에 생성되며, 다운로드된 모든 패키지가 이곳에 위치하게 됩니다.

5. **스크립트 실행 (선택 사항)**:
   package.json의 scripts 섹션에 정의된 postinstall 스크립트가 있는 경우, 설치가 완료된 후 자동으로 해당 스크립트가 실행됩니다. 이는 패키지 설치 후 추가적인 설정이나 구성을 위해 사용될 수 있습니다.

6. **캐시 사용**:
   npm과 Yarn 모두 의존성을 다운로드할 때, 로컬 캐시를 활용하여 이미 다운로드된 패키지를 재사용합니다. 이는 설치 시간을 단축시킵니다.

## db 관계형 비관계형 차이

관계형 데이터베이스(RDBMS)와 비관계형 데이터베이스(NoSQL)는 데이터 저장 및 관리 방식에서 큰 차이를 보이는 두 가지 유형의 데이터베이스입니다.

1. **관계형 데이터베이스 (RDBMS)**

   - **구조화된 데이터**: 데이터가 테이블 형식(행과 열)으로 구성되며, 각 테이블은 명확한 스키마(데이터 구조)를 갖습니다.

   - **SQL 사용**: 데이터 쿼리와 조작을 위해 SQL(Structured Query Language)을 사용합니다.

   - **관계**: 테이블 간에 관계를 설정할 수 있으며, 이를 통해 데이터의 무결성을 유지합니다. 예를 들어, 외래 키(foreign key)를 사용하여 테이블 간의 관계를 정의합니다.

   - **ACID 특성**: 원자성(Atomicity), 일관성(Consistency), 고립성(Isolation), 내구성(Durability)을 지원하여 데이터의 안정성과 무결성을 보장합니다.

     - **ACID**

       1. **A(Atomicity)**: 트랜잭션은 모든 작업이 성공적으로 완료되거나 전혀 수행되지 않아야 합니다. 즉, 트랜잭션 내의 모든 작업이 완료되지 않으면, 시스템은 이전 상태로 롤백됩니다.

       2. **C(Consistency)**: 트랜잭션이 수행되기 전과 후에 데이터베이스의 일관성이 유지되어야 합니다. 모든 트랜잭션은 데이터베이스를 유효한 상태에서 유효한 상태로 변환해야 합니다.

       3. **I(Isolation)**: 동시에 수행되는 트랜잭션들은 서로 독립적으로 실행되어야 하며, 하나의 트랜잭션이 다른 트랜잭션에 영향을 미치지 않도록 보장합니다. 이는 트랜잭션의 중간 결과가 외부에 노출되지 않도록 합니다.

       4. **D(Durability)**: 트랜잭션이 완료된 후, 그 결과는 시스템 장애가 발생하더라도 영구적으로 저장되어야 합니다. 즉, 성공적으로 수행된 트랜잭션의 결과는 항상 데이터베이스에 남아야 합니다.

   - **예시**: MySQL, PostgreSQL, Oracle, Microsoft SQL Server 등이 있습니다.

2. **비관계형 데이터베이스 (NoSQL)**

   - **비구조화된 데이터**: 데이터가 테이블 형식이 아닌 다양한 형식(문서, 키-값, 그래프 등)으로 저장될 수 있습니다. 스키마가 유연하여 데이터 구조가 변화해도 쉽게 대응할 수 있습니다.

   - **쿼리 언어**: SQL 대신 각 데이터베이스에 맞는 API 또는 쿼리 언어를 사용합니다.

   - **수평 확장성**: 데이터베이스를 여러 서버에 분산하여 저장할 수 있어 대량의 데이터를 쉽게 처리할 수 있습니다.

   - **CAP 이론**: 일관성(Consistency), 가용성(Availability), 파티션 허용성(Partition Tolerance) 중 두 가지를 동시에 만족하기 어려운 상황을 설명합니다. 대부분의 NoSQL 데이터베이스는 가용성과 파티션 허용성을 우선시합니다.

   - **CAP이론**

     - **C(Consistency)**: 모든 노드가 동일한 데이터를 유지하는 것을 의미합니다. 즉, 어떤 노드에서 데이터가 변경되면, 모든 노드가 즉시 업데이트되어야 합니다.

     - **A(Availability)**: 모든 요청에 대해 응답을 보장하는 것입니다. 시스템이 작동 중일 때, 사용자는 항상 응답을 받을 수 있어야 합니다.

     - **P(Partition Tolerance)**: 네트워크 파티션이 발생하더라도 시스템이 계속해서 운영될 수 있는 능력을 의미합니다. 즉, 일부 노드가 서로 통신할 수 없더라도 시스템이 기능을 유지해야 합니다.

   - **예시**: MongoDB(문서 기반), Redis(키-값 저장소), Cassandra(열 기반), Neo4j(그래프 데이터베이스) 등이 있습니다.

3. **요약**

   - **관계형 데이터베이스**: 구조화된 데이터, 엄격한 스키마, SQL 사용, ACID 특성을 가진 데이터베이스로, 금융, 기업 데이터 등 신뢰성과 무결성이 중요한 경우에 적합합니다.

   - **비관계형 데이터베이스**: 비구조화된 데이터, 유연한 스키마, 수평 확장성을 갖춘 데이터베이스로, 소셜 미디어, 실시간 분석, 빅데이터 등 다양한 데이터 유형을 처리하는 데 적합합니다.

## HTTP와 HTTPS의 차이

HTTP와 HTTPS의 차이점은 보안입니다. HTTP는 데이터를 암호화하지 않고 전송하지만, HTTPS는 SSL/TLS 프로토콜을 사용하여 데이터를 암호화해 보안을 강화합니다.

### SSL/TLS

SSL("Secure Sockets Layer")과 TLS("Transport Layer Security")는 인터넷에서 데이터 전송 시 보안을 제공하는 프로토콜입니다. SSL은 초기 버전이고 TLS는 그 후속 버전으로 더 안전합니다. 이 프로토콜은 데이터 암호화, 인증 및 무결성을 보장하여 안전한 통신을 가능하게 합니다.

## 브라우저 엔진은?

브라우저 엔진은 웹 브라우저에서 웹 페이지를 렌더링하고 실행하는 핵심 컴포넌트입니다. 주로 두 가지 기능을 수행합니다.

1. **엔진 종류**

   1. **렌더링 엔진**: HTML, CSS, JavaScript를 해석하고 화면에 표시합니다. 예를 들어, Chrome은 Blink, Firefox는 Gecko를 사용합니다.

   2. **JavaScript 엔진**: JavaScript 코드를 실행합니다. Chrome은 V8 엔진을, Firefox는 SpiderMonkey를 사용합니다.

1. **엔진들의 상세설명**

   1. **Blink**

      - **브라우저**: 주로 Google Chrome 및 Chromium 기반 브라우저에서 사용.

      - **기능**: HTML, CSS를 렌더링하고 JavaScript를 실행하는데 최적화되어 있습니다. 빠른 성능과 최신 웹 표준 지원을 강조합니다.

      - **특징**: 오픈 소스이며, 다양한 최적화 기술을 통해 페이지 로딩 속도를 개선합니다. 다양한 기능이 실험적으로 추가되기도 합니다.

   2. **Gecko**

      - **브라우저**: Mozilla Firefox에서 사용

      - **기능**: Blink와 비슷하게 HTML, CSS 및 JavaScript를 처리합니다. 웹 표준을 따르며, 안전성과 보안에 중점을 두고 설계되었습니다.

      - **특징**: Mozilla의 오픈 소스 프로젝트로, 접근성 및 개인 정보 보호 기능에 강점을 보입니다. 다양한 플러그인 및 확장 프로그램을 지원합니다.

   3. **V8**

      - **브라우저**: Google Chrome에서 사용되며, Node.js에서도 사용됩니다.

      - **기능**: JavaScript 코드 실행을 위한 엔진으로, 고속 성능을 자랑합니다. Just-In-Time(JIT) 컴파일을 통해 코드를 실행합니다.

      - **특징**: 크로스 플랫폼에서 작동하며, 최신 ECMAScript(자바스크립트 표준) 기능을 지속적으로 지원합니다.

   4. **SpiderMonkey**

      - **브라우저**: Mozilla Firefox에서 사용

      - **기능**: JavaScript 실행을 위한 엔진으로, JIT 컴파일을 지원합니다.

      - **특징**: 다양한 최신 JavaScript 기능을 지원하며, WebAssembly와 같은 새로운 웹 기술에도 대응합니다.

### JIT

주로 프로그래밍 언어의 실행 속도를 개선하기 위해 사용되는 컴파일 기법입니다. JIT 컴파일러는 프로그램 실행 중에 코드의 일부를 런타임에 컴파일하여 성능을 높입니다.

1. **JIT의 작동 방식**:

   1. **소스 코드**: 원래의 소스 코드가 인터프리터를 통해 실행됩니다.

   2. **컴파일**: 자주 실행되는 코드(핫스팟)을 감지하면 JIT 컴파일러가 해당 코드를 네이티브 머신 코드로 컴파일합니다.

   3. **캐시**: 컴파일된 코드는 캐시에 저장되어 이후 실행 시 빠르게 사용할 수 있습니다.

2. **장점**:

   - **성능 향상**: 반복적으로 실행되는 코드를 최적화하여 속도를 높입니다.

   - **동적 최적화**: 런타임에 코드 실행 패턴을 분석하여 최적화할 수 있습니다.

3. **단점**:

   - **메모리 사용**: JIT 컴파일러는 추가적인 메모리를 사용할 수 있습니다.

   - **초기 지연**: 프로그램 시작 시 코드 컴파일이 필요하기 떄문에 초기 실행 속도가 느릴 수 있습니다.

JIT는 Java의 HotSpot, JavaScript의 V8 엔진 등에서 널리 사용됩니다.

## 컴파일

Compile은 고급 프로그래밍 언어로 작성된 소스코드를 기계어 또는 중간 코드로 변환하는 과정입니다. 이 과정은 컴파일러라는 프로그램에 의해 수행되며, 컴파일된 코드는 실행 가능한 파일이나 바이너리 형태로 저장됩니다. 컴파일은 주로 성능 향상을 위해 이루어지며, 코드의 문법 오류를 사전에 검출할 수 있는 장점도 있습니다.

## Docker

Docker는 컨테이너 기술로, 애플리케이션을 가상화하여 독립적인 환경에서 실행할 수 있게 해줍니다. 이를 통해 개발, 배포, 확장이 용이해지고, 환경 차이로 인한 문제를 줄일 수 있습니다

### 컨테이너

컨테이너는 애플리케이션과 그 실행에 필요한 모든 의존성을 패키징하여 격리된 환경에서 실행할 수 있게 해주는 lightweight한 가상화 기술입니다.

- **주요 특징**:

  1.  **격리성**: 각 컨테이너는 독립적인 환경에서 실행되므로, 다른 컨테이너와의 충돌이 없습니다.

  2.  **경량**: VM(가상 머신)에 비해 리소스를 적게 사용하며, 빠른 시작과 종료가 가능합니다.

  3.  **이식성**: 동일한 컨테이너 이미지를 다양한 환경에서 일관되게 실행할 수 있습니다.

  4.  **버전 관리**: 컨테이너 이미지는 버전 관리가 가능하며, 특정 상태로 쉽게 롤백할 수 있습니다.

컨테이너는 주로 Docker와 같은 도구를 통해 관리합니다.

### 컨테이너의 가상화

컨테이너 가상화는 가상화의 한 형태로, 애플리케이션과 그에 필요한 라이브러리, 종속성 등을 패키징하여 격리된 환경에서 실행할 수 있도록 하는 기술이다.

## Typescript 쓰는 이유

Typescript (TS)는 JavaScript의 상위 집합으로 주로 다음과 같은 이유로 사용됩니다.

1. **정적 타입**: 타입을 명시함으로써 코드 작성 시 오류를 미리 발견할 수 있습니다.

2. **개발 도구 지원**: IntelliSense, 자동 완성 등 다양한 개발 도구의 지원을 통해 생산성을 높입니다.

3. **대규모 프로젝트**: 코드 유지보수와 협업이 용이해지며, 코드 구조를 더 명확하게 할 수 있습니다.

4. **최신 JavaScript 기능**: 최신 ECMAScript 기능을 사용할 수 있으며, 하위 호환성을 유지합니다.

### **ECMA**

ECMA는 "European Computer Manufactures Association"의 약자로 컴퓨터 및 정보 기술 관련 표준을 개발하는 비영리 조직입니다.

- **표준화**: 다양한 프로그래밍 언어와 기술의 표준을 정의합니다. 가장 잘 알려진 표준 중 하나는 ECMAScript로, JavaScript의 기반이 됩니다.

- **기술 규격**: 언어의 문법, 동작 방식 및 API에 대한 규격을 제공합니다.

ECMA는 프로그래밍 언어의 일관성을 보장하고, 상호 운용성을 높이는데 기여합니다.

### 하위 호환성

하위 호환성(Backward Compatibility 또는 Downward Compatibility)은 새로운 버전의 소프트웨어나 시스템이 이전 버전과 호환되어, 이전 버전에서 작성된 코드나 데이터가 새로운 버전에서도 정상적으로 작동하도록 보장하는 개념입니다. 즉, 사용자가 새로운 버전으로 업그레이드해도 기존 기능이나 데이터가 영향을 받지 않고, 계속 사용할 수 있는 상태를 의미합니다.

1. **하위 호환성의 중요성**

   1. **사용자 경험 유지**: 사용자나 개발자는 기존의 코드나 애플리케이션을 변경할 필요 없이 새로운 기능이 개선된 성능을 쉽게 사용할 수 있습니다.

   2. **비용 절감**: 하위 호환성을 유지하면, 기존 시스템을 업데이트하거나 수정하는 데 드는 시간과 비용을 줄일 수 있습니다.

   3. **신뢰성**: 소프트웨어가 안정적으로 작동하면, 사용자와 개발자 모두의 신뢰를 얻을 수 있습니다.

2. **하위 호환성이 필요한 상황**

   - **API 변화**: API를 변경할 때, 기존 클라이언트가 여전히 작동하도록 하기 위해 하위 호환성을 유지하는 것이 중요합니다.

   - **데이터 형식**: 데이터베이스의 스키마를 변경할 때, 이전 데이터가 새로운 스키마에서 문제없이 읽힐 수 있도록 해야 합니다.

   - **소프트웨어 업그레이드**: 운영 체제나 애플리케이션의 새로운 버전을 설치할 때, 기존의 파일이나 설정이 손상되지 않도록 해야 합니다.

3. **하위 호환성의 도전 과제**

   1. **기능 추가와 호환성**: 새로운 기능을 추가하는 과정에서 이전 기능과 충돌하지 않도록 신중하게 설계해야 합니다.

   2. **성능**: 하위 호환성을 유지하는 과정에서 성능이 저하될 수 있으므로, 이를 균형 있게 관리해야 합니다.

   3. **복잡성 증가**: 하위 호환성을 위해 추가적인 코드나 로직을 관리해야 할 수 있어, 소프트웨어의 복잡성이 증가할 수 있습니다.

하위 호환성은 소프트웨어의 진화와 발전에서 매우 중요한 요소이며, 사용자의 요구와 기대를 충족시키는 데 큰 역할을 합니다.

## 클라이언트 서버 구조

클라이언트 서버 모델은 네트워크에서 클라이언트와 서버 간의 상호작용을 정의하는 구조입니다.

- **주요 요소**:

  1.  **클라이언트**: 사용자 요청을 보내고, 서버로부터 데이터를 받는 프로그램이나 장치입니다. 예를 들어, 웹 브라우저가 클라이언트 역할을 합니다.

  2.  **서버**: 클라이언트의 요청을 처리하고, 필요한 데이터를 제공하는 시스템입니다. 웹 서버가 이 역할을 합니다.

- **작동 방식**:
  클라이언트가 서버에 요청을 보내면, 서버는 해당 요청을 처리하고 응답을 클라이언트로 반환합니다. 이 구조는 분산 시스템을 효율적으로 구성하는데 유용합니다.

### 클라이언트 서버 모델의 특징

1. **분리된 역할**:
   클라이언트는 사용자 인터페이스와 사용자 경험을 관리하며, 서버는 데이터 저장 및 처리, 비즈니스 로직을 담당합니다.

2. **네트워크 통신**:
   클라이언트와 서버는 네트워크를 통해 서로 통신합니다. HTTP, HTTPS, WebSocket 등의 프로토콜을 사용하여 데이터를 주고받습니다.

3. **확장성**:
   서버는 여러 클라이언트를 동시에 처리할 수 있도록 설계되어 있어, 시스템의 확장성이 뛰어납니다. 필요에 따라 서버를 추가하여 부하를 분산할 수 있습니다.

4. **보안**:
   클라이언트-서버 구조에서는 보안 조치를 쉽게 적용할 수 있습니다. 예를 들어, 서버에서 인증 및 권한 부여를 처리할 수 있습니다.

5. **데이터 저장**:
   서버는 클라이언트의 데이터를 중앙에서 관리하여, 데이터 일관성과 무결성을 유지합니다.

## 세션, 쿠키, 캐시

1. **세션(Session)**

   - **정의**: 서버 측에서 사용자의 상태를 관리하기 위한 방법입니다. 사용자가 웹사이트에 접속하는 동안의 상태 정보를 저장합니다.

   - **저장 위치**: 서버에 저장되며, 사용자의 브라우저에는 세션 ID가 쿠키 형태로 저장됩니다.

   - **사용 목적**: 로그인 상태 유지, 장바구니 정보 저장 등, 세션은 일반적으로 사용자가 브라우저를 닫거나 세션 타임아웃이 발생하면 만료됩니다.

2. **쿠키(Cookie)**

   - **정의**: 클라이언트 측에서 사용자의 정보를 저장하는 작은 데이터 파일입니다.

   - **저장 위치**: 사용자의 브라우저에 저장됩니다.

   - **사용 목적**: 사용자 인증, 개인화된 설정, 방문 기록 등. 쿠키는 만료 기간을 설정할 수 있어 영구적으로 저장될 수 있습니다.

3. **캐시(Cache)**

   - **정의**: 자주 요청되는 데이터를 임시로 저장하여 다음 요청 시 빠르게 제공하는 메커니즘입니다.

   - **저장 위치**: 클라이언트(브라우저) 또는 서버에 저장될 수 있습니다.

   - **사용 목적**: 웹 페이지 로딩 속도 향상, 서버 부하 감소 등, 캐시는 만료 기간이나 정책에 따라 갱신됩니다.

## 웹 보안

웹 보안을 위한 대책은 여러 가지가 있으며, 주요 방법은 다음과 같습니다.

1. **HTTPS 사용**: 데이터 전송 시 SSL/TLS를 통해 암호화하여 보안을 강화합니다.

2. **인증 및 권한 부여**: 강력한 비밀번호 정책과 다단계 인증(MFA)을 통해 사용자 인증을 강화합니다.

3. **입력 검증**: 사용자 입력을 검증하여 SQL 인젝션, 크로스 사이트 스크립팅(XSS) 등의 공격을 방지합니다.

4. **정기적인 업데이트**: 소프트웨어와 라이브러리를 최신 상태로 유지하여 알려진 취약점을 차단합니다.

5. **백업 및 복구 계획**: 정기적인 데이터 백업과 복구 계획을 수립하여 데이터 손실에 대비합니다.

6. **방화벽 및 IDS/IPS**: 네트워크를 보호하기 위해 방화벽과 침입 탐지/방지 시스템을 설정합니다.

### MFA

**MFA(Multi-Factor Authentication)**

- **정의**: 사용자가 로그인할 때 두 개 이상의 인증 요소를 요구하는 방식입니다.

- **요소**: 일반적으로 세 가지 유형이 있습니다.

  1.  **지식 기반**: 사용자가 알고 있는 정보(비밀번호)

  2.  **소지 기반**: 사용자가 가지고 있는 물리적 장치(휴대폰의 인증 앱).

  3.  **고유 기반**: 사용자의 생체 정보(지문, 얼굴 인식).

- **목적**: 계정 탈취를 방지하고 보안을 강화합니다.

### IDS/IPS (Intrusion Detection System / Intrusion Prevention System)

1. **정의**:

   - **IDS**: 네트워크 또는 시스템에서 비정상적인 활동이나 침입 시도를 감지하는 시스템입니다.

   - **IPS**: IDS의 기능에 추가로, 감지된 공격을 차단하는 기능을 갖춘 시스템입니다.

2. **기능**:

   - **IDS**: 로그 모니터링, 알림 전송 등으로 공격을 경고합니다.

   - **IPS**: 실시간으로 공격을 차단하고, 네트워크 트래픽을 분석하여 위협을 방지합니다.

3. **목적** : 시스템 및 네트워크를 보호하고, 공격에 대한 실시간 대응을 제공합니다.

## 성능 최적화 방법

1. **코드 최적화**: 불필요한 코드 제거, 알고리즘 개선 및 효율적인 데이터 구조 사용.

2. **이미지 최적화**: 이미지 크기 축소 및 적절한 포맷을 사용하여 로딩 속도 개선.

3. **캐싱**: 정적 자원(HTML, CSS, JavaScript 등)을 캐시하여 반복 요청 시 속도 향상.

4. **비동기 로딩**: JavaScript와 CSS 파일을 비동기로 로드하여 페이지 렌더링 속도 개선

5. **CDN 사용**: 콘텐츠 전송 네트워크(CDN)를 통해 사용자에게 가까운 서버에서 콘텐츠 제공

6. **데이터베이스 최적화**: 쿼리 최적화, 인덱스 사용 및 데이터 정규화로 데이터베이스 성능 향상

7. **서버 성능 모니터링**: 서버 리소스를 모니터링하고, 필요에 따라 스케일 업 또는 스케일 아웃

### 정규화 (Normal Form)

정규화(Normalization)는 데이터베이스 설계에서 데이터의 중복을 줄이고 데이터 무결성을 높이기 위해 사용하는 과정입니다. 이는 데이터베이스의 구조를 체계적으로 구성하여 효율적인 데이터 관리를 가능하게 합니다.

1. **정규화의 목적**

   1. **중복 최소화**: 동일한 데이터가 여러 장소에 저장되지 않도록 하여 저장 공간을 절약하고 업데이트 시 오류를 방지합니다.

   2. **무결성 유지**: 데이터의 일관성과 정확성을 보장합니다. 즉, 하나의 데이터 변경이 모든 관련 데이터에 자동으로 반영되도록 합니다.

   3. **쿼리 효율성 향상**: 데이터 구조가 명확해지면 쿼리 성능이 향상될 수 있습니다.

2. **정규형 (Normal Form)**

   정규화는 여러 단계로 이루어지며, 각 단계는 정규형으로 구분됩니다. 주요 정규형은 다음과 같습니다:

   1. **제 1정규형 (N1F)**:

      - 모든 컬럼의 값이 원자적(atomic)이어야 합니다. 즉, 각 컬럼은 더 이상 나눌 수 없는 단일값을 가져야 합니다.

      - 중복된 행이 없어야 합니다.

   2. **제2 정규형 (2NF)**:

      - 제1 정규형을 만족하고, 기본 키에 대해 완전 함수 종속이 있어야 합니다. 즉, 기본 키의 일부에만 의존하는 속성이 없어야 합니다.

   3. **제3 정규형 (3NF)**:

      - 제2 정규형을 만족하고, 기본 키에 대해 이행적 함수 종속이 없어야 합니다. 즉, A -> B이고 B -> C일 때, A -> C가 성립하지 않아야 합니다.

   4. **BCNF (Boyce-Codd Normal Form)**:
      - 제3 정규형을 만족하며, 모든 결정자가 후보 키여야 합니다. 즉, 비주요 속성이 다른 비주요 속성에 의존하지 않아야 합니다.

3. **정규화의 장점과 단점**

   - **장점**:

     - 데이터 중복 감소

     - 데이터 무결성 증가

     - 데이터 업데이트 및 관리의 용이성

   - **단점**:

     - 과도한 정규화는 쿼리 성능을 저하시킬 수 있음

     - 복잡한 조인이 필요할 수 있어 성능 저하 가능성

     - 설계와 유지 관리의 복잡성 증가

정규화는 데이터베이스 설계의 중요한 과정이지만, 항상 정규화가 정답은 아닙니다. 때로는 성능을 위해 의도적으로 비정규화하는 경우도 있습니다.

### CDN(Content Delivery Network)

- **정의**: 전 세계에 분산된 서버 네트워크로, 사용자에게 콘텐츠를 더 빠르고 효율적으로 제공하는 시스템입니다.

- **작동 원리**: 사용자의 지리적 위치에 가장 가까운 서버에서 웹 페이지, 이미지, 비디오 등의 정적 콘텐츠를 제공하여 로딩 시간을 단축합니다.

- **장점**:

  - **속도 향상**: 데이터 전송 거리가 줄어들어 빠른 로딩 속도 제공

  - **트래픽 분산**: 서버에 가해지는 부하를 줄여 안전성 증가

  - **보안**: DDoS 공격 방어 및 SSL 지원 기능 제공

### 스케일 업(Scale Up)

- **정의**: 기존 서버의 성능을 높이는 방식으로, 더 강력한 하드웨어(CPU, 메모리 등)로 업그레이드 하는 것을 의미합니다.

- **장점**:

  - **간단한 관리**: 단일 서버에서 모든 작업을 처리하므로 관리가 용이합니다.

  - **즉각적인 성능 향상**: 하드웨어 업그레이드로 성능이 즉시 개선됩니다.

- **단점**:

  - **비용 문제**: 고성능 하드웨어는 비쌀 수 있습니다.

  - **한계**: 특정 한계에 도달하면 더 이상 확장이 불가능합니다.

### 스케일 아웃(Scale Out)

- **정의**: 여러 대의 서버를 추가하여 시스템을 확장하는 방식입니다.

- **장점**:

  - **유연성**: 필요에 따라 서버를 추가하여 용량을 쉽게 확장할 수 있습니다.

  - **비용 효율성**: 일반적으로 저렴한 하드웨어를 사용하여 확장이 가능합니다.

- **단점**:

  - **복잡성**: 여러 서버를 관리해야 하므로 시스템 관리가 복잡해질 수 있습니다.

  - **데이터 일관성**: 데이터 분산으로 인해 일관성을 유지하기 어려울 수 있습니다.

## db의 종류

1. **관계형 데이터베이스 (RDBMS)**:

   - **정의**: 데이터가 테이블 형식으로 저장되고, 테이블 간의 관계를 통해 데이터를 관리합니다.

   - **예시**: MySQL, PostgreSQL, Oracle, Microsoft SQL Server

   - **특징**: SQL(Structured Query Language)을 사용하여 데이터 쿼리 및 조작을 수행합니다. 데이터 무결성과 트랙잭션 처리를 지원합니다.

2. **비관계형 데이터베이스(NoSQL)**:

   - **정의**: 관계형 모델이 아닌 방식으로 데이터를 저장하는 데이터베이스입니다. 다양한 데이터 모델을 지원합니다.

   - **예시**: MongoDB, Cassandra, Redis, Couchbase

   - **특징**: 스키마가 없거나 유연하고 데이터 구조가 다양합니다. 대규모 데이터와 높은 성능을 처리하는 데 유리합니다.

3. **객체지향 데이터베이스 (OODBMS)**

   - **정의**: 객체 지향 프로그래밍 언어와 통합하여 데이터를 객체로 저장하는 데이터베이스입니다.

   - **예시**: db4o, ObjectDB

   - **특징**: 객체와 클래스 개념을 사용하여 복잡한 데이터 모델을 표현할 수 있습니다.

4. **그래프 데이터베이스**

   - **정의**: 노드, 엣지, 속성으로 구성된 그래프 구조로 데이터를 저장하는 데이터베이스입니다.

   - **예시**: Neo4j, Amazon Neptune

   - **특징**: 복잡한 관계 데이터를 효과적으로 관리하며, 소셜 네트워크, 추천 시스템 등에 적합합니다.

5. **문서 지향 데이터베이스**

   - **정의**: JSON, XML 등의 문서 형식으로 데이터를 저장하는 데이터베이스입니다.

   - **예시**: MongoDB, CouchDB

   - **특징**: 유연한 데이터 구조를 제공하며, 복잡한 쿼리를 지원합니다.

## 백엔드 프레임워크의 종류

백엔드 프레임워크는 서버 측 애플리케이션을 개발하는 데 도움을 주는 소프트웨어 프레임워크입니다. 여러 종류가 있으며, 주요 백엔드 프레임워크는 다음과 같습니다.

1. **Node.js (Express)**

   - **정의**: JavaScript 런타임 환경인 Node.js 위에 구축된 웹 애플리케이션 프레임워크입니다.

   - **특징**: 비동기 이벤트 기반 아키텍처를 사용하여 높은 성능을 제공합니다. RESTful API 개발에 적합하며, 미들웨어를 통해 요청과 응답을 처리합니다.

2. **Django**

   - **정의**: Python으로 작성된 고급 웹 프레임워크입니다.

   - **특징**: 강력한 ORM(Object-Relational Mapping), 보안 기능, 관리 패널과 같은 여러 내장 기능을 제공합니다. 빠른 개발과 유지보수를 지원합니다.

3. **Ruby on Rails**

   - **정의**: Ruby 프로그래밍 언어로 작성된 프레임워크입니다.

   - **특징**: "Convention over Configuration" 및 "Don't Repaeat Yourself" 원칙을 따르며, 생산성을 높이는 다양한 도구와 라이브러리를 제공합니다.

4. **ASP.NET**

   - **정의**: Microsoft에서 개발한 웹 프레임워크로 .NET 플랫폼을 기반으로 합니다.

   - **특징**: C#을 사용하여 웹 애플리케이션을 개발할 수 있으며, 강력한 보안 기능과 성능을 제공합니다. MVC(Model-View-Controller) 아키텍처를 지원합니다.

5. **Spring**

   - **정의**: Java 기반의 애플리케이션 프레임워크로, 특히 엔터프라이즈급 애플리케이션 개발에 적합합니다.

   - **특징**: 의존성 주입, AOP(Aspect-Oriented Programming) 등 다양한 기능을 제공하며, RESTful API 및 마이크로서비스 아키텍처에 널리 사용됩니다.

6. **Flask**

   - **정의**: Python으로 작성된 경량 웹 프레임워크입니다.

   - **특징**: 간단하고 유연한 구조로, 필요한 기능만 추가하여 사용할 수 있습니다. RESTful API 및 소규모 애플리케이션에 적합합니다.

7. **AOP의 주요 개념**

   1. **Aspect(관점)**: 공통적인 기능(예: 로깅, 보안, 트랜잭션 관리 등)을 캡슐화한 모듈입니다. 이 기능은 여러 곳에서 재사용될 수 있습니다.

   2. **Join Point (조인 포인트)**: 프로그램 실행 중에 Aspect가 적용될 수 있는 지점입니다. 예를 들어, 메서드 호출, 객체 생성 등이 조인 포인트가 될 수 있습니다.

   3. **Advice (어드바이스)**: Aspect가 특정 조인 포인트에서 실행하는 코드입니다. 주로 Before, After, Around 어드바이스로 나뉩니다.

      - **Before**: 조인 포인트 이전에 실행됩니다.

      - **After**: 조인 포인트 이후에 실행됩니다.

      - **Around**: 조인 포인트를 감싸며, 조인 포인트를 실행하기 전후에 실행됩니다.

   4. **Pointcut (포인트 컷)**: 어떤 조인 포인트에서 어떤 어드바이스를 적용할지 정의하는 표현식입니다. 즉, 어떤 Aspect가 어디에서 실행될지를 결정합니다.

8. **AOP의 장점**

   - **코드의 모듈화**: 공통 기능을 별도의 Aspect로 분리하여, 코드의 가독성을 높이고 유지 관리가 용이합니다.

   - **재사용성**: 공통적인 기능을 여러 모듈에서 사용할 수 있어, 중복 코드를 줄일 수 있습니다.

   - **유연성**: 특정 기능을 쉽게 추가하거나 변경할 수 있습니다.

9. **AOP의 사용 예**

   AOP는 주로 로깅, 보안, 트랜잭션 처리 등과 같은 공통 기능을 관리하기 위해 사용됩니다. 예를 들어, Spring Framework에서 AOP를 활용하여 서비스 메서드에 로깅 기능을 추가할 수 있습니다.

10. **결론**

    AOP는 소프트웨어 개발에서 공통적인 관심사를 분리하여 코드의 품질을 높이고, 유지보수를 쉽게하는 데 유용한 기법입니다.
