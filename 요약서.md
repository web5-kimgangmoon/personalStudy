# 목차

- **웹**

  - **웹 기초**

    1.  **문서객체모델**
    2.  **JSON**
    3.  **세션, 쿠키, 캐시**
    4.  **CORS(Cross-Origin Resource Sharing)**
    5.  **적응형과 반응형의 차이**
    6.  **SSR, CSR**
    7.  **SEO**
    8.  **SERP**
    9.  **크롤링(Crawling)**
    10. **인덱싱 (Indexing)**
    11. **DNS(domain name system)**
    12. **오버페칭 (Over-fetching)**
    13. **언더페칭 (Under-fetching)**
    14. **DTO(개인질문)**
    15. **직렬화, 역직렬화(개인질문)**

  - **웹 프로토콜 및 응용**

    1. **웹 프로토콜**
    2. **프로토콜(웹 X)(개인질문)**
    3. **RESTful API**
    4. **OSI 7계층**
    5. **TCP/IP 4계층 및 5계층 모델**
    6. **TCP, UDP**
    7. **HTTP들의 버전**
    8. **SSL/TLS**
    9. **웹 보안**
    10. **MFA**
    11. **IDP/IPS (Intrusion Detection System / Intrusion Prevention System)**
    12. **HTTP와 HTTPS의 차이**
    13. **HTTP 상태 코드**
    14. **3 Way-HandShake 및 4 Way-HandShake**
    15. **세션 기반 인증과 토큰 기반 인증**
    16. **google.com을 입력했을 때**
    17. **크로스 브라우징**
    18. **웹 접근성**
    19. **JWT**
    20. **대칭 비밀 키 암호화와 비대칭 키 암호화 방식**
    21. **퍼블릭 IP와 프라이빗 IP**
    22. **ISP(Internet Service Provider)**
    23. **IPv4, IPv6의 차이**
    24. **IPSec**
    25. **OAuth(번외)**
    26. **서드파티**
    27. **WAS**
    28. **WS**

- **코딩**

  - **콜백함수**

    1. **AJAX**
    2. **동기와 비동기**
    3. **async/await 외의 비동기 처리 방법**
    4. **RxJS**
    5. **데이터의 스트림 형태**
    6. **Promise**
    7. **메서드 체이닝이란? 장단점은?**
    8. **콜백 함수**
    9. **프라미스와 콜백함수의 차이점과 각각의 장단점은?**
    10. **콜백 지옥**

  - **코딩이론**

    1.  **추상화**
    2.  **원시 타입과 참조타입에 대해서**
    3.  **가비지 컬렉터(Garbage Collector, GC)**
    4.  **순환참조**
    5.  **리팩토링**
    6.  **클린 코드와 리팩토링 차이**
    7.  **Call By Value와 Call By Reference**
    8.  **TDD**
    9.  **CICD**
    10. **트러블 슈팅 경험**

  - **프론트엔드**

    1.  **CSS 적용 순서**
    2.  **모달과 팝업의 차이**
    3.  **inline과 inline block의 차이**
    4.  **이벤트 위임**
    5.  **GraphQL**
    6.  **템플릿 엔진**
    7.  **디자이너가 psd 파일 또는 jpg 파일만 주었을 때 구현 가능?(해당 이미지를 청사진으로서 활용하는 경우의 고려사항)**

  - **백엔드**

    1. **백엔드 프레임워크의 종류**
    2. **프레임워크(JS 기반)**
    3. **Waterline**
    4. **런타임**
    5. **프레임워크와 라이브러리 모듈**
    6. **Express**

  - **아키텍처 및 프로그래밍 패러다임**

    1. **IoC(Inversion of Control)(제어의 역전)**
    2. **프로토타입**
    3. **아키텍처**
    4. **AOP (Aspect-Oriented Programming)**
    5. **데코레이터 패턴이란**
    6. **의존성 주입 (Dependency Injecction)**
    7. **의존성 주입과 데코레이터 패턴(자필)**
    8. **싱글톤 패턴**
    9. **MVC 패턴**
    10. **클라이언트 서버 구조**
    11. **클라이언트 서버 모델의 특징**
    12. **플러그인 기반 아키텍처**
    13. **마이크로 서비스 아키텍처(MSA)**
    14. **마이크로 서비스와 모놀리틱 서비스**
    15. **이벤트 기반 아키텍처**
    16. **병렬 프로그래밍**
    17. **세마포어와 뮤텍스, 조건 변수**
    18. **데이터 경쟁(Data Race)**
    19. **Hydration(번외)**
    20. **동시성 모델**
    21. **함수형 프로그래밍**
    22. **순수 함수**
    23. **OOP 특징과 원칙**
    24. **OOP와 함수형 프로그래밍의 차이점**

  - **db**

    1. **db의 종류**
    2. **db 관계형 비관계형 차이**
    3. **ORM(Object-Relational Mapping)**
    4. **인덱스**
    5. **트랜잭션**

- **js**

  - **nodeJs**

    1. **Node.js**
    2. **Node.js는 단일 스레드?(개인적 해석, 인터넷 서치)**
    3. **스레드풀**
    4. **CPU 집약적인 작업**
    5. **Node.js 이벤트 큐 동작 원리**
    6. **이벤트 루프**
    7. **Node.js의 모듈 종류는?**
    8. **Node.js가 BackEnd에서 선호되는 이유**
    9. **Node.js의 장단점**
    10. **npm**
    11. **SemVer**
    12. **npm install**
    13. **dependence와 devDependence 차이**
    14. **Node.js가 싱글 스레드지만 병렬작업이 가능한 이유**
    15. **클러스터링**

  - **ES6의 추가요소들 및 문제해결 방안**

    1. **var, let, const**
    2. **일시적 사각지대(Temporal Dead Zone, TDZ)**
    3. **let과 const(자필 및 chatGPT)**
    4. **스코프**
    5. **변수의 생성과정**
    6. **라이프 타임**
    7. **모든 브라우저에서 ES6 스펙에 대한 지원이 완벽하지 않으며, 해결 방안은?**
    8. **Babel**
    9. **Webpack**

  - **react**

    1.  **React**
    2.  **상태관리**
    3.  **React의 동작원리**
    4.  **컴포넌트**
    5.  **클래스 컴포넌트와 함수형 컴포넌트의 차이는?**
    6.  **훅**
    7.  **라이프사이클의 메서드 종류는?**
    8.  **Angular, Vue.js, React.js의 차이는?**
    9.  **Angular의 디자인 원칙**
    10. **Virtual dom**

  - **바닐라 js**

    1. **Typescript 쓰는 이유**
    2. **ECMA**
       1. **하위 호환성**
    3. **null과 undefined의 차이**
    4. **클로저(Closure)**
    5. **실행 컨텍스트(Excution Context)**
    6. **브라우저 엔진은?**
    7. **JIT**
    8. **컴파일**
    9. **자바스크립트의 Number Type과 다른 언어의 차이는?**
    10. **배정도, 단정도의 뜻(개인질문)**
    11. **배열과 실제 자료구조 배열의 차이점은?**
    12. **Call, Apply, Bind**
    13. **this**
    14. **useStrict**
    15. **useStrict 모드에서의 this는?**

- **컴퓨터과학**

  - **컴퓨터과학 기초**

    1. **프로세스와 스레드 차이**
    2. **성능 최적화 방법**
       1. **정규화 (Normal Form)**
       2. **CDN(Content Delivery Network)**
       3. **스케일 업(Scale Up)**
       4. **스케일 아웃(Scale Out)**
    3. **자료구조**
    4. **큐와 스택 차이**
    5. **BST**
       1. **자가 균형 이진 검색 트리**
    6. **시간 복잡도**
    7. **트랜잭션 데드락**
    8. **좀비프로세스**

  - **가상화**

    1. **Docker**
       1. **컨테이너**
       2. **컨테이너의 가상화**
    2. **Docker와 VM의 차이는?**

  - **버전관리**

    1. **버전 관리 시스템**
    2. **git이란?**
    3. **GitHub**
    4. **Jenkins**

## _웹_

## 웹 기초

### 문서객체모델

문서 객체 모델(DOM)은 HTML 및 XML 문서의 구조화된 표현을 제공하는 프로그래밍 인터페이스입니다. DOM은 문서의 모든 요소, 속성들을 객체로 표현합니다.

1. **_주요 개념_**

   1. **트리 구조**
   2. **노드 타입**
      1. Element Node(기본 태그, \<div> 등)
      2. Text Node
      3. Attribue Node
      4. Document Node
   3. **인터페이스**(언어에 독립적인 API 제공)

2. **_주요 기능_**

   1. **문서 탐색**(다른 노드나 관련 노드를 찾기 편하다)
   2. **내용 변경**(속성이나 텍스트)
   3. **노드 추가 및 삭제**
   4. **이벤트 처리**

3. **_결론_**

DOM은 웹 페이지를 동적으로 조작할 수 있게 해주는 인터페이스다.

### JSON

데이터 교환 형식이며, 텍스트 기반의 포맷이다.

1. **형식**(키-값 쌍의 형태로 구성된다.)
2. **가독성**
3. **언어 독립성**
4. **데이터 유형**(문자열, 숫자, 배열, 객체, 불리언, 널)
5. **사용 용도**(데이터 전송, 설정 파일, 데이터 저장 등)

### 세션, 쿠키, 캐시

1. **_세션(session)_**

   - **정의**: 사용자가 웹사이트에 접속하는 동안의 상태 정보

   - **저장 위치**: 서버에서 저장, 사용자 브라우저에선 세션 ID가 쿠키로 저장된다.

   - **사용 목적**: 로그인 상태 유지, 장바구니 정보 저장 등.

   - **특징**:세션은 일반적으로 사용자가 브라우저를 닫거나 세션 타임아웃이 발생하면 만료됩니다.

2. **_쿠키(Cookie)_**

   - **정의**: 사용자의 정보를 저장하는 작은 데이터 파일

   - **저장 위치**: 클라이언트의 브라우저

   - **사용 목적**: 사용자 인증, 개인화된 설정, 방문 기록 등.

   - **특징**: 쿠키는 만료 기간을 설정할 수 있어 영구적으로 저장될 수 있습니다.

3. **_캐시(Cache)_**

   - **정의**: 임시 저장된 자주 요청되는 데이터

   - **저장 위치**: 클라이언트(브라우저) 및 서버

   - **사용 목적**: 웹 페이지 로딩 속도 향상, 서버 부하 감소 등.

   - **특징**: 만료 기간이나 정책에 따라 갱신됩니다.

### CORS(Cross-Origin Resource Sharing)

웹 브라우저는 다른 출처의 리소스에 대한 요청을 제한하여 보안을 강화합니다.

CORS은 웹 애플리케이션에서 리소스가 다른 출처(origin)에서 요청될 때 보안을 관리하는 메커니즘입니다.

1. **_출처(origin)_**

   - **구성**: 프로토콜, 도메인, 포트번호

2. **_CORS 정책_**

   - **기능**: 서버는 응답 헤더에 특정 CORS 헤더를 포함하여 요청이 허용되는 출처를 명시합니다.

   - **주요 헤더**: Access-Control-Alllow-Origin

3. **_요청 유형_**

   - **단순 요청(Simple Request)**: GET, POST, (특정 조건 하에) 요청 등.

   - **사전 요청(Preflight Request)**: 브라우저가 실제 요청 전에 OPTIONS 메서드를 사용해 서버에 권한을 확인합니다.

4. **_보안_**

   - **보안**: CORS는 출처를 명시적으로 관리합니다.

### 적응형과 반응형의 차이

적응형(adaptive)
반응형(Responsive)

1. **_정의_**

   - **적응형**: 특정 화면 크기나 해상도에 맞춰 미리 여러 레이아웃을 제공하는 방식입니다.

   - **반응형**: 하나의 레이아웃을 사용하며, 화면 크기에 따라 요소의 크기와 위치가 동적으로 조정됩니다.

2. **_작동 방식_**

   - **적응형**: 특정 브레이크포인트(예: 480px 등)에서 서로 다른 레이아웃을 로드합니다.

   - **반응형**: 화면 크기에 맞춰 하나의 레이아웃이 유동적으로 변화합니다.

3. **_장단점_**

   - **적응형**:

     1. **_장점_**: 특정 화면에 맞춘 레이아웃 제공으로, 사용자 경험이 향상될 수 있습니다.

     2. **_단점_**

        1. 개발 및 유지보수가 복잡해집니다.

        2. 시간과 비용이 더 소요될 수 있습니다.

   - **반응형**:

     1. **_장점_**

        1. 유지보수가 용이합니다.

        2. 수정이 쉽다.

     2. **_단점_**

        1. 사용자 경험이 적응형에 비해 뒤떨어질 수 있다.

        2. 유동적인 레이아웃의 구현을 위해 CSS가 도리어 복잡해질 수 있다.

### SSR, CSR

- **_SSR_**

  1. **_정의_**

     - 서버에서 HTML을 생성하여 클라이언트에 전달하는 방식입니다.

  2. **_특징_**

     - **초기 로딩 속도 빠름**

     - **SEO 최적화**

     - **javaScript가 비활성되어도 정상적인 페이지 표시**

  3. **_단점_**

     - **서버 부하**

     - **상호작용 성능 느림**

- **_CSR_**

  1.  **_정의_**

      - 클라이언트(브라우저)에서 JavaScript로 데이터를 가져오고, DOM을 조작하여 HTML을 생성하는 방식입니다.

  2.  **_특징_**

      - **빠른 사용자 경험**

      - **서버 부하 감소**

  3.  **_단점_**

      - **초기 로딩 속도 느림**

      - **SEO 문제**

      - **JavaScript 비활성시 비정상적인 페이지 표시**

### SEO

SEO는 웹사이트나 웹페이지를 검색 엔진 결과 페이지에서 높은 순위에 노출시키기 위한 전략과 기법을 의미합니다.

1. **_주요 요소_**

   - **온페이지 SEO (On-page SEO)**

     - **키워드 최적화**(사용자들이 자주 검색하는 키워드)

     - **메타 태그**

     - **콘텐츠 품질**

     - **간결한 URL 구조**

     - **내부 링크**(해당 웹사이트가 가진 다른 페이지와 링크)

   - **오프페이지 SEO(Off-page SEO)**

     - **백링크**(다른 웹사이트에서 자신의 웹사이트로 연결되는 링크)

     - **소셜 미디어**

   - **기술적 SEO (Technical SEO)**

     - **사이트 속도**

     - **모바일 최적화**

     - **사이트 구조**(크롤링과 인덱스가 쉬운 구조)

     - **사용자 경험**

2. **_SEO의 중요성_**

   - **트래픽 증가**

   - **브랜드 신뢰성**

   - **비용 효율성**

### SERP

SERP는 검색 엔진에서 사용자가 검색한 키워드에 대한 결과 페이지를 의미합니다.

1. **_SERP의 주요 구성 요소_**

   1. **유기적 검색 결과(Organic Results)**(유동적인 검색결과)

   2. **광고**(광고비가 지불된 유료 광고)

   3. **스니펫(Feature Snippets)**(질문에 대한 직접적인 답변이나 요약, 상단에 강조 표시)

   4. **지역 정보(Local Results)**(특정 지역에 대한 검색일 경우, 지역 정보와 지도와 주소가 표시)

   5. **관련 질문(People Also Ads)**

   6. **이미지/비디오 결과**

2. **SERP의 중요성**

   1. **가시성**

   2. **사용자 경험**

   3. **비즈니스 기회**

### 크롤링 (Crawling)

1.  **_정의_**

    - 크롤링은 검색 엔진 봇(크롤러 또는 스파이더)이 웹 페이지를 탐색하여 새로운 콘텐츠를 발견하고, 기존의 페이지를 업데이트하는 과정입니다. 크롤러는 링크를 따라 이동합니다.

2.  **_과정_**

    1.  **시작점**(초기 URL 목록을 기반으로 시작)

    2.  **페이지 수집**(지정된 URL에 접속, 페이지의 콘텐츠를 가져온다)

    3.  **링크 추적**(페이지 내의 링크를 분석, 새로운 URL을 큐에 추가하고 지속적으로 크롤링 진행)

    4.  **재방문**(정기적인 지속적 업데이트)

3.  **_중요성_**

    - **신규 콘텐츠 발견**

    - **업데이트 유지**

### 인덱싱 (Indexing)

1.  **_정의_**

    - 인덱싱은 크롤링을 통해 수집된 웹 페이지의 콘텐츠를 분석하고, 이를 검색 엔진의 데이터베이스에 저장하고 정리하는 과정이다.

2.  **_과정_**

    1. **데이터 분석**(텍스트, 메타 태그, 이미지 등을 분석하고 중요한 정보 추출)

    2. **구조화**(키워드와 관련된 구조로 정리하여 인덱스 생성)

    3. **저장**(db에 저장)

3.  **중요성**

    1. **검색 효율성**(db의 인덱스)

    2. **정확한 검색 결과**

### DNS(domain name system)

인터넷에서 도메인 이름을 IP 주소로 변환하는 시스템입니다.

1. **_주요 기능_**

   1. **도메인 이름 해석**(이름을 IP로 변환)

   2. **주소 캐싱**(자주 요청되는 이름과 IP 주소 쌍을 캐싱)

   3. **부하 분산**(여러 IP 주소를 도메인 이름에 매핑)

2. **_DNS의 구조_**

   1. **DNS 리졸버**(도메인 이름을 IP 주소로 변환하는 역할)

   2. **루트 DNS 서버**(최상위 DNS 서버, 특정 도메인의 네임 서버에 대한 정보 제공)

   3. **TLD(최상위 도메인)(Top-Level-Domain) 서버**(특정 도메인(.com, .org 등)에 대한 정보 저장)

   4. **권한 있는 네임 서버**(특정 도메인에 대한 IP 주소와 관련된 정보를 저장)

### 오버페칭 (Over-fetching)

클라이언트가 실제로 필요로 하는 것보다 더 많은 데이터를 요청하는 상황.

### 언더페칭 (Under-fetching)

클라이언트가 필요한 데이터를 요청할 때, 부족한 데이터가 반환되는 상황.

### DTO(개인질문)

Data Transfer Object의 약자 데이터 전송 객체를 의미합니다.

1. **_주요 특징_**

   1. **단순화된 구조**(데이터만 담는 용도, 필드와 접근자(getter, setter) 구성)

   2. **데이터 전송**(클라이언트와 서버 또는 서비스 간에 데이터 전송시 사용)

   3. **캡슐화**

   4. **성능 최적화**(필요한 데이터만 전송가능)

2. **_DTO의 예시_**

   ```js
   class UserDTO {
     constructor(id, name, email) {
       this.id = id;
       this.name = name;
       this.email = email;
     }
   }

   // 사용 예
   function getUser(userId) {
     // 데이터베이스에서 사용자 정보를 가져온다고 가정
     const userFromDb = {
       id: userId,
       name: "John Doe",
       email: "john@example.com",
       password: "secret", // 비밀번호는 필요없으므로 제외
     };

     const userDTO = new UserDTO(
       userFromDb.id,
       userFromDb.name,
       userFromDb.email
     );
     return userDTO;
   }

   // 클라이언트에서 사용자 정보 요청

   const user = getUser(1);
   console.log(ser); // {id:1, name: "John Doe", email: "Johen@example.com"}
   ```

3. **_DTO의 장점_**

   1. **유지보수 용이성**(구조가 명확해짐)

   2. **안정성**(필요없는 데이터 제외)

   3. **확장성**(구조가 일관됨으로 쉽게 확장)

   4. **데이터 직렬화**(쉽게 직렬화, 역직렬화)

4. **_DTO의 단점_**

   1. **추가적인 코드**

   2. **성능 이슈**(대량의 데이터 전송 시 DTO 객체 생성이 영향을 줄 수 있음)

### 직렬화, 역직렬화(개인질문)

직렬화(Serialization), 역직렬화(Deserialization)은 데이터 구조나 객체 상태를 전송이나 저장할 수 있는 형식으로 변환하는 과정.

1. **_직렬화(Serialization)_**

   - **정의**: 객체나 데이터 구조를 연속적인 바이트 스트림으로 변환.

   - **사용 목적**: 데이터 전송, 파일에 저장 또는 db에 저장, 세션 상태 저장

   - **예시(js)**

   ```js
   const user = {
     name: "John Doe",
     age: 30,
     email: "john@example.com",
   };

   // 직렬화
   const serializationUser = JSON.stringify(user);
   console.log(serialization);
   ```

2. **_역직렬화(Deserialization)_**

   - **정의**: 직렬화된 데이터(일반적으로 문자열 형식)로부터 원래의 객체나 데이터 구조를 복원하는 과정.

   - **사용 목적**: 수신 데이터 객체 변환, 파일 읽기 및 객체 복원, API 응답

   - **예시 (JavaSript)**

   ```js
   // JSON 문자열
   const serializedUser =
     '{"name":"John Doe", "age":30, "email":"john@example.com"}';

   // 역직렬화
   const user = JSON.parse(serializedUser);
   console.log(user); // {name: "John Doe", age:30, email: "john@example.com"}
   ```

3. **_직렬화와 역직렬화의 장단점_**

   1. **장점**

      - **데이터 전송 용이성**

      - **저장 공간 효율성**

      - **상태 저장**(쉽게 저장 및 복원 가능)

   2. **단점**

      - **성능 저하**(전환 과정 필요, 대량의 데이터 처리시 성능 저하 발생가능)

      - **데이터 손실 가능성**(객체의 메서드나 원시 타입 이외의 데이터 손실)

      3. **버전 호환성**(자동으로 관리가 안됨)

4. **_사용 사례_**

   1. **API 통신**

   2. **데이터베이스 저장**

   3. **세션 관리**

5. **_요약_**

   - **직렬화**: 객체나 데이터 구조를 연속적인 바이트 스트림 또는 문자열 형식으로 변환하는 과정.

   - **역직렬화**: 직렬화된 데이터를 원래의 객체나 데이터 구조로 복원하는 과정.

## 웹 프로토콜 및 응용

### 웹 프로토콜

웹에서 클라이언트와 서버 간의 통신을 정의하는 규칙과 규약의 집합입니다.

1. **주요 웹 프로토콜**

   1. **HTTP (Hypertext Transfer Protocol)**

      가장 널리 사용되는 웹 프로토콜, 요청-응답 모델.

   2. **HTTPS (Hypertext Transfer Protocol Secure)**

      HTTP의 보안 버전, SSL/TLS 프로토콜 사용.

   3. **FTP (File Transfer Protocol)**

      클라이언트와 서버 간의 파일 전송 및 관리를 지원, 사용자 인증(로그인) 기능을 제공한다.

   4. **SFTP (SSH File Transfer Protocl)**

      SSL(Secure Shell) 프로토콜을 사용하여 안전한 파일 전송을 지원합니다.

   5. **IMAP (Internet Message Access Protocol)**

      이메일 클라이언트가 서버에 저장된 이메일에 접근하고 관리할 수 있도록 하는 프로토콜이다. 메일이 남기에 여러 디바이스에서 확인 가능.

   6. **POP3(Post Office Protocol version 3)**

      이메일 클라이언트가 서버에서 이메일을 다운로드하여 로컬로 저장하는 프로토콜입니다. 이메일 다운 후 서버에서 삭제된다.

2. **웹 프로토콜의 중요성**

   - **상호운용성**(다양한 클라이언트와 통신 가능)

   - **보안**

   - **성능**

### 프로토콜(웹 X)(개인 질문)

컴퓨터 네트워크에서 데이터 통신을 위해 정해진 규칙이나 규약의 집합을 의미.

1. **_주요 역할_**

   1. **데이터 형식 정의**(데이터 구조와 형식을 정의)

   2. **전송 규칙**(전송 방법과 순서 규정. 요청과 응답의 순서, 데이터 전송, 속도, 패킷 크기 등을 명시)

   3. **에러 처리**(데이터 전송 중 오류가 발생했을 때의 처리방법 정의.)

   4. **연결 관리**(통신을 시작하고 종료하는 방법, 연결을 유지하는 방법 규정)

2. **_프로토콜의 종류_**

   1. **애플리케이션 계층 프로토콜**(사용자와 직접 상호작용하는 프로토콜, HTTP(웹), SMTP(이메일), FTP(파일 전송))

   2. **전송 계층 프로토콜**(데이터 전송 신뢰성 보장, 데이터 패킷 순서 관리, TCP(Transmission Control Protocol)와 UDP(User Datagram Protocol)가 있습니다)

   3. **인터넷 계층 프로토콜**(데이터를 목적지까지 전송하는 데 필요한 주소 지정 및 라우팅 기능 제공 프로토콜(IP))

   4. **네트워크 인터페이스 계층 프로토콜**(물리적 네트워크에서 데이터의 전송을 관리하는 프로토콜, Ethernet, Wi-Fi 등이 있습니다.)

### RESTful API

Restful API는 Representational State Transfer(REST) 원칙을 따르는 웹 서비스 인터페이스입니다.(클라이언트-서버 아키텍처)

1. **자원(Resource)**

   URI(하나의 리소스를 가리키는 문자열)를 사용하여 자원을 식별합니다.

2. **HTTP 메서드**

   1. **GET**(조회)

   2. **POST**(생성)

   3. **PUT**(전체 갱신)

   4. **PATCH**(부분 갱신)

   5. **DELETE**(삭제)

3. **상태 비저장성(Stateless)**

   REST API의 각 요청은 독립적이며, 서버는 클라이언트의 상태를 저장하지 않습니다.

4. **표현(Representation)**

   자원은 다양한 형식(예: JSON, XML)으로 표현될 수 있습니다.

5. **캐싱(Caching)**

   응답 캐시

6. **계층화(Layered System)**

   여러 계층으로 구성될 수 있으며, 클라이언트는 중간 서버의 존재를 알지 못합니다.

### OSI 7계층

OSI 7계층(Open Systems Interconnection model)은 네트워크 통신을 표준화하기 위해 제안된 개념적 모델입니다.

1. **물리 계층 (Physical Layer)**

   - **역할**: 전기적, 기계적, 절차적 특성을 정의하여 실제 데이터를 전송하는 계층입니다.

   - **예시**: 케이블, 리피터, 허브, 전기 신호 등

2. **데이터 링크 계층(Data Link Layer)**

   - **역할**: 물리적 네트워크에서 데이터의 오류 감지 및 수정, 그리고 MAC 주소를 사용한 노드 간의 데이터 전송을 담당합니다.

   - **예시**: 이더넷, Wi-Fi, PPP(점대점 프로토콜)

3. **네트워크 계층 (Network Layer)**

   - **역할**: 데이터 패킷의 경로 설정 및 전달을 담당하며, 논리적 주소(예: IP 주소)를 사용하여 네트워크 간 통신을 가능하게 합니다.

   - **예시**: IP(인터넷 프로토콜), ICMP(인터넷 제어 메시지 프로토콜)

4. **전송 계층 (Transport Layer)**

   - **역할**: 종단 간 (end-to-end) 통신을 관리하며, 데이터의 전송 오류를 감지하고 복구합니다. 흐름 제어 및 세분화된 데이터 전송도 지원합니다.

   - **예시**: API(응용 프로그램 프로그래밍 인터페이스), 소켓

5. **세션 계층 (Session Layer)**

   - **역할**: 통신 세션을 관리하고, 세션의 생성, 유지 및 종료를 담당합니다. 데이터 교환의 동기화도 지원합니다.

   - **예시**: API(응용 프로그램 프로그래밍 인터페이스), 소켓

6. **표현 계층 (Presentation Layer)**

   - **역할**: 데이터의 형식과 표현을 변환하여 서로 다른 시스템 간의 데이터 호환성을 보장합니다. 데이터 압축 및 암호화도 이 계층에서 수행됩니다.

   - **예시**: JPE6, GIF, ASCII

7. **응용 계층 (Application Layer)**

   - **역할**: 최종 사용자가 직접 사용하는 응용프로그램과 네트워크 간의 인터페이스를 제공합니다. 사용자와 네트워크의 상호작용을 처리합니다.

   - **예시**: HTTP, FTP, SMTP, DNS

### TCP/IP 4계층 및 5계층 모델

TCP/IP 모델은 인터넷과 같은 네트워크에서 데이터 통신을 위한 프로토콜을 정의하는 구조.

- **TCP/IP 4계층 모델**

  1.  **네트워크 인터페이스 계층(Network Interface Layer)**

      - **역할**: 물리적 네트워크에서 데이터 전송을 담당하며, 하드웨어와 관련된 데이터 링크 및 물리적 전송을 포함합니다.

      - **예시**: Ethernet, Wi-Fi, ARP(Address Resolution Protocol)

  2.  **인터넷 계층 (Internet Layer)**

      - **역할**: 데이터 패킷의 주소 지정 및 라우팅을 담당합니다.

      - **예시**: IP (Internet Protocol),
        ICMP (Internet Control Message Protocol)

  3.  **전송 계층 (Transport Layer)**

      - **역할**: 종단 간 데이터 전송을 관리하며, 신뢰성, 흐름 제어 및 오류 검출을 제공합니다.

      - **예시**: TCP (Transmission Control Protocol), UDP (User Datagram Protocol)

  4.  **응용 계층 (Application Layer)**

      - **역할**: 최종 사용자와의 상호작용을 처리하며, 애플리케이션 프로토콜을 포함합니다.

      - **예시**: HTTP, FTP, SMTP, DNS

  - **TCP/IP 5계층 모델**

    1. **물리 계층(Physical Layer)**

       - **역할**: 전기적 신호, 케이블 및 하드웨어와 관련된 요소를 다룹니다.

    2. **데이터 링크 계층(Data Link Layer)**

       - **역할**: 물리적 네트워크의 데이터 전송 및 오류 감지를 담당합니다.

    3. **인터넷 계층 (Internet Layer)**

       - **역할**: 데이터 패킷의 주소 지정 및 라우팅을 담당합니다.

    4. **전송 계층 (Transport Layer)**

       - **역할**: 종단 간 데이터 전송을 관리하며, 신뢰성, 흐름 제어 및 오류 검출을 제공합니다.

    5. **응용 계층 (Application Layer)**

       - **역할**: 최종 사용자와의 상호작용을 처리하며, 애플리케이션 프로토콜을 포함합니다.

### TCP, UDP

1. **TCP (Transmission Control Protocol)**

   1. **연결 지향**(데이터 전송 전에 연결 설정)

   2. **신뢰성**(데이터 손실 확인)

   3. **순서 보장**

   4. **흐름 제어**

   5. **사용 예**(웹 페이지 로딩, 파일 전송, 이메일 등)

2. **UDP (User Datagram Protocol)**

   1. **비연결 지향**

   2. **신뢰성 없음**

   3. **순서 보장 없음**

   4. **흐름 제어 없음**

   5. **사용 예**(실시간 게임, 비디오 스트리밍, 음성 통화(VoIP) 등)

3. **요약**

   - **TCP**: 신뢰성과 순서 보장이 필요한 데이터 전송에 적합합니다.

   - **UDP**: 빠른 전송 속도가 필요한 경우에 적합합니다.

### HTTP들의 버전

1. **_HTTP/1.1_**

   - **_출시 연도_**: 1999년

   - **_주요 특징_**:

     1. **지속적 연결**(여러 요청과 응답을 하나의 TCP 연결에서 처리 가능)

     2. **요청/응답 다양한 헤더**

     3. **Chunked 전송 인코딩**(데이터를 여러 조각(chunk)로 나누어 전송 가능)

     4. **HTTP 캐시**(미리 받아온 데이터 저장 가능)

   - **_단점_**

     1. **헤드 오버로드**(매 요청마다 TCP 연결 설정)

     2. **동시성**(여러 요청에 다수의 TCP 연결 생성 필요)

2. **_HTTP/2_**

   - **_출시 연도_**: 2015년

   - **_주요 특징_**:

     1. **이진 프로토콜**(이전은 문자열, 해당 버전에선 이진 형식)

     2. **멀티 플렉싱**

     3. **서버 푸시**(서버는 클라이언트의 요청 없이도 필요한 자원을 미리 전송(css,js 등))

     4. **헤더 압축**(HPACK)

     5. **지속적 연결**

   - **_단점_**:

     1. **복잡성**

     2. **TCP 사용**(여전히 TCP)

3. **_HTTP/3_**

   - **_출시 연도_**: 2020년

   - **주요 특징**:

     1. **QUIC 프로토콜**(UDP 기반 프로토콜)

     2. **무연결성**(각 요청은 독립적이므로 다른 요청에서 패킷이 손실되도 지장없이 동작)

     3. **0-RTT 연결**(이전에 연결된 클라이언트는 연결 설정 없이 데이터 즉시 전송 가능)

     4. **내장 암호화**(QUIC은 모든 데이터 암호화)

     5. **멀티플렉싱 및 헤더 압축**(이전 버전 기능)

   - **단점**:

     1. **UDP 기반**(패킷 손실 시 재전송 방식이 TCP와 다르게 동작할 가능성)

     2. **서버 지원 필요**(HTTP/3를 지원하는 웹 서버가 적다)

4. **요약**

   1. **HTTP/1.1**: 텍스트 기반, 요청/응답 모델, 다수의 연결 필요.

   2. **HTTP/2**: 이진 프로토콜, 멀티 플렉싱, 서버 푸시, 헤더 압축.

   3. **HTTP/3**: QUIC 기반, 무연결성, 0-RTT 지원, 내장 암호화.

### SSL/TLS

SSL("Secure Sockets Layer")과 TLS("Transport Layer Security")는 인터넷에서 데이터 전송 시 보안을 제공하는 프로토콜입니다. SSL은 초기 버전, TLS는 후기 버전입니다.

1. **목적**

   데이터 암호화, 인증 및 무결성 보장.

2. **SSL과 TLS의 관계 및 성능**

   1. **TLS는 SSL의 후속 프로토콜**(실제로 TLS 1.0은 SSL 3.0의 개선 버전으로 간주. 같이 묶어 불리는 경우가 많습니다)

   2. **성능 개선**:

      - 암호화 및 복호화 과정 최적화, 성능 향상. TLS 1.2와 TLS 1.3은 특히.

      - TLS 1.3에서는 핸드쉐이크 과정이 간소화되었습니다.

   3. **HTTP/3와의 통합**:

      HTTP/3는 QUIC 프로토콜을 사용하며, QUIC는 TLS 1.3을 내장하고 있다.

### 웹 보안

1. **HTTPS 사용**(SSL/TLS)

2. **인증 및 권한 부여**(강력한 비밀번호 정책과 다단계 인증)

3. **입력 검증**(사용자 입력 검증으로 SQL 인젝션, 크로스 사이트 스크립팅(XSS) 등의 공격 방지)

4. **정기적인 업데이트**(알려진 취약점 차단)

5. **백업 및 복구 계획**

6. **방화벽 및 IDS/IPS**

### MFA(Multi-Factor Authentication)

- **정의**: 사용자가 로그인할 때 두 개 이상의 인증 요소를 요구하는 방식입니다.

- **요소**

  1.  **지식 기반**

  2.  **소지 기반**

  3.  **고유 기반**(생체 정보)

### IDS/IPS (Intrution Detection System / Intrution Prevention System)

1. **정의**:

   - **IDS**: 네트워크 또는 시스템에서 비정삭적인 활동이나 침입 시도를 감지하는 시스템입니다.

   - **IPS**: IDS의 기능에 추가로, 감지된 공격을 차단하는 기능을 갖춘 시스템입니다.

2. **기능**:

   - **IDS**: 로그 모니터링, 알림 전송 등으로 공격을 경고합니다.

   - **IPS**: 실시간으로 공격을 차단하고, 네트워크 트래픽을 분석하여 위협을 방지합니다.

### HTTP와 HTTPS의 차이

보안, HTTP는 데이터 암호화가 없지만, HTTPS는 SSL/TLS 프로토콜을 사용하여 데이터를 암호화한다.

### HTTP 상태 코드

HTTP 상태 코드는 클라이언트의 요청에 대한 서버의 응답 상태를 나타내는 3자리 숫자 코드입니다.

1. **_정보 응답 (1XX)_**

   - **100 Continue**(요청 계속 가능)

   - **101 Switching Protocols**(클라이언트 요청에 맞춰 프로토콜 변경)

2. **_성공 응답(2XX)_**

   - **200 OK**(요청 성공)

   - **201 Created**(요청 성공, 자원 생성)

   - **202 Accepted**(요청 접수, 아직 완료X)

   - **204 No Content**(요청 성공, 반환 내용없음)

3. **_리다이렉션(3XX)_**

   - **300 Mutiple Choices**(요청 자원이 여러 개, 클라이언트의 선택 필요)

   - **301 Moved Permanetly**(영구적인 URL 리다이렉션)

   - **302 Found**(임시적인 URL 리다이렉션)

   - **304 Not Modified**(요청된 자원이 수정X)

4. **_클라이언트 오류 (4XX)_**

   - **400 Bad Request**(잘못된 요청)

   - **401 Unauthorized**(인증 필요 혹은 실패)

   - **403 Forbidden**(요청 이해, 서버가 거부)

   - **404 Not Found**(자원 없음)

   - **405 Method Not Allowed**(요청한 HTTP 메서드 지원X)

   - **408 Request Timeout**(요청 시간 초과)

5. **서버 오류 (5XX)**

   - **500 Internal Server Error**(서버 내부 오류)

   - **501 Not Implemented**(서버가 기능을 지원 X)

   - **503 Service Unavailable**(서버가 과부하 혹은 유지보수 중)

   - **504 Gateway Timeout**(게이트웨이가 타임아웃)

### 3-Way-HandShake 및 4 Way-HandShake

1. **3-Way-HandShake (연결 설정)**(TCP 연결 설정)

   1. **SYN**: SYN(세그먼스 시작) 패킷 전송, 클라이언트의 초기 시퀸스 번호 포함.

   2. **SYN-ACK**: 서버에서 응답으로 SYN-ACK 패킷 전송, 서버의 초기 시퀸스 번호와 클라이언트의 시퀸스 번호를 확인하기 위한 ACK 포함.

   3. **ACK**: 연결 확인의 ACK 패킷 전송, 완료.

2. **4-Way HandShake (연결 종료)**

   1. **FIN**: 클라이언트에서 FIN(종료) 패킷 전송.

   2. **ACK**: 서버 FIN 패킷 수신, 서버에서 응답으로 ACK 패킷 전송, 클라이언트에서 서버로의 데이터 전송 종료.

   3. **FIN**: 서버에서 FIN 패킷 전송, 서버에서 클라이언트로의 데이터 전송 종료 의사.

   4. **ACK**: 클라이언트 FIN 패킷 수선, 클라이언트 종료 요청 확인으로 ACK 패킷 전송. 연결은 종료.

### 세션 기반 인증과 토큰 기반 인증

웹 애플리케이션에서 사용자의 인증을 처리하는 방법.

- **세션 기반 인증**

  1.  **서버 저장 방식**(세션)

  2.  **상태 유지**(여러 요청 사이에서도 상태 유지)

  3.  **보안**(서버 저장으로 유리함, 대신 세션 하이재킹 등의 공격엔 취약)

  4.  **확장성 나쁨**(여러 서버가 필요하면, 세션을 공유하는 추가 작업 필요)

- **토큰 기반 인증**

  1.  **클라이언트 저장 방식**(클라이언트면 로컬 스토리지나 쿠키나 상관X)

  2.  **상태 비유지**

  3.  **보안**(만료 시간과 서명, CSRF(Cross-Site Request Forgery)와 같은 공격에 취약)

  4.  **확장성 좋음**(클라이언트 저장)

### google.com을 입력했을 때

1. **URL 입력 및 브라우저 처리**(URL 해석 및 HTTP 요청 생성)

2. **DNS 조회**(DNS 리졸버에 요청, DNS 리졸버는 캐시, 루트 DNS 서버, TLD 서버, 권한 있는 서버 순으로 도메인의 IP 주소를 찾는다)

3. **TCP 연결 설정**(3-way handShake 포함)

4. **HTTP 요청 전송**

5. **서버 처리 및 응답**(서버에서 HTML, CSS, JS를 포함한 콘텐츠를 가진 페이지를 HTTP 응답으로 브라우저로 전송.)

6. **페이지 렌더링**(렌더링한 후 페이지 표시)

7. **추가 리소스 요청**(이미지나 스크립트 등 추가적인 리소스 필요시 요청)

수 밀리 초 안에 일어난다.

### 크로스 브라우징

크로스 브라우징은 웹 애플리케이션이나 웹 사이트가 다양한 클라이언트에서 일관되게 작동하고, 동일한 UX를 제공하는 것을 의미합니다.

1. **_주요 요소_**

   1. **호환성**(각 브라우저는 표준이 다를 수 있으므로, 고려 필요)

   2. **디자인**(브라우저별로 CSS의 렌더링이 다를 수 있다.)

   3. **기능성**(JS 기능이나 API 사용이 브라우저마다 다를 수 있다.)

2. **크로스 브라우징을 고려해야 하는 이유**

   1. **사용자 경험**

   2. **접근성**(다양한 디바이스로 이용 가능)

   3. **시장 점유율**(다양한 브라우저의 사용자층 섭렵 가능)

3. **크로스 브라우징 문제 해결 방법**

   1. **CSS 리셋 및 Normalize**

   2. **폴리필(Polyfill)**(기능 추가)

   3. **브라우저 테스트**

   4. **프레임워크 및 라이브러리 사용**(React, Angular, Vue.js와 같은 프레임워크 및 라이브러리는 호환성을 잘 처리)

### 웹 접근성

웹 접근성(Web Accessibility)은 장애인과 비장애인을 포함한 모든 사용자가 웹 콘텐츠에 접근하고 사용할 수 있도록 보장하는 개념입니다.

1. **주요 요소**

   1. **장애 유형**

   2. **사용자 유형**(모바일, 느린 인터넷, 다양한 브라우저)

2. **웹 접근성의 중요성**

   1. **포괄적인 사용자 경험**(사용자수 증가)

   2. **법적 요구사항**(미국의 ADA(American with Disabilities Act) 등)

   3. **사회적 책임**

3. **웹 접근성을 위한 원칙**

   1. **명확성(Perceivable)**(모든 콘텐츠는 인식 가능해야 합니다. 예를 들어, 이미지에는 대체 텍스트를 통해 시각 장애인이 내용을 알 수 있도록 합니다.)

   2. **운용 가능성(Operable)**(키보드로도 접근 가능해야 합니다.)

   3. **이해 가능성(Understandable)**(정보와 인터페이스는 이해하기 쉬워야 합니다.)

   4. **견고성 (Robust)**(다양한 사용자 에이전트(브라우저, 스크린 리더 등)에서 잘 작동해야 합니다.)

4. **웹 접근성을 높이기 위한 방법**

   1. **적절한 HTML 사용**(의미론적 HTML 사용)

   2. **대체 텍스트 제공**

   3. **키보드 네비게이션 지원**(키보드로 접근가능하도록 작성)

   4. **명확한 색상 대비**(시각적으로 약한 사용자도 쉽게 읽을 수 있도록 작성)

   5. **사용자 피드백 요청**(실제 사용자에게 접근성 테스트)

### JWT

JWT(제이슨 웹 토큰, JSON Web Token)는 인증 및 정보 교환을 위해 사용되는 개방형 표준(RFC7519)입니다.

1. **_주요 구성 요소_**

   1. **헤더(Header)**(토큰의 유형, 서명 알고리즘 정의)

   2. **페이로드(Payload)**(실제 데이터, 클레임(사용자 정보, 토큰의 만료 시간 등) 정보 포함)

   3. **서명(Signature)**(헤더와 페이로드 조합 후 비밀 키로 서명, 무결성 보장)

header.payload.signature
각 부분은 Base64Url로 인코딩.

2. **장점**

   1. **자체 포함형**(JWT엔 모든 정보가 있어, 세션 필요 X)

   2. **확장성 좋음**

   3. **다양한 플랫폼 지원**(프로그래밍 언어나 플랫폼에 구애 X)

3. **사용 사례**

   1. **인증**

   2. **정보 교환**

4. **보안 고려사항**

   - **비밀키 관리 주의**

   - **만료 시간 설정 권장**

### 대칭 비밀 키 암호화와 비대칭 키 암호화 방식

- **_대칭 비밀 키 암호화 (Symmetric Key Encryption)_**

  1.  **_정의_**: 암호화와 복호화에 동일한 키를 사용하는 방식.

  2.  **_장점_**

      - **속도 빠름**

      - **간단한 구현**

  3.  **단점**

      - **키 분배 문제**(암호화와 복호화에서 같은 키 사용으로 안전하게 키 공유 및 관리 어려움)

      - **확장**(사용자 수가 많아지면 키 관리가 복잡해짐, 수많은 비밀키를 각 개인이 소유해야 함)

  4.  **예시 알고리즘**(AES(고급 암호화 표준), DES(데이터 암호화), Blowfish 등)

- **비대칭 키 암호화 (Asymmetric Key Encryption)**

  1.  **정의**: 암호화와 복호화에 다른 키를 사용하는 방식.(공개키, 비밀키)

  2.  **장점**

      - **키 분배 용이**(공캐 키, 비밀 키로 암호화와 복호화의 키 분리)

      - **디지털 서명**(비밀키의 존재 덕분)

  3.  **단점**

      - **속도 느림**

      - **복잡성**

  4.  **예시 알고리즘**: RSA, DSA(디지털 서명 알고리즘), ECC(타원 곡선 암호화) 등.

### 퍼블릭 IP와 프라이빗 IP

- **_퍼블릭 IP (Public IP)_**

  1. **_정의_**

     - 퍼블릭 IP는 인터넷에 연결된 장치가 어디서나 접근 가능한 주소입니다.

     - 인터넷 서비스 제공업체(ISP)에 의해 할당됩니다.

  2. **_특징_**

     - **고유성**

     - **접근 가능성**(인터넷의 다른 장치와 모두 연결가능)

     - **변경 가능성**(ISP에 따라 주기적으로 변경가능)

  3. **사용 예**: 웹 서버, 이메일 서버 등

- **_프라이빗 IP (Private IP)_**

  1.  **_정의_**:특정 네트워크에서만 사용되는 주소.

  2.  **_특징_**

      - **비고유성**(다른 네트워크에서 사용가능)

      - **제한된 범위**: RFC 1918에 정의된 특정 IP 범위 내에서만 사용 가능합니다.

        - **클래스 A**: 10.0.0.0 ~ 10.255.255.255

        - **클래스 B**: 172.16.0.0 ~ 172.31.255.255

        - **클래스 C**: 192.168.0.0 ~ 192.168.255.255

      - **NAT 사용**(인터넷 접근 시, NAT를 통해 퍼블릭 IP로 전환)

  3.  **사용 예**: 가정이나 회사의 로컬 네트워크 내의 컴퓨터, 스마트폰, 프린터 등.

### ISP(Internet Service Provider)

인터넷 접속 서비스를 제공하는 회사나 기관을 의미합니다.

1. **_주요 기능과 서비스_**

   1. **인터넷 접속**(DSL, 케이블, 광섬유, 위성 등으로 제공)

   2. **도메인 등록**(도메인 이름을 등록하고 관리합니다.)

   3. **호스팅 서비스**(고객이 인터넷에서 콘텐츠를 서비스할 수 있도록 지원합니다.)

   4. **기술 지원**(인터넷 연결 문제, 장비 설정 등의 기술 지원을 제공합니다.)

   5. **보안 서비스**(방화벽, VPN(가상 사설망), 안티바이러스 솔루션 등)

2. **_ISP의 종류_**

   1. **전국 ISP**(대규모 네트워크를 운영, 전국적으로 서비스 제공.)

   2. **지역 ISP**(특정 지역에 집중, 지역 사회의 특성에 맞춘 서비스와 지원을 제공.)

   3. **전문 ISP**(특정 서비스에 집중하는 업체, 해당 서비스에서 전문적인 서비스를 제공.)

### IPv4, IPv6의 차이

IPv4(인터넷 프로토콜 버전 4), IPv6(인터넷 프로토콜 버전 6)는 둘 다 인터넷에서 장치 간 통신을 위해 사용하는 두 가지 IP 주소 체계입니다.

1. **_주소 형식_**

   - **IPv4**: 32 비트 주소 체계, 4개의 10진수로 구분된 숫자로 구성, 2^32개의 IP주소

   - **IPv6**: 128 비트 주소 체계, 8개의 16진수로 구분된 숫자로 구성, 2^128개의 IP주소

2. **_주소 공간_**

   - **IPv4**:주소가 적어, 고갈되어 갑니다.

   - **IPv6**:주소가 상대적으로 많아, IP 주소 고갈 문제를 해결가능합니다.

3. **_헤더 구조_**

   - **IPv4**: 헤더가 복잡하고 가변적인 필드 탓에, 처리 속도가 느릴 수 있습니다.

   - **IPv6**: 헤더가 간소화되었고, 필드 수가 줄어 라우팅과 패킷 처리 효율이 높아졌습니다.

4. **_NAT(Network Address Translation)_**

   - **IPv4**: IP 주소 고갈 문제 해결을 위한 NAT 사용, 여러 장치가 하나의 퍼블릭 IP 주소를 공유합니다.

   - **IPv6**: IP 주소가 많아, NAT의 필요성이 적다.

5. **_보안_**

   **IPv4**: 보안 기능이 선택 사항이며, 보안이 강화된 프로토콜의 필요성이 크다.

   **IPv6**: IPSec을 기본적으로 내장하고 있다.

6. **_멀티캐스트와 기타 기능_**

   **IPv4**: 멀티캐스트 기능이 지원하지만, 범위와 유용성에 제한이 있습니다.

   **IPv6**: 멀티캐스트, Anycast 등 다양한 통신 방식이 내장되어 있습니다.

### IPSec

IPSec(Internet Protocol Security)은 인터넷 프로토콜(IP) 통신의 보안을 제공하기 위해 설계된 프로토콜 집합입니다.

1. **_주요 특징 및 구성 요소_**

   1. **가능**

      - **기밀성**(데이터 암호화)

      - **무결성**

      - **인증**(데이터 출처 확인)

   2. **구성 요소**

      - **AH(Authentication Header)**(데이터의 인증과 무결성만 제공. 원본 인증, 변조 확인.)

      - **ESP(Encapsulating Security Payload)**(데이터의 인증과 무결성, 기밀성을 제공. 데이터 암호화, 인증 정보 추가.)

   3. **모드**

      - **전송 모드(Transport Mode)**(IP 패킷의 페이로드만 암호화, 주로 호스트 간의 통신에 사용.)

      - **터널 모드 (Tunnel Mode)**(전체 패킷을 암호화하여 새로운 IP 헤더를 추가, 주로 두 네트워크 간의 VPN 연결에 사용.)

   4. **키 관리**

      - IKE(Internet Key Exchange) 프로토콜을 사용합니다. IKE는 보안 연결을 설정하고, 암호화 키를 교환합니다.

2. **_사용 사례_**

   - **VPN**(원격 사용자가 안전하게 기업 네트워크에 접속할 수 있도록 하는 데 주로 사용.)

   - **데이터 보호**

### OAuth

OAuth(오픈 인증, Open Authorization)은 사용자 인증 및 권한 부여를 위한 프로토콜로, 사용자 정보를 안전하게 공유할 수 있도록 설계되었습니다.

1. **_주요 특징_**

   1. **권한 부여**

      OAuth는 사용자(자원 소유자)가 자신의 자원에 대한 접근을 특정 애플리케이션(클라이언트)에 허용하는 메커니즘을 제공합니다.

   2. **토큰 기반**

      OAuth는 사용자 인증 후에 권한 부여 토큰을 발급하며, 해당 토큰을 통해 애플리케이션이 자원에 접근할 수 있도록합니다.

   3. **스코프**

      사용자가 애플리케이션에 권한을 부여할 때, 특정 자원이나 작업에 대한 접근 범위를 지정할 수 있습니다.

2. **_다양한 플로우_**

   - **Authorization Code Grant**(서버 간의 안전한 통신을 위해 주로 사용.)

   - **Implicit Grant**(주로 웹 브라우저 기반의 애플리케이션에서 사용)

   - **Resource Owner Password Credentials Grant**(사용자가 직접 비밀번호를 입력하여 권한을 부여.)

   - **Client Credentials Grant**(서버 간의 통신에서 사용.)

3. **사용 사례**

   - **소셜 로그인**

   - **API 접근**

### 서드파티

서드파티라는 용어는 거래나 계약, 서비스에 관련된 세 주체를 의미합니다.

1. **주체 간의 관계**

   - **제1자 (First Party)**(사용자.)

   - **제2자 (Second Party)**(공급자나 서비스 제공자.)

   - **서드파티(Third Party)**(외부 주체, 독립적인 서비스나 기능을 제공하는 업체.)

2. **예시**

   - **소프트웨어**

   - **결제 시스템**

   - **애드온 및 플러그인**

3. **장점과 단점**

   - **장점**: 개발 시간 단축, 기능 확장에 유리.

   - **단점**: 보안이나 안정성 불안, 서드파티 서비스의 정책 변화나 서비스 중단 고려필요.

### WAS

WAS(Web Application Server, 웹 애플리케이션 서버)는 웹 어플리케이션을 실행하고 관리하는 서버입니다.

1. **주요 기능**

   1. **애플리케이션 실행**

   2. **비즈니스 로직 처리**

   3. **세션 관리**

   4. **통신 프로토콜 지원**

   5. **로드 밸런싱 및 확장성**

   6. **보안 기능**

2. **예시**

   - **JAVA 기반 WAS**

   - **.NET 기반 WAS**

   - **js 기반 WAS**: Node.js, Express.js, NestJS, koa.js 등

### WS

웹 서비스의 약자로, 웹 서비스는 서로 다른 애플리케이션 간에 데이터를 전송하고 상호작용할 수 있도록 해주는 소프트웨어 시스템입니다.

1. **_주요 특징_**

   1. **인터넷 기반**(다양한 플랫폼과 언어에서 호환이 가능)

   2. **표준 프로토콜**(SOAP(Simple Object Access Protocol)나 REST(Representational State Transfer)와 같은 표준 프로토콜을 사용.)

      - **SOAP**: XML 기반의 메시지 프로토콜, 보안성이 중요시되는 애플리케이션에서 사용합니다.

      - **REST**: HTTP 프로토콜을 기반으로 하며, JSON, XML 등을 사용하여 데이터를 전송합니다.

   3. **서비스 지향 아키텍처(SOA)**: 웹 서비스는 SOA의 중요한 구성 요소, 독립적으로 개발된 서비스들이 상호작용하여 더 큰 시스템을 구성합니다.

   4. **상호 운용성**: 웹 서비스는 서로 다른 시스템과 플랫폼 간의 상호 운용성을 지원한다.

2. **_사용 사례_**

   - **API 제공**

   - **비즈니스 통합**

   - **모바일 애플리케이션**

## _코딩_

## 콜백함수

### AJAX

AJAX는 Asynchronous JavaScript and XML의 약자로, 웹 페이지를 비동기적으로 업데이트할 수 있도록 해주는 기술입니다.

1. **AJAX의 주요 특징**

   1. **비동기성**(클라이언트가 서버에 요청을 보내는 동안 웹 페이지가 멈추지 않고 사용자와 상호작용.)

   2. **부분 업데이트**(웹페이지의 일부만 업데이트 가능.)

   3. **다양한 데이터 형식 지원**(다양한 데이터 형식을 지원하지만, 특히 JSON은 데이터 전송 형식으로 많이 사용하고 JS와 호환성이 높다.)

   4. **비동기 요청**(AJAX는 JS의 XMLHttpRequest 객체를 사용하여 서버에 비동기적으로 요청을 보냅니다)

2. **AJAX의 동작 방식**

   1. **사용자 인터페이스 이벤트**(이벤트 발생)

   2. **AJAX 요청 생성**(JS를 사용하여 XMLHttpRequest 객체를 생성, 서버에 비동기 요청)

   3. **서버 처리**(서버가 처리 및 응답)

   4. **응답 처리**(클라이언트 응답 받고, JS로 특정 부분 업데이트)

3. **AJAX의 장점**

   1. **빠른 사용자 경험**(부분 업데이트 장점)

   2. **서버와의 효율적인 데이터 통신**(필요한 데이터만 요청 가능)

   3. **인터렉티브한 웹 애플리케이션**(실시간 업데이트가 가능한 동적인 웹 애플리케이션 작성가능)

4. **AJAX의 단점**

   1. **SEO 문제**(CSR의 문제점과 동일)

   2. **브라우저 호환성**(구식 브라우저와의 호환성 문제)

   3. **복잡성 증가**

### 동기와 비동기

통신에서 동기(Synchronous)와 비동기(Asynchronous) 처리는 데이터 전송 및 응답을 처리하는 방식에 대한 개념입니다.

1. **동기(Synchronous)**

   - **정의**: 요청을 보낸 후, 응답을 받을 때까지 기다리는 방식.

   - **특징**: 코드의 흐름이 요청과 응답에 따라 직선적으로 진행됩니다. UI가 정지될 수 있습니다. 구현이 간단하고 이해하기 쉬운 경우가 많습니다.

   - **예시**: JS의 XMLHttpRequest 사용

2. **비동기(Asynchronous)**

   - **정의**: 요청을 보낸 후, 응답을 기다리지 않고 수행하는 방식입니다.(콜백, 프로미스)

   - **특징**: 코드의 흐름이 요청과 응답과 독립적입니다. 부분 업데이트로 UX의 향상이 가능, 비즈니스 로직을 구현에 유용하다.

### async/await 외의 비동기 처리 방법

- **Promise**

  JavaScript의 비동기 처리 방법. then, catch, finally 메서드 이용.

- **콜백 함수**

  비동기 작업이 완료된 후 호출되는 함수를 정의하여 결과를 처리합니다. 콜백 헬은 주의해야 합니다.

- **RxJS**

  Reactive Programming 라이브러리로, 스트림을 통해 비동기 데이터를 처리할 수 있습니다.

- **EventEmitter**

  Node.js의 이벤트 기반 프로그래밍 패턴을 사용하여 이벤트가 발생할 때 비동기 처리를 수행할 수 있습니다.

### RXJS

RXJS (Reactive Extenstions for JavaScript)는 비동기 데이터 흐름을 처리하기 위한 라이브러리로, 옵저버블 패턴을 사용하여 데이터를 스트림 형태로 다룹니다.

1. **주요 개념**

   1. **옵저버블 (Observable)**

      데이터 스트림을 나타내며, 데이터를 발행하는 주체입니다.

   2. **옵저버 (Observer)**

      옵저버블을 구독하고, 데이터가 발행될 때마다 알림을 받는 객체입니다.

   3. **구독 (Subscription)**

      옵저버블을 구독하는 행위로, 데이터가 발행되면 콜백이 실행됩니다.

   4. **연산자 (Operators)**

      옵저버블을 변환하거나 조작하는 함수들입니다. 예를 들어, map, filter, merge, switchMap 등의 연산자가 있습니다.

2. **기본 사용법**

   ```bash
   npm install rxjs
   ```

   ```js
   import { Observable } from "rxjs";

   // 옵저버블 생성
   const myObservable = new Observable((subscriber) => {
     subscriber.next("Hello");
     subscriber.next("World");
     subscriber.complete();
   });

   const myObserver = {
     next: (value) => console.log(value),
     error: (err) => console.error(err),
     complete: () => console.log("Done"),
   };

   // 옵저버블 구독
   myObservable.subscribe(myObserver);
   ```

3. **연산자 사용 예제**

   ```js
   import { of } from "rxjs";
   import { map, filter } from "rxjs/operators";

   const number = of(1, 2, 3, 4, 5);

   // 연산자를 사용한 예제
   const processedNumbers = numbers.pipe(
     filter((x) => x % 2 === 0), // 짝수만 통과
     map((x) => x * 10) // 각 숫자에 10 곱하기
   );

   processedNumbers.subscribe(console.log); // 20, 40
   ```

4. **장점**

   1. **콜백 지옥 회피와 간소화된 코드**

   2. **연산자 체이닝을 통한 간단한 구성 가능성**

   3. **다양한 데이터 소스를 통합, 응답성 유지**

### 데이터의 스트림 형태

데이터의 스트림 형태는 데이터를 연속적으로 생성하고 처리하는 방식을 나타냅니다.

1. **_스트림의 기본 개념_**

   1. **스트림**

      데이터의 연속적인 흐름을 나타냅니다. 스트림은 시간에 따라 변화하는 데이터 시퀸스를 의미합니다.

   2. **발행자 (Publisher)**

      데이터를 생성하고 스트림에 발행하는 주체입니다. 이는 옵저버블 형태로 구현됩니다.

   3. **구독자 (Subscriber)**

      스트림의 데이터를 소비하고 반응하는 주체입니다. 구독자는 발행자가 발행하는 데이터에 대해 반응합니다.

   4. **변환 및 조작**

      스트림의 데이터를 변환하거나 필터링하는 연산자들이 사용됩니다.

2. **_스트림의 종류_**

   1. **단방향 스트림**: 데이터가 한 방향으로만 흐릅니다.(클릭, 입력 등)

   2. **양방향 스트림**: 데이터가 양 방향으로 흐를 수 있습니다.(웹 소켓 통신)

3. **_스트림 처리의 장점_**

   1. **비동기 처리**

   2. **조합 가능성**(여러 데이터 소스를 하나의 스트림으로 결합 가능)

   3. **지연 평가**(필요할 때만 데이터를 처리할 수 있다.)

4. **예시**

   ```js
   import { fromEvent } from "rxjs";
   import { map } from "rxjs/operators";

   // 버튼 클릭 이벤트 스트림 생성
   const button = document.getElementById("myButton");
   const clicks = fromEvent(button, "click");

   // 클릭 이벤트를 처리하여 좌표를 로그에 남김
   const positions = clicks.pipe(
     map((event) => ({ x: event.clientX, y: event.clientY }))
   );

   positions.subscribe((pos) => console.log(`X: ${pos.x}, Y: ${pos.y}`));
   ```

   이벤트로 클릭할 때마다 데이터(좌표) 발행.

### Promise

Promis는 JavaScript에서 비동기 작업을 처리하기 위한 객체입니다. 주로 비동기 연산의 성공 또는 실패 결과를 다루기 위해 사용됩니다.

1. **대기(pending)**: 초기 상태로, 비동기 작업이 아직 완료되지 않은 상태입니다.

2. **이행(fulfilled)**: 비동기 작업이 성공적으로 완료되었을 때의 상태입니다. 결과 값을 반환합니다.

3. **거부(rejected)**: 비동기 작업이 실패했을 때의 상태입니다. 오류 이유를 반환합니다.

### 메서드 체이닝이란? 장단점은?

1. **메서드 체이닝(Method Chaning)이란?**

   메서드 체이닝은 객체지향 프로그래밍에서 하나의 객체에 대해 여러 메서드를 연속적으로 호출할 수 있도록 하는 방법입니다.

2. **장점**

   1. **가독성 향상**

   2. **코드 간소화**

   3. **편리한 API 설계**

3. **단점**

   1. **디버깅의 어려움**(메서드 체이닝으로 인해 각 결과를 추적하기 어려워진다. 특히 오류 발생의 위치.)

   2. **불변성의 손실**(객체가 불변성을 유지하기 힘듬)

   3. **하나의 큰 객체**(남용시에 하나의 객체가 너무 많은 책임을 가지게 된다.)

## 콜백 함수

콜백 함수는 다른 함수의 인자로 전달되어 특정 시점에 호출되는 함수를 의미합니다.

- **_주요 특징_**

  - **비동기 처리**: 콜백 함수는 주로 비동기 작업이 완료된 후 실행됩니다.

  - **유연성**: 다른 함수에 인자로 전달됨으로써, 함수의 동작을 외부에서 조작할 수 있습니다.

### 프라미스와 콜백함수의 차이점과 각각의 장단점은?

프라미스와 콜백함수는 자바스크립트에서 비동기 작업을 처리하는 두 가지 주요 방법입니다.

1. **_콜백 함수_**

   콜백 함수는 특정 작업이 완료된 후 호출되는 함수입니다.(인수로 사용되는 함수)

   1. **_장점_**

      1. **단순함**(간단한 작업은 구현이 쉽고 직관적)

      2. **전통적인 사용법**(JS에서 주로 쓰이는 방식)

   2. **_단점_**

      1. **콜백 지옥**

      2. **에러 처리 어려움**

2. **_프라미스_**

   프라미스는 비동기 작업의 완료 또는 실패를 나타내는 객체입니다.

   1. **_장점_**

      1. **가독성**(메서드 체이닝 활용으로 읽기 쉬움)

      2. **에러 처리**(catch 메서드 활용으로 한곳에서 모든 오류 처리 가능)

      3. **비동기 코드 흐름 관리**(async, await를 활용할 수 있음)

   2. **단점**

      1. **복잡성**(경우에 따라 더 복잡함)

      2. **상태 관리**(이행, 거부, 대기를 모두 관리해야 함)

   3. **비동기 처리 방식**

      - **콜백함수**: 비동기 작업이 완료되면 호출됩니다.

      - **프라미스**: 비동기 작업의 완료 또는 실패를 나타내는 객체입니다.

   4. **가독성**

      - **콜백 함수**: 중첩되면 콜백지옥.

      - **프라미스**: then, catch의 메서드 체이닝으로 상대적으로 가독성이 좋은 편입니다.

   5. **에러 처리**

      - **콜백 함수**: 각 콜백.

      - **프라미스**: catch 블록.

   6. **비동기 흐름 제어**

      - **콜백 함수**: 복잡함.

      - **프라미스**: async/await로 제어 가능.

   7. **단순성**

      - **콜백 함수**: 간단한 비동기 작업.

      - **프라미스**: 복잡한 비동기 작업.

### 콜백지옥

콜백지옥은 비동기 프로그래밍에서 콜백 함수가 중첩되어 작성될 때 발생하는 코드의 가독성 저하와 유지보수 어려움을 의미합니다.

1. **특징**

   1. **중첩된 구조**

   2. **가독성 저하**

   3. **에러 처리의 복잡성**

2. **해결 방법**

   1. **Promise**

   2. **async/await**

## 코딩이론

### 추상화

추상화(Abstraction)는 복잡한 시스템이나 개념을 단순화하여 중요한 정보나 특성만을 드러내고, 불필요한 세부사항을 숨기는 과정입니다.

1. **_소프트웨어 개발에서의 추상화_**

   1. **목적**: 코드의 복잡성을 줄이고, 재사용성을 높이고, 시스템의 이해도를 높이는 것입니다.

   2. **예시**

      1. **객체지향 프로그래밍**: 클래스와 객체를 사용하여 복잡한 현실 세계의 개념을 모델링합니다.

      2. **API**: 제공되는 기능의 세부사항을 알 필요가 없게 만듭니다.(예: OAUTH 로직이나 위치추적 로직 등)

2. **_추상화의 유형_**

   1. **데이터 추상화**: 필요한 기능만을 노출하는 방법.

   2. **절차적 추상화**: 복잡한 알고리즘이나 프로세스를 여러 개의 간단한 단계로 나누는 방법.

3. **_장점_**

   1. **복잡성 감소**

   2. **재사용성**

   3. **유지보수 용이성**(모듈화가 잘 이루어진다)

4. **_단점_**

   1. **성능 저하**(불필요한 오버헤드 증가)

   2. **추상화의 오해**(기능이나 성격을 착각하게 할 수 있음)

### 원시 타입과 참조타입에 대해서

1. **_원시 타입 (Primitive Type)_**

   - **정의**: 단일 값으로 표현되며, 불변(immutable)입니다.

   - **종류**: JS에서는 string, number, boolean, null, undefined, symbol, bigint가 원시 타입입니다.

   - **저장 방식**: 값 자체가 스택에 저장됩니다.

2. **_참조 타입(Reference Type)_**

   - **정의**: 객체 형태로 여러 값을 포함할 수 있으며, 가변(mutable)입니다.

   - **종류**: Object, Array, Function, Date, 사용자 정의 객체 등입니다.

   - **저장 방식**: 값이 힙에 저장되고, 변수에는 해당 값의 참조(주소)가 저장됩니다.

### 가비지 컬렉터(Garbage Collector, GC)

더 이상 필요하지 않은 객체를 찾아 메모리에서 해제함으로써 메모리 누수를 방지하고, 효율적으로 메모리를 관리하는 시스템입니다.

1. **가비지 컬렉션의 원리**

   1. **메모리 할당**(객체의 메모리 할당)

   2. **참조 카운팅**(각 객체는 자신을 참조하는 다른 객체의 수를 추적)

   3. **루트 검색**(가비지 컬렉터는 **루트**라고 불리는 참조 집합(전역 변수, 스택 변수 등)을 기준으로 여전히 참조되고 있는 객체들을 추적)

   4. **가비지 식별**(루트에서 도달할 수 없는 객체는 가비지로 간주)

   5. **메모리 해제**(메모리에서 해제)

2. **가비지 컬렉션의 방식**

   1. **Mark-and-Sweep**: 객체를 마킹하여 사용중과 사용하지 않은 객체를 구분한 후, 사용하지 않은 객체를 메모리에서 해제합니다.

   2. **Generational Garbage Collection**: 객체의 생애 주기에 따라 세대별로 구분하여 관리합니다.

      - **원리**: **young generation**(새로 생성된 객체), **old generation**(일정 시간이 지난 객체)로 분리하고, 대부분의 객체는 짧은 생애를 가지므로 **young generation**에서 자주 가비지 컬렉션이 수행됩니다.

   3. **Reference Counting**: 각 객체의 참조 카운트를 유지, 카운트가 0이 되는 객체를 즉시 해제합니다.(순환 참조는 해결 못함)

3. **장점**

   - **메모리 관리의 자동화**

   - **메모리 누수 방지**

4. **단점**

   - **성능 저하**(가비지 컬렉션이 수행되는 동안 프로그램이 일시 중지될 수 있음)

   - **예측 불가능성**(자동 메모리 관리 시스템이므로 예측불가)

### 순환참조

순환참조(Circular Reference)는 두 개이상의 객체가 서로를 참조하여 발생하는 상황을 말합니다.

1. **_문제점_**

   1. **메모리 누수**

   2. **가비지 컬렉션의 비효율성**(참조 카운팅 방식은 인식하지 못함)

2. **_해결방법_**

   1. **마크 앤 스위프**: 루트에서 접근 가능한 객체르 마킹한 후, 마킹되지 않은 객체릃 해제합니다.

   2. **Weak Reference**: 참조된 객체가 다른 강한 참조가 없을 경우, 가비지 컬렉션의 대상이 됩니다.

   3. **명시적 해제**: 순환 참조를 미리 방지하거나, 객체의 참조를 명시적으로 해제합니다.

### 리팩토링

리팩토링(Refactoring)은 기존의 코드 구조를 개선하면서도 외부의 동작이나 기능은 변경하지 않는 과정을 의미합니다.

1. **_리팩토링의 목적_**

   1. **가독성 향상**

   2. **유지보수성 증대**(코드를 명확하고 체계적으로 구성)

   3. **중복 제거**

   4. **성능 최적화**

   5. **테스트 용이성**

2. **_리팩토링의 기법_**

   1. **코드 정리**

   2. **함수 및 메서드 분리**(분할)

   3. **변수 및 함수 이름 개선**

   4. **클래스 추출**(분할)

   5. **중복 코드 통합**

3. **_리팩토링의 중요성_**

   1. **품질 향상**

   2. **팀워크 개선**

   3. **비용 절감**(초기 개발 단계에서 진행)

4. **_리팩토링의 주의점_**

   1. **기능 변경 없음**

   2. **점진적 진행**

   3. **버전 관리**

### 클린 코드와 리팩토링 차이

- **_클린 코드_**

  1. **_정의_**: 읽기 쉽고 이해하기 쉬우며, 유지보수가 용이한 코드를 의미합니다.

  2. **_특징_**

     1. **가독성**

     2. **명확한 네이밍**

     3. **일관성**

     4. **단일 책임 원칙(SRP)**(각 함수나 클래스는 하나의 책임만을 가져야 한다)

     5. **테스트 용이성**

  3. **_초점_**:클린 코드는 코드 작성 시부터 품질을 높이는 것을 목표로 합니다.

- **_리팩토링_**

  1.  **_정의_**: 기존의 코드를 개선하면서도 기능을 변경하지 않고, 코드의 구조를 재조정하는 작업입니다.

  2.  **_특징_**

      1. **기존 코드 개선**

      2. **기능 불변성**

      3. **점진적 접근**

  3.  **_초점_**: 이미 작성된 코드의 품질을 향상시키기 위한 방법입니다.

### Call By Value와 Call By Reference

Call By Value와 Call By Reference는 함수에 인수를 전달하는 두 가지 주요 방식입니다.

- **_Call By Value_**

  1.  **정의**: 함수 호출 시, 인수의 값이 복사되어 함수에 전달됩니다.

  2.  **특징**

      - **복사**

      - **안정성**(원본 데이터는 변경되지 않음)

      - **메모리 사용 급증 가능성**(인수가 큰 데이터 구조일 경우, 복사로 인한 메모리 사용량 증가)

- **_Call BY Reference_**

  1.  **정의**: 함수 호출 시, 인수의 메모리 주소(참조)가 전달됩니다.

  2.  **특징**

      - **주소 전달**

      - **부작용**(원본 데이터가 변경될 수 있음)

      - **메모리 사용 급증 없음**(인수가 큰 데이터 구조라도, 메모리 사용량이 주소 복사이기에 급증하지 않는다.)

### TDD

테스트 케이스를 먼저 작성한 후 그에 맟춰 코드를 구현하는 방법론입니다.

1. **_TDD의 주요 단계_**

   1. **Red (테스트 실패)**: 구현할 기능에 테스트 케이스를 작성, 기능은 구현되지 않은 상태(실패해야 함).

   2. **Green (테스트 통과)**: 테스트 케이스를 통과시키기 위해 최소한의 코드를 작성합니다. 모든 테스트가 통과하는지 확인합니다.

   3. **Refactor (리팩토링)**: 코드가 잘 작동하면, 코드의 품질을 개선합니다.

2. **_TDD의 장점_**

   1. **버그 감소**: 테스트를 먼저 작성하기 때문에 코드의 결함을 사전에 발견할 수 있습니다.

   2. **리팩토링 용이**: 작성된 테스트로 리팩토링 후도 쉽게 검증 가능하다.

   3. **설계 개선**: 코드의 구조와 설계에 시간을 더 쏟게 된다.

   4. **명확한 요구 사항**

3. **TDD의 단점**

   - **시간 소요**: 개발 초기에는 시간과 노력이 더 들 수 있습니다.(테스트 케이스 작성)

   - **학습 곡선**: TDD의 개념을 익히고 적응하는 데 시간이 필요합니다.

   - **과도한 테스트**: 불필요한 테스트가 작성될 수도 있습니다.

### CI/CD

1. **CI (Continuous Integration)(지속적 통합)**: 개발자들이 코드를 자주 (보통 하루에 여러 번) 통합하는 방법입니다.

   - 각 코드 변경 사항은 자동으로 빌드되고 테스트되어, 통합 후 발생할 수 있는 문제를 빠르게 발견할 수 있습니다.

2. **CD (Continuous Delivery / Continuous Deployment)**

   CI의 확장으로, 코드 변경 사항이 자동으로 프로덕션 환경에 배포되는 프로세스입니다.

   - **Continuous Delivery**: 모든 코드 변경이 테스트를 통과하면 언제든지 배포할 준비가 되어 있는 상태입니다.(배포는 수동)

   - **Continuous Deployment**: 코드 변경이 자동으로 프로덕션 환경에 배포됩니다.

3. **장점**

   - **빠른 피드백**: 코드 변경마다 자동으로 테스트가 이루어져, 문제를 조기에 발견할 수 있습니다.

   - **일관된 품질**: 자동화된 테스트나 빌드를 통해 품질이 일관되게 유지됩니다.

   - **신속한 배포**

   4. **효율적인 협업**

### 트러블 슈팅 경험

트러블 슈팅 경험은 문제를 진단하고 해결하는 과정에서의 경험을 읨합니다.

1. **문제 정의**: 문제를 명확히 정의한다.

2. **정보 수집**: 로그 파일, 모니터링 도구, 사용자 피드백 등을 통해 문제의 원인을 파악할 수 있습니다.

3. **가설 설정**

4. **원인 분석**:가설을 검증하기 위한 추가 조사를 진행합니다.

5. **해결책 구현**

6. **결과 검증**: 문제 해결한 후, 결과를 검증합니다.

7. **문서화**: 문제의 원인, 해결 방법, 이후 예방 조치 등을 문서화합니다.

## 프론트엔드

### CSS 적용 순서

CSS 적용 순서는 스타일 시트가 HTML 문서에 적용되는 순서를 정의합니다.

1. **우선 순위 (Specificity)**

   CSS 선택자의 특이성에 따라 스타일이 적용됩니다.

   1. **인라인 스타일**: 1000점

   2. **ID 선택자**: 100점

   3. **클래스, 속성, 가상 클래스 선택자**: 10점

   4. **태그(요소) 선택자**: 1점

2. **출처 순서 (Source Order)**

   특정한 스타일이 여러 번 정의된 경우, 마지막에 선언된 스타일이 적용됩니다.

3. **스타일 적용 순서**

   밑의 순서대로.

   1. **브라우저 기본 스타일**: 각 브라우저는 기본적으로 제공하는 스타일이 있습니다.

   2. **사용자 스타일 시트**: 사용자가 브라우저에서 정의한 스타일이 있을 수 있습니다.

   3. **외부 스타일 시트**: \<link> 태그를 추가한 외부 CSS 파일의 스타일이 적용됩니다.(나중 스타일이 앞의 스타일을 덮어씀)

   4. **내부 스타일 시트**: \<style> 태그 안에 정의된 CSS가 적용됩니다.

   5. **인라인 스타일**: HTML 요소의 style 속성으로 정의된 CSS가 가장 높은 우선순위를 가집니다.

4. **!important 규칙**

   CSS 규칙에 !important를 추가하면 해당 스타일이 가장 높은 우선 순위를 가집니다.(일반적인 규칙의 적용 순서 무시 가능)

### 모달과 팝업의 차이

모달(Modal)과 팝업(Popup)은 웹에서 사용되는 인터페이스 요소로 사용자에게 추가적인 정보를 제공하거나 특정 작업을 유도하는 데 사용됩니다.

1. **_모달(Modal)_**

   1. **정의**: 모달은 사용자가 특정 작업을 완료할 때까지 다른 작업을 차단하는 대화상자입니다.(오버레이(겹침), 상호작용 요구)

   2. **특징**

      1. **블로킹**(다른 요소와 상호작용 불가)

      2. **명확한 목적**

      3. **일관된 디자인**(대부분은 비슷함)

   3. **사용 예**: 로그인 폼, 경고 메시지, 사용자 설정 변경 등.

2. **_팝업(Popup)_**

   1. **정의**: 팝업은 일반적으로 새로운 브라우저 창이나 탭으로 열리는 추가 콘텐츠입니다.

   2. **특징**

      1. **비블로킹**

      2. **자유로운 이동**(기존 페이지에 독립적)

      3. **사용 예**: 광고, 쿠키 등의 요청, 외부 링크로 연결되는 콘텐츠.

3. **_요약_**

   1. **모달**:

      1. 현재 작업을 차단하고, 사용자에게 특정 작업을 요구하는 대화 상자.

      2. 블로킹, 명확한 목적, 주로 중요한 정보나 입력을 요청할 때 사용.

   2. **팝업**:

      1. 새로운 브라우저 창이나 탭으로 열리며, 배경 페이지와 독립적으로 존재.

      2. 비블로킹, 광고나 외부 콘텐츠를 표시할 때 주로 사용.

### inline과 inline block의 차이

inline과 inline-block은 CSS에서 요소의 레이아웃을 설정하는 두 가지 값입니다.

- **주요 차이점 요약**

      1. **배치 방식**:

         - **Inline**: 같은 줄에서 흐름.

         - **Inline-block**: 같은 줄에서 흐름.

      2. **크기 조정**:

         - **Inline**: width와 height를 지정할 수 없음.

         - **Inline-block**: width와 height를 지정할 수 있음.

      3. **마진과 패딩**

         - **Inline**: 좌우 마진/패딩만 적용

         - **Inline-block**: 상하좌우 모두 적용

      4. **예시 요소**

         - **Inline**: \<span>, \<a>, \<strong> 등

         - **Inline-block**: \<div>, \<img>, 사용자 정의 요소 등

### 이벤트 위임

event Delegation, 이벤트 처리기법이며,
이 방법은 이벤트를 부모 요소에 설정하고, 자식 요소에서 발생한 이벤트를 부모 요소에서 처리하도록 하는 방식입니다.

1. **_작동 원리_**

   1. **이벤트 캡처링과 버블링**

      1. 이벤트가 발생하면 DOM 트리에서 아래에서 위로(bubbling) 또는 위에서 아래로 (capturing) 전달됩니다.

      2. 이벤트 위임은 주로 버블링 단계에서 발생하는데, 자식 요소에서 발생한 이벤트가 부모 요소로 전파될 때 부모에서 이를 감지하여 처리합니다.

   2. **부모 요소에 이벤트 리스너 추가**: 부모 요소에 이벤트 리스너를 추가하고, 이벤트가 발생했을 때 이벤트 객체를 통해 어떤 자식 요소에서 발생했는지를 확인합니다.

2. **_장점_**

   1. **성능 향상**(하나의 리스너로 처리, 메모리 사용량 줄어듬)

   2. **동적 요소 처리**(새로운 자식 요소에도 자동으로 이벤트가 추가된다)

   3. **코드 간소화**(한 곳에서 이벤트 처리하므로 코드 간소화)

3. **_단점_**

   1. **이벤트 전파 관리**(다른 요소에서 이벤트가 발생할 수 있으므로, 조건문 등으로 관리 필요)

   2. **이벤트 핸들러의 맥락**(this 바인딩이 부모요소를 기준으로 되어있다.)

### GraphQL

GraphQL은 API를 설계하고 쿼리하기 위한 쿼리 언어이자, 서버와 클라이언트 간의 데이터를 효율적으로 전송할 수 있도록 돕는 런타임 환경입니다.

1. **주요 특징**

   1. **선택적 데이터 요청**(클라이언트는 필요한 데이터 구조를 명시적으로 요청 가능)

   2. **단일 엔드포인트**

   3. **타입 시스템**(API의 데이터 구조를 명확하게 정의 가능)

   4. **실시간 데이터**(서브스크립션 기능 지원)

   5. **강력한 개발자 도구**(GraphQL에는 API 문서화를 위한 도구가 제공됨)

2. **Subscription**

   - **정의**:클라이언트가 특정 이벤트에 대해 실시간으로 데이터 업데이트를 받을 수 있도록 합니다.

   - **작동**:클라이언트가 서버에 구독을 요청하면, 서버는 해당 이벤트가 발생할 때마다 클라이언트에 데이터를 푸시(push)합니다.(옵저버 패턴과 유사)

   - **용도**: 채팅, 피드업데이트 등.

### 템플릿 엔진

동적인 웹 페이지를 생성하기 위해 HTML 파일 내에 JS 코드를 삽입하여 데이터를 출력하는 도구입니다.

1. **특징**

   1. **변수 삽입**

   2. **조건문 및 반복문 지원**

### 디자이너가 psd 파일 또는 jpg 파일만 주었을 때 구현 가능?(해당 이미지를 청사진으로서 활용하는 경우의 고려사항)

1. **구현 가능성**

   1. **PSD 파일**:

      1. PSD 파일은 레이어, 텍스트, 벡터 이미지 등을 포함할 수 있어 디자인 요소를 세밀하게 조정할 수 있습니다.

      2. **장점**: 각 요소를 개별적으로 추출하고 수정할 수 있으므로, UI 요소나 아이콘 등을 쉽게 사용할 수 있습니다.

      3. **단점**: 전용 소프트웨어 필요, 변환 작업 필요.

   2. **JPG 파일**:

      1. JPG 파일은 정적 이미지로, 주로 배경 이미지나 아이콘으로 사용.

      2. **장점**: 간단하게 사용할 수 있습니다.

      3. **단점**: JPG는 비트맵 이미지이기 때문에 확대하면 품질이 떨어지고, 세부조정이 불가능합니다.

2. **구현 절차**

   1. **디자인 분석**

   2. **HTML 구조 작성**

   3. **CSS 스타일링**

   4. **이미지 활용**

   5. **반응형 디자인**

   6. **테스트 및 디버깅**

## 백엔드

### 백엔드 프레임워크의 종류

백엔드 프레임워크는 서버 측 애플리케이션을 개발하는 데 도움을 주는 소프트웨어 프레임워크입니다.

1. **Express.js**

   - **정의**: Node.js 기반 프레임워크, 가볍고 유연하다.

   - **특징**: 미들웨어 사용, RESTful API 적합, 간단하고 직관적인 라우팅.

2. **Koa**

   - **정의**: Express보다 미들웨어 관리와 구조화가 쉽다.

   - **특징**: async/await 지원, 비동기 코드 작성 용이, 경량 구조.

3. **Nest.js**

   - **정의**: 유연하고 확장성이 좋은 프레임워크로 플러그인 시스템 사용.

   - **특징**: 모듈화된 아키텍처와 의존성 주입 가능, 대규모 애플리케이션 개발에 좋음.

4. **Hapi.js**

   - **정의**: 유연하고 확장성이 좋은 서버 프레임워크, 플러그인 시스템 사용.

   - **특징**: 안정성과 보안 기능, RESTful API 및 웹 애플리케이션 개발에 적합.

5. **Sails.js**

   - **정의**: express 기반 MVC 프레임워크.

   - **특징**: 실시간 웹 애플리케이션과 RESTful API 구축에 적합, 데이터베이스 ORM인 Waterline 사용.

6. **Fastify**

   - **정의**: 매우 빠르고 가벼운 서버 프레임워크, 고성능 애플리케이션 개발 적합.

   - **특징**: 플러그인 아키텍쳐 사용, JSON 기반의 요청과 응답 처리에 최적화.

### Waterline

- **_정의_**: Sail.js의 기본 ORM(Object-Relational Mapping)으로 다양한 데이터베이스와 상호작용할 수 있는 추상화된 레이어를 제공합니다.

- **특징**:

  - **다양한 데이터베이스 지원**: SQL 기반의 관계형 데이터 베이스와 NoSQL 데이터베이스 모두 지원합니다.

  - **간단한 쿼리 언어**

  - **모델 기반**: 데이터 모델을 정의, 데이터베이스와의 상호작용 단순화.

### 런타임

- **정의**: 프로그램이 실행되는 환경, 운영 체제, 메모리, 라이브러리 및 런타임 시스템을 포함합니다.

- **예시**: Java Virtual Machine (JVM)과 같은 특정 플랫폼에서 실행되는 애플리케이션이 있습니다.

### 프레임워크와 라이브러리 모듈

1. **프레임워크(Framework)**

   - **정의**: 특정한 아키텍처와 규칙을 제공하여 애플리케이션을 구조화하는 기본 뼈대.

   - **특징**: 개발자가 프레임워크에 맞춰 코드를 작성해야 하며, 제어의 흐름이 프레임워크에 있습니다.

2. **라이브러리 (Library)**

   - **정의**: 특정 기능이나 작업을 수행하기 위해 미리 작성된 코드 집합.

   - **특징**: 개발자가 호출하는 방식으로, 제어의 흐름이 개발자에게 있습니다.

3. **모듈(Module)**

   - **정의**: 특정 기능을 캡슐화하여 재사용 가능한 코드 단위.

   - **특징**: 서로 다른 모듈 간의 의존성을 관리 가능, 다른 모듈에서 쉽게 가져다 쓸 수 있습니다. ES6 모듈, CommonJS 모듈이 있습니다.

### Express

Express는 Node.js 환경에서 웹 애플리케이션 및 API를 구축하기 위한 간편하고 유용한 프레임워크입니다.

1. **주요 특징**

   1. **경량 및 유연성**(필요한 기능만 선택적으로 추가 가능)

   2. **미들웨어**(요청과 응답 객체 처리하는 함수)

   3. **라우팅**

   4. **템플릿 엔진 통합**(다양한 템플릿 엔진과 통합할 수 있음)

   5. **RESTful API 개발 적합**

   6. **활발한 커뮤니티와 큰 생태계**

## 아키텍처 및 프로그래밍 패러다임

### IoC(Inversion of Control)(제어의 역전)

객체 지향 프로그래밍에서 객체의 생성과 의존성 관리를 개바자가 아닌 프레임워크나 컨테이너가 담당하게 하는 설계 원칙입니다.

**주요 측징**

- **제어의 역전**: 객체가 자신의 의존성을 생성 및 관리하는게 아닌, IoC는 외부에서 이 과정을 담당합니다.

- **의존성 관리**: IoC는 의존성 주입과 밀접하게 관련되어, 객체가 필요로 하는 의존성을 외부에서 주입받도록 합니다.

- **유연성 및 확장성**: IoC를 사용하면 코드의 구조가 유연해지고, 변경이 용이해집니다.

### 프로토타입

**_유형_**

1. **소프트웨어 개발**(소프트웨어의 초기 버전이나 모형)

2. **프로토타입 패턴**(객체지향 프로그래밍에서, 기존 객체를 복사하여 새로운 객체를 생성하는 디자인 패턴입니다.)

3. **웹 개발**(웹 애플리케이션의 구조와 기능을 시각적으로 표현한 모델)

### 아키텍처

아키텍처(Architecture)는 특정 시스템이나 소프트웨어의 구조와 조직을 설명하는 개념.

1. **_시스템 구조_**

   1. **구성 요소**(시스템을 이루는 요소(모듈, 컴포넌트 등)들과 그 기능.)

   2. **관계**(구성 요소들 간의 상호작용 및 의존 관계)

2. **_설계 원칙_**

   1. **표준**: 시스템의 설계를 위한 가이드라인이나 규칙.

   2. **패턴**: 자주 사용되는 설계의 형태나 방법론.

3. **_기술 스택_**(프로그래밍 언어, 프레임워크, 데이터베이스, 서버 등)

4. **_성능 및 확장성_**

   1. **성능 고려사항**: 시스템이 얼마나 빠르고 효율적으로 작동하는지에 대한 기준.

   2. **확장성**

5. **_사용자 요구사항_**

   1. **기능적 요구사항**(사용자가 원하는 기능.)

   2. **비기능적 요구사항**(성능, 보안, 사용성 등 시스템의 품질 속성)

### AOP (Aspect-Oriented Programming)

1. **_AOP의 주요 개념_**

   1. **Aspect(관점)**: 공통적인 기능을 캡슐화한 모듈입니다.

   2. **Join Point (조인 포인트)**: 프로그램 실행 중에 Aspect가 적용될 수 있는 지점입니다.(메서드 호출, 객체 생성 등)

   3. **Advice (어드바이스)**: Aspect가 특정 조인 포인트에서 실행하는 코드입니다.

      - **Before**: 조인 포인트 이전에 실행됩니다.

      - **After**: 조인 포인트 이후에 실행됩니다.

      - **Around**: 조인 포인트 실행하기 전후에 실행됩니다.

   4. **Pointcut (포인트 컷)**: 어떤 Aspect가 어디에서 실행될지를 결정합니다.

2. **_AOP의 장점_**

   - **코드의 모듈화**

   - **재사용성**

   - **유연성**

3. **AOP의 사용 예**: 로깅, 보안, 트랜잭션 처리 등과 같은 공통 기능을 관리.

### 데코레이터 패턴이란

기존 객체를 수정하지 않고도 기능을 확장할 수 있게 해주며, 객체를 래핑(wrapping)하여 추가적인 기능을 부여합니다.

**주요 특징**

- **유연성**(기존 코드를 변경하지 않고 테코레이터 객체를 생성하여 기능 추가.)

- **확장성**(여러 데코레이터를 조합하여 객체의 기능을 다양하게 확장할 수 있음.)

- **Single Responsibility Principle**(각 데코레이터는 특정 기능을 담당하므로, 코드의 책임을 분리할 수 있음.)

### 의존성 주입 (Dependency Injection)

- **정의**: 객체 간의 의존성을 관리하는 디자인 패턴으로 객체가 의존성을 외부에서 주입받는 방식입니다.

- **특징**:

  - **유연성**(코드의 재사용성 향상, 결합도 약하게)

  - **테스트 용이성**

  - **자동 설정 관리**(객체 생성과 의존성 관리를 프레임워크가 처리)

### 의존성 주입과 데코레이터 패턴(자필)

- **데코레이터 패턴의 목적과 유용성**: 라이브러리나 프레임워크의 모듈을 활용하면서도, 기존의 코드의 변경이 적다는 점은 데코레이터 패턴의 유용성.

- **의존성 주입의 목적과 유용성**: 외부에서 주입받은 속성이나 객체이기에 주입받은 객체는 그 세부사항을 알 필요가 없고 그럼으로써 결합을 느슨하게 할 수 있다는 점에서 의존성 주입은 유용하다.

보통 두 목적이 동시에 달성되지만, 이 두 개를 헷갈리면 안된다.

### 싱글톤 패턴

싱글톤 패턴(Singleton Pattern)은 클래스의 인스턴스가 오직 하나만 생성되도록 보장하는 디자인 패턴입니다.

- **주요 특징**

  - **단일 인스턴스**(클래스의 인스턴스가 하나만 존재함)

  - **전역 접근**

  - **지연 초기화**(필요할 때까지 인스턴스를 생성하지 않고, 대체로 최초 요청 시 생성함)

### MVC 패턴

1. **_MVC 패턴의 구조_**

   1. **Model (모델)**: 애플리케이션의 데이터와 비즈니스 로직, 데이터 처리 및 상태 관리를 담당합니다. 데이터를 변경할 때, 이벤트를 발생시켜 컨트롤러에 알립니다.

   2. **View (뷰)**: 사용자에게 보여지는 인터페이스를 담당합니다. 사용자가 입력한 정보를 받아서 컨트롤러에 전달합니다. 뷰는 모델의 변화에 반응하여 갱신합니다.

   3. **Controller (컨트롤러)**: 사용자 입력을 처리하고, 모델과 뷰에 전달하는 역할을 합니다. 이를 통해 모델과 뷰는 직접적으로 상호작용 하지 않습니다.

2. **MVC 패턴의 장점**

   - **분리된 관심사\[책임\](concerns)**(각 구성 요소가 독립적.)

   - **재사용성**(하나의 모델을 여러 뷰에서 사용가능.)

   - **유연성**(각 요소가 독립적이므로, 유연하게 대응 가능)

### 클라이언트 서버 구조

- **_정의_**: 네트워크에서 클라이언트와 서버 간의 상호작용.

- **_주요 요소_**

  1.  **클라이언트**(요청을 보내거나 데이터를 받는 프로그램이나 장치)

  2.  **서버**(요청을 처리하고, 필요한 데이터를 제공하는 시스템.(웹서버))

- **작동 방식**: 클라이언트가 서버에 요청을 보내면, 서버는 해당 요청을 처리하고 응답을 클라이언트로 반환합니다.

### 클라이언트 서버 모델의 특징

1. **분리된 역할**

2. **네트워크 통신**

3. **확장성**(서버는 여러 클라이언트를 동시에 처리 가능, 필요에 따라 서버를 추가할 수도 있음)

4. **보안**(서버에서 데이터를 처리하기 때문에)

5. **데이터 저장**(중앙(db나 서버)에서 데이터 저장, 일관성과 무결성 유지)

### 플러그인 기반 아키텍처

주요 애플리케이션이 기본 기능을 제공, 추가 기능은 플러그인 형태로 외부에서 추가하거나 제거할 수 있는 구조입니다.

1. **_주요 특징_**

   1. **모듈화**(각 플러그인은 독립적으로 구현)

   2. **확장성**(기존 코드 수정 필요 X)

   3. **유연성**(플러그인을 빼거나 추가하기만 하면 됨)

   4. **독립성**(플러그인은 모듈화 되어있다.)

2. **사용 사례**

   - **웹 브라우저**

   - **IDE(통합 개발 환경)**

   - **CMS(콘텐츠 관리 시스템)**(많은 플러그인이 외부 개발자에 의해 개발되고 배포될 수 있다)

3. **장점**

   1. **유지 보수 용이성**(모듈화 되어있음)

   2. **기능 확장 용이**

   3. **커뮤니티 및 생태계**(외부 개발자에 의해 개발되고 배포 가능하여 생태계가 활성화된다)

4. **단점**

   1. **복잡성**(의존성 관리)

   2. **성능 문제**(지나친 플러그인 추가는 성능 저하)

   3. **보안 위험**(외부 플러그인의 악성코드 위험)

### 마이크로 서비스 아키텍처(MSA)

MSA(microservices Architecture)는 소프트웨어 개발 패러다임으로, 애플리케이션을 여러 개의 작은 독립적인 서비스로 구성하는 방식입니다.

1. **_MSA의 주요 특징_**

   1. **독립성**(서로에게 영향을 미치지 않음)

   2. **기능 중심**(기능이나 도메인에 초점을 맞춤)

   3. **다양한 기술 스택**(각 마이크로서비스는 필요한 기술 스택을 자유롭게 선택가능)

   4. **API 기반 통신**(응답의 추상화 덕분에 결합도가 느슨하다)

   5. **자동화 및 오케스트레이션**(배포와 관리를 자동화하기 위한 도구와 기술)

2. **_MSA의 장점_**

   1. **유연성**(서버의 독립적인 배포와 확장 덕.)

   2. **팀 분산**

   3. **스케일링**(부하가 쏠린 서비스만 확장하면 됨)

   4. **신뢰성**(하나의 서비스 장애 발생시 전체 시스템이 다운되지 않음)

3. **MSA의 단점**

   1. **복잡성 증가**(여러 개의 서비스 관리와 모니터링)

   2. **운영 비용**(여러 개의 서비스 관리와 모니터링)

   3. **데이터 관리**(여러 개의 서비스에서의 db 관리)

### 마이크로 서비스와 모놀리틱 서비스

- **모놀리틱 서비스**

  1.  **정의**: 모놀리틱 서비스는 모든 기능이 단일 애플리케이션으로 통합되어 있는 구조입니다.

  2.  **특징**

      1. **단일 코드베이스**(모든 기능이 하나의 코드베이스에 포함)

      2. **일관성**(모든 모듈이 동일한 기술 스택을 가지며, 데이터베이스의 스키마를 공유하므로 작업 후에도 일관성이 유지된다.)

      3. **간단한 배포**(하나의 코드베이스, 한 번에 배포 가능)

      4. **상태 관리**(상태 공유가 용이)

  3.  **장점**

      1. **단순함**

      2. **성능 좋음**

      3. **유지보수 쉬움**

  4.  **단점**

      1. **스케일링 문제**(부분 확장 불가)

      2. **배포의 위험성 증가**(배포시간이 길어지고, 실패시 영향이 크며 확장과 수정이 어렵다)

      3. **기술 스택 제한**(모든 기능이 동일한 언어와 프레임워크를 써야함)

  - **마이크로서비스**

    1. **정의**: 애플리케이션을 여러 개의 독립적인 서비스로 나누어 개발하는 구조입니다.

    2. **특징**

       1. **독립적인 서비스**

       2. **자율성**(서비스 간의 의존성이 낮음)

       3. **API 기반 통신**(서비스 간의 통신은 API를 통함(추상화))

       4. **분산된 데이터 관리**(각 모듈은 데이터베이스 독립적으로 보유가능)

    3. **장점**

       1. **유연성**(각 서비스가 독립적)

       2. **확장성**(각 서비스가 독립적)

       3. **신속한 배포**(분산된 비즈니스 로직 덕에 개개의 모듈의 무게가 상대적으로 가볍다)

       4. **장애 격려**(한 서비스에서 오류가 나도 전체 시스템이 다운되지 않는다)

    4. **단점**

       1. **복잡성**(여러 서비스 간의 통신과 관리)

       2. **배포 및 운영 어려움**(서비스 수가 많아질수록)

       3. **데이터 일관성 문제**(서비스가 독립적으로 데이터베이스를 관리하므로)

### 이벤트 기반 아키텍처

이벤트 기반 아키텍처(Event-Driven Architecture, EDA)는 이벤트를 통해 시스템의 구성 요소들이 상호작용하는 구조입니다.

비동기적이고 느슨한 결합을 가집니다.

1. **_주요 구성 요소_**

   1. **이벤트**: 특정 상황이나 상태 변화가 발생했을 때 생성되는 메시지입니다.

   2. **이벤트 발행자**: 이벤트를 생성하는 주제로, 특정 행동이나 상태 변화가 발생했을 때 이벤트를 발행합니다.

   3. **이벤트 수신자(리스너)**: 특정 이벤트를 감지하고 이에 반응하는 구성 요소입니다. 수신자는 이벤트에 지정된 작업을 한다.

   4. **이벤트 버스**: 이벤트 발행자와 수신자 간의 통신을 중재하는 역할을 합니다.(수신자와 발행자의 상호작용을 위한 통로)

2. **_특징_**

   1. **비동기 처리**(필요할 때만 사용)

   2. **느슨한 결합**(구성 요소들이 독립적)

   3. **실시간 반응**(즉시 반응)

3. **_활용 사례_**

   1. **마이크로서비스 아키텍처**

   2. **IoT 시스템**

   3. **웹 애플리케이션**

### 병렬 프로그래밍

병렬 프로그래밍(Parallel Programming)은 여러 개의 프로세서나 코어에서 동시에 여러 작업을 수행하도록 프로그램을 설계하는 방법입니다.

1. **_병렬 프로그래밍의 주요 개념_**

   1. **동시성 vs 병렬성**

      1. **동시성(Concurrency)**: 여러 작업이 동시에 실행되는 것**처럼** 보이는 상태.

      2. **병렬성(Parallelism)**: **실제로** 여러 프로세서 또는 코어가 동시에 작업을 수행하는 것.

   2. **작업 분할**: 큰 작업을 여러 개의 작은 서브 작업으로 나누어 독립적으로 수행합니다.

   3. **동기화(Synchronization)**: 여러 프로세스가 공유 자원에 접근할 때, 데이터 일관성을 유지하기 위해 동기화 기법이 필요.(뮤텍스, 세마포어, 조건 변수)

   4. **로드 밸런싱(Load Balancing)**: 모든 프로세서에 작업을 균등하게 분배한다.

2. **병렬 프로그래밍의 장점**

   1. **성능 향상**

   2. **효율적인 리소스 사용**

   3. **대규모 데이터 처리**

3. **병렬 프로그래밍의 단점**

   1. **복잡성**(동기화 및 데이터 경쟁 문제)

   2. **디버깅 어려움**(여러 스레드와 프로세스가 동시에 실행되기 때문에)

   3. **오버헤드**(작업 분할과 통신의 오버헤드)

### 세마포어와 뮤텍스, 조건 변수

세마포어(Semaphore)와 뮤텍스(Mutex)는 동기화 메커니즘으로 여러 스레드나 프로세스가 공유 자원에 안전하게 접근할 수 있도록 도와줍니다.

- **_뮤텍스 (Mutex)_**

  1.  **정의**: 뮤텍스는 "Mutual Exclusion"의 줄임말로 오직 하나의 스레드만 공유 자원에 접근할 수 있도록 보장하는 동기화 객체입니다.

  2.  **특징**

      - **상호배제**(오직 하나의 스레드만)

      - **소유권**(뮤텍스를 소유한 스레드만이 해제 가능)

      - **간단한 사용**(단일 스레드 접근제한이므로)

  3.  **사용 예**: 데이터베이스 연결, 파일 접근 등

- **_세마포어 (Semaphore)_**

  1.  **정의**: 세마포어는 특정 자원에 접근할 수 있는 스레드 수를 제한하는 동기화 객체입니다. 초기값으로 설정된 카운터를 가지고 있으며, 이 카운터를 기반으로 자원 접근을 관리합니다.

  2.  **특징**

      1. **카운팅**

         1. **이진 세마포어(Binary Semaphore)** (0 또는 1의 값만 가질 수 있으며, 뮤텍스처럼 동작.)

         2. **카운팅 세마포어(Counting Semaphore)**(0 이상의 정수를 가질 수 있으며, 여러 스레드가 동시에 자원에 접근할 수 있도록 허용)

      2. **소유권 없음**(세마포어는 특정 스레드가 소유하지 않으며, 어떤 스레드든지 세마포어의 값을 감소시킬 수 있습니다.)

- **조건 변수(Condition Variable)**

  특정 조건이 충족될 때까지 스레드를 대기 상태로 전환하고, 조건이 충족되면 대기 중인 스레드를 깨워주는 기능을 제공합니다.

  1.  **_주요 개념_**

      1. **대기와 신호**

         1. **대기**: 특정 조건 발생 전까지의 상태.

         2. **신호**: 특정 조건 발생시, 다른 스레드가 조건 변수를 통해 대기 중인 스레드를 깨우는 현상.

      2. **뮤텍스와 함께 사용**:

         - 조건 변수는 반드시 뮤텍스와 함께 사용해야 합니다. 뮤텍스를 통해 공유 자원에 대한 접근을 안전하게 관리하면서, 조건 변수는 조건이 충족될 때까지 스레드를 대기 상태로 전환합니다.

         - 스레드가 조건 변수를 대기할 때, 먼저 뮤텍스를 잠그고, 대기 상태로 들어간 후 뮤텍스를 해제합니다. 신호가 발생하면 대기 중인 스레드는 뮤텍스를 다시 획득하고, 조건을 확인한 후 작업을 계속합니다.

  2.  **사용 예**: 조건 변수는 생산자-소비자 같은 문제에서 많이 사용됩니다.(저장공간이 가득차는 등, 조건에 따라 **대기**가 필요.)

  3.  **결론**

      1. 뮤텍스는 단일 스레드만 공유 자원에 접근가능.(소유권 존재)

      2. 세마포어는 여러 스레드가 자원에 접근가능. 카운터 기반.(소유권 X)

      3. 조건 변수는 스레드 간의 복잡한 상호작용을 위한 도구.(대기, 신호, 뮤텍스와 함께 사용)

### 데이터 경쟁

멀티스레드 환경에서 발생할 수 있는 문제로 두 개 이상의 스레드가 동시에 같은 데이터를 읽거나 쓰려고 할 때 발생.

1. **_데이터 경쟁의 주요 특징_**

   1. **동시 접근**

   2. **최소 한 스레드가 쓰기**(그래야 한쪽이 읽기 작업을 하는 경우, 데이터 경쟁이 발생.)

   3. **결과 불확실성**(스레드 실행 순서에 따라 결과가 달라짐)

2. **_데이터 경쟁의 해결 방법_**

   1. **뮤텍스 사용**

   2. **조건 변수 사용**

   3. **스레드 안전한(Thread-safe) 자료구조 사용**

   4. **원자적 연산**(원자적 연산(Atomic Operations)을 사용, 연산이 중단되지 않고 실행되거나 실행되지 않는다.)

### Hydration(번외)

초기 HTML 콘텐츠를 클라이언트 측 JS 애플리케이션과 연결하는 과정을 의미합니다.

1. **_Hydration의 작동방식_**

   1. **서버 측 렌더링(SSR)**: 서버는 사용자 요청에 대한 HTML 콘텐츠를 미리 렌더링하여 클라이언트에 전달합니다.(페이지의 초기 상태)

   2. **클라이언트 측 JavaScript 초기화**: 클라이언트 측에서 JS가 로드되면, 서버에서 렌더링된 HTML을 기반으로 애플리케이션의 상태를 초기화합니다.

   3. **상태 동기화**: 클라이언트에서 JS가 실행되면서 서버에서 전달된 HTML과 클라이언트 애플리케이션의 상태가 동기화됩니다.

2. **_Hydration의 장점_**

   1. **빠른 초기 로딩**(서버에서 미리 렌더링된 HTML(SSR의 장점))

   2. **향상된 사용자 경험**(사용자는 초기 HTML을 볼 수 있음(SSR의 장점))

   3. **상태 유지**(페이지의 상태나 UI의 상태)

3. **Hydration의 단점**

   1. **리소스 소모**:(클라이언트에서 추가 처리 필요함)

   2. **복잡성**(SSR과 Hydration, 두 개를 관리할 필요가 있음, 설정과 유지보수 복잡해짐)

### 동시성 모델

여러 작업이나 프로세스가 동시에 실행될 수 있도록 하는 프로그램이나 시스템의 설계 방식입니다.

1. **스레드와 프로세스**(여러 스레드 또는 프로세스가 동시에 작업)

2. **동기화(Synchronization)**: 여러 스레드가 공유 자원에 접근할 때 충돌 방지를 위한 메커니즘.

3. **비동기 프로그래밍**

4. **이벤트 기반 모델**

5. **병렬 처리**(멀티코어 프로세서)

### 함수형 프로그래밍

프로그래밍 패러다임의 하나로, 수학적 함수 개념을 바탕으로 하여 프로그램을 구성하는 방식.

1. **1급 함수(First-class Function)**: 함수는 다른 함수의 인자로 전달되거나, 반환값으로 사용될 수 있으며, 변수에 할당될 수 있는 객체로 취급됩니다.

2. **순수 함수(Pure Functions)**: 순수 함수는 같은 입력에 대해 항상 같은 출력을 반환하며, 외부 상태나 변수를 변경하지 않습니다.

3. **불변성(Immutaility)**: 함수형 프로그래밍에서는 데이터가 생성되면 변경되지 않는 불변성을 선호합니다. (데이터 추적이 쉬움, 부작용 감소)

4. **고차 함수(Higher-Order Functions)**: 함수를 인자로 받거나 함수를 반환하는 함수를 의미합니다.

5. **함수 조합(Function Composition)**: 여러 함수를 조합하여 새로운 함수를 만드는 방식입니다.

6. **지연 평가(lazy Evaluation)**: 필요할 때까지 계산을 미루는 방식. (메모리 사용 최적화와 성능 향상)

7. **재귀(Recursion)**: 반복문 대신 함수가 자기 자신을 호출하는 방식을 사용하여 반복적인 작업을 처리합니다.

8. **상태 변화의 최소화**: **상태 변화**(데이터나 객체, 상태 등이 시간이 지나면서 변화하는 과정)를 최소화하여 코드의 복잡성을 줄이고, 프로그램의 유지보수성을 높입니다.

9. **예외 처리**: 고유한 패턴을 사용하며, 일반적으로 함수형 프로그래밍의 원칙을 따릅니다.

10. **언어 예시**: Haskell, Lisp, Scala, F#, Clojure, JS, Python(일부) 등이 있고, JS와 Python은 함수형 프로그래밍 스타일 지원하는 기능 포함.

### 순수 함수

1. **_특징_**

   1. **항상 같은 입력, 같은 출력**

   2. **부작용이 없음**(외부 상태나 변수를 변경 X)

2. **_순수 함수의 장점_**

   1. **예측 가능성**(같은 입력, 같은 출력)

   2. **테스트 용이성**(부작용이 없으므로)

   3. **병렬 처리 가능성**(외부 상태 의존 없음)

   4. **코드 재사용성**(외부 상태 의존 없음)

### OOP 특징과 원칙

객체 지향 프로그래밍(Object-Oriented Programming, OOP)은 데이터와 그 데이터에 관련된 행동을 하나의 단위로 묶어 관리하는 방식.

1. **_OOP의 주요 특징_**

   1. **캡슐화(Encapsulation)**

      - **설명**: 객체는 데이터(상태)와 메서드(동작)를 하나의 단위로 묶어 외부로부터 보호합니다.

      - **장점**: 데이터 무결성을 유지, 객체 내부 구현 변경 시 외부에 미치는 영향 최소화.

   2. **상속(Inheritance)**

      - **설명**: 새로운 클래스가 기존 클래스의 속성과 메서드를 물려받아 사용할 수 있게 하는 기능입니다.

      - **장점**: 공통 기능을 가진 클래스 간의 관계를 명확히 하고, 유지보수를 용이하게 합니다.

   3. **다형성(Polymorphism)**

      - **설명**: 동일한 인터페이스를 사용하여 여러 형태의 객체를 처리할 수 있게 해주는 기능.(오버로딩, 오버라이딩)

      - **장점**: 코드의 유연성을 높이고, 다양한 객체를 동일한 방식으로 처리할 수 있습니다.

   4. **추상화 (Abstraction)**

      - **설명**: 세부 사항을 숨기고, 필요한 정보만을 노출하는 과정입니다.

      - **장점**: 시스템을 단순하게 이해할 수 있게 하고, 복잡성을 줄입니다.

2. **OOP의 원칙**

   1. **DRY (Don't Repeat Yourself)**: 중복 코드를 피하고, 코드를 재사용할 수 있도록 설계하는 원칙.

   2. **KISS (Keep It Simple, Stupid)**: 시스템을 가능한 한 단순하게 유지해야 한다는 원칙.

   3. **YAGNI (You Aren't Gonna Need It)**: 현재 필요하지 않은 기능은 미리 구현하지 말라는 원칙입니다.

   4. **SOLID 원칙**

      - **S**: Single Responsibility Principle(SRP), 하나의 클래스는 하나의 책임만 가져야 한다.

      - **O**: Open/Close Principle (OCP) - 클래스는 확장에는 열려 있어야 하고, 수정에는 닫혀 있어야 합니다.

      - **L**: Liskov Subsititution Principle (LSP) - 자식 클래스는 부모 클래스를 대체할 수 있어야 합니다.

      - **I**: Interface Segregation Principle (ISP) - 자신이 이용하지 않는 메서드에 의존하지 않아야 합니다.

      - **D**: Dependency Inversion Principle (DIP) - 상위 모듈이 하위 모듈에 의존해서는 안되며, 추상화에 의존해야 한다. 추상화는 세부사항에 의존하면 안된다.

### OOP와 함수형 프로그래밍의 차이점

1. **_기본 개념_**

   1. **OOP**: 데이터와 메서드를 하나의 객체로 묶어 모듈화하는 방식입니다.

   2. **함수형 프로그래밍**: 함수를 기본 단위로 하여 프로그램을 구성하는 방식입니다.

2. **상태 관리**

   1. **OOP**: 객체의 상태를 변경한다.(메소드 호출로 데이터 수정)

   2. **함수형 프로그래밍**:변경하지 않으며, 필요하면 새로운 값을 생성.(불변성)

3. **데이터와 행동**:

   1. **OOP**: 데이터와 행동(메소드)을 함께 묶는다.

   2. **함수형 프로그래밍**: 데이터와 행동을 분리한다.

4. **부작용**

   1. **OOP**: 객체의 상태 변경으로인한 부작용 발생.

   2. **함수형 프로그래밍**: 순수 함수를 통한 부작용의 최소화.

5. **코드 구조**

   1. **OOP**: 클래스와 객체를 중심으로 코드 구조 설계.

   2. **함수형 프로그래밍**: 함수 호출을 통한 데이터 흐름 관리.

6. **예시 언어**

   1. **OOP 언어**:: Java, C++, C#, Python, Scala, Clojure, F#, Elixir, JavaScript(일부) 등.

   2. **함수형 프로그래밍 언어**: Haskell, Scala, Closure, F#, Elixir, JavaScript(일부) 등.

## db

### db의 종류

1. **_관계형 데이터베이스 (RDBMS)_**

   - **정의**: 데이터가 테이블 형식으로 저장되고, 테이블 간의 관계를 통해 데이터를 관리합니다.

   - **예시**: MySQL, Oracle, PostgreSQL, Microsoft SQL Server.

   - **특징**: SQL(Structured Query Language)을 사용하여 데이터 쿼리 및 조작을 수행.(무결성과 트랜잭션 처리 지원)

2. **_비관계형 데이터베이스(NoSQL)_**

   - **정의**: 관계형이 아닌 데이터베이스.

   - **예시**: MongoDB, Cassandra, Redis, Couchbase

   - **특징**: 스키마가 없거나 유연하고 데이터 구조가 다양합니다.(무거운 작업에 유리)

3. **_객체지향 데이터베이스 (OODBMS)_**

   - **정의**: 객체 지향 프로그래밍 언어와 통합하여 데이터를 객체에 저장하는 데이터베이스.

   - **예시**: db4o, ObjectDB.

   - **특징**: 객체와 클래스 개념을 사용하여 복잡한 데이터 모델을 표현할 수 있습니다.

4. **_그래프 데이터베이스_**

   - **정의**: 노드, 엣지, 속성으로 구성된 그래프 구조로 데이터를 저장하는 데이터베이스입니다.

   - **에시**: Neo4j, Amazon Neptune

   - **특징**: 복잡한 관계 데이터를 효과적으로 관리합니다.(소셜 네트워크, 추천 시스템 등에 적합)

5. **문서 지향 데이터베이스**

   - **정의**: JSON, XML 등의 문서 형식으로 데이터를 저장하는 데이터베이스입니다.

   - **예시**: MongoDB, CouchDB

   - **특징**: 유연한 데이터 구조를 제공하며, 복잡한 쿼리를 지원합니다.

### db 관계형 비관계형 차이

데이터 저장 및 관리 방식.

1. **_관계형 데이터베이스 (RDBMS)_**

   - **구조화된 데이터**(테이블 형식(행과 열)으로 구성, 명확한 스키마(데이터 구조))

   - **SQL 사용**

   - **관계**(테이블 간에 관계를 설정할 수 있으며, 이를 통해 데이터의 무결성을 유지)

   - **ACID 특성**: 원자성(Atomicity), 일관성(Consistency), 고립성(Isolation), 내구성(Durability)을 지원.

     - **ACID**

       1. **원자성**: 모든 작업이 완료되거나 수행되지 않아야 합니다.

       2. **일관성**: 작업 후에도 스키마(데이터 구조)가 유지되어야 합니다.

       3. **고립성**: 하나의 트랜잭션이 다른 트랜잭션에 영향을 미치지 않도록 보장합니다.

       4. **내구성**: 트랜잭션이 완료된 후, 그 결과는 시스템 장애가 발생하더라도 영구적으로 저장되어야 합니다.

   - **예시**: MySQL, Oracle, PostgreSQL, Microsoft SQL Server.

2. **_비관계형 데이터베이스 (NoSQL)_**

   - **비구조화된 데이터**: 데이터가 테이블 형식이 아닌 다양한 형식으로 저장될 수 있습니다.(스키마가 유연)

   - **쿼리 언어**: SQL 대신 각 데이터베이스에 맞는 API 또는 쿼리 언어를 사용합니다.

   - **수평 확장성**: 데이터베이스를 여러 서버에 분산하여 저장할 수 있어 대량 데이터를 쉽게 처리할 수 있습니다.

   - **CAP 이론**: 일관성(Consistency), 가용성(Availability), 파티션 허용성(Partition Tolerance) 중 두 가지를 동시에 만족하기 어려운 상황을 설명합니다.

   - **CAP이론**

     - **일관성**: 모든 노드가 동일한 데이터를 유지하는 것을 의미합니다.(노드들의 지속적 업데이트)

     - **가용성**: 모든 요청에 대해 응답을 보장하는 것입니다.(시스템 작동하면 항상 응답을 받을 수 있게 보장)

     - **파티션 허용성**: 네트워크 파티션(서버들 간의 통신이 끊어지거나 일부 서버들끼리만 통신할 수 있는 상태)이 발생하더라도 정상적으로 작동할 수 있는 능력.

   - **예시**: MongoDb(문서 기반), Redis(키-값 저장소), Cassandra(열 기반), Neo4j(그래프 데이터베이스).

### ORM(Object-Relational Mapping)

객체 지향 프로그래밍 언어와 관계형 데이터베이스 간의 데이터 변환을 자동으로 처리해주는 기술입니다.

SQL 쿼리를 직접 작성하지 않고도 상호작용 가능.

- **_주요 특징_**

  1.  **추상화**(데이터베이스 접근을 추상화)

  2.  **생산성 향상**(데이터베이스와의 상호작용을 쉽게 함)

  3.  **유지보수 용이**(객체 모델과 데이터베이스 모델 사이의 변환 작업 불필요)

### 인덱스

인덱스(index)는 데이터베이스에서 데이터 검색을 빠르게 하기 위해 사용되는 데이터 구조입니다.

인덱스는 특정 필드에 대한 값들을 미리 정렬하고 저장한다.

- **_주요 특징_**

  1.  **검색 성능 향상**

  2.  **다양한 유형**(B-tree, 해시 인덱스 등)

  3.  **저장 공간 소모**:(추가적인 저장 공간이 필요, 데이터 수정(삽입, 삭제, 업데이트) 시 인데스도 수정 필요)

### 트랜잭션

트랜잭션은 데이터베이스에서 하나의 논리적 작업 단위를 의미합니다.

- **주요 특징**

  1. **원자성**(작업이 성공적으로 완료되거나 실패)

  2. **일관성**(작업 전후 데이터 스키마 유지)

  3. **격리성**(서로에게 영향을 미치지 않음)

  4. **지속성**(트랜잭션 성공시 결과가 영구적으로 저장됨)

## **_JS_**

## nodeJS

### Node.js

서버 측에서 JavaScript를 실행할 수 있도록 해주는 오픈 소스 런타임 환경입니다. Google의 V8 엔진 기반.

1. **주요 특징**

   1. **비동기 I/O**

   2. **이벤트 기반**(이벤트 루프를 사용하여 비동기 작업을 처리.)

   3. **단일 스레드**(비동기 I/O로 단일 스레드의 한계를 넘음)

   4. **NPM (Node Package Manager)**(풍부한 생태계 보유)

   5. **크로스 플랫폼**(Node.js는 다양한 운영체제 실행 가능)

2. **주요 사용 사례**

   1. **웹 서버**

   2. **실시간 애플리케이션**

   3. **데이터 스트리밍**

   4. **프론트엔드와 백엔드 통합**

3. **장점**

   1. **고성능**(비동기 I/O와 이벤트 기반 아키텍처 덕분에 동시 연결들 처리가능)

   2. **빠른 개발 속도**(다양한 라이브러리로 개발 시간 단축가능)

   3. **JavaScript**(프론트엔드와 동일한 언어)

4. **단점**

   1. **콜백 헬**(ES6 이후 해결)

   2. **CPU 집약적인 작업**(단일 스레드의 한계)

### Node.js는 단일 스레드?(개인적 해석, 인터넷 서치)

libuv 라이브러리를 통해 다중스레드로 비동기 I/O가 가능하지만, 이벤트 루프 자체는 단일 스레드.

### 스레드풀

여러 개의 스레드를 미리 생성해두고, 작업이 들어올 때마다 이 스레드를 재사용하여 처리하는 메커니즘.

1. **성능 향상**(스레드를 매번 생성할 필요가 없음)

2. **자원 관리**

3. **비동기 처리 유리**

### CPU 집약적인 작업

중앙 처리 장치(CPU)의 처리 능력에 의해 성능이 결정되는 작업을 말합니다.

1. **_주요 특징_**

   1. **높은 CPU 사용률**(CPU 자원을 많이 요구하므로 CPU 사용률이 높아짐.)

   2. **짧은 I/O 대기 시간**(대부분을 CPU 계산에 소모)

   3. **계산 집중형**(복잡한 알고리즘이 필요한 작업들)

2. **_예시_**

   1. **수치 계산**

   2. **비디오 처리**

   3. **머신 러닝**

   4. **이미지 처리**

3. **성능 최적화**

   1. **다중 스레딩**(병렬 처리)

   2. **최적화된 알고리즘**

   3. **하드웨어 업그레이드**

### Node.js 이벤트 큐 동작 원리

여러 비동기 작업이 완료되었을 때 이를 처리하는 메커니즘입니다.

- **Node.js 이벤트 큐의 동작 원리**

  1.  **이벤트 루프(Event Loop)**(반복적으로 실행, 실행할 작업 확인 처리)

  2.  **콜백 큐(Callback Queue)**(비동기 작업이 완료되면 해당 작업에 등록된 콜백 함수가 콜백 큐에 추가. 이벤트 루프가 처리할 준비가 된 콜백 함수 처리.)

  3.  **태스크 큐(Task Queue)**(setTimeout, setInterval과 같은 타이머와 같은 작업 포함. 지연된 후 실행)

  4.  **마이크로태스크 큐(Microtask Queue)**(프로미스의 then, catch, finally와 같은 메서드에 의해 추가되는 마이크로태스크 저장.)

  5.  **이벤트 루프의 작동**

      1. **콜 스택(Call Stack)**(현재 실행중인 코드 확인)

      2. **콜백 큐 확인**(콜 스택이 비어있으면 콜백 함수들 실행)

      3. **마이크로태스크 큐 확인**(마이크로태스크 확인 및 실행)

      4. **태스크 큐 확인**(태스크 큐에서 대기중인 작업 처리)

      5. **이 과정을 반복**

### 이벤트 루프

비동기 처리를 관리하는 메커니즘으로, 단일 스레드에서 비동기 작업을 효율적으로 수행하는 데 도움을 줍니다.

1. **비동기 작업 처리**

2. **콜 스택(Call Stack)**: 함수 호출이 이루어질 때마다 스택이 추가, 실행 완료시 스택에서 제거. (동기 실행)

3. **태스크 큐 (Task Queue)**: 비동기 작업이 완료되면 큐에 추가. 콜 스택이 비어있으면 태스크 큐 실행.

4. **이벤트 루프 작동 원리**

   1. 콜 스택에 현재 실행중인 작업이 끝나면, 이벤트 루프는 태스크 큐 확인.

   2. 큐의 작업들을 콜 스택에 추가 및 실행.

   3. 과정 반복, 비동기 작업 완료시 다음 작업 실행.

### Node.js의 모듈 종류는?

1. **내장 모듈 (Built-in Modules)**

   설치 없이 사용 가능.

   - **fs**(파일 시스템과 상호작용)

   - **http**(HTTP 서버와 클라이언트 생성 및 관리)

   - **path**(파일 및 디렉토리 경로 처리)

   - **os**(운영체제, CPU, 메모리, 네트워크 등 정보제공)

   - **event**(이벤트 기반 프로그래밍 지원. 이벤트 생성 및 리스닝)

   - **crypto**(암호화 및 해시 함수 제공)

2. **사용자 정의 모듈 (User-defined Modules)**

   개발자가 직접 작성한 모듈.

3. **외부 모듈 (External Modules)**

   NPM을 통해 설치할 수 있는 모듈.

   - **express**(웹 애플리케이션 프레임워크, HTTP 서버와 RESTful API 작성 용이)

   - **mongoose**(MongoDB와 상호작용하기 위한 ODM(Object Data Modeling)(객체(Object)와 데이터베이스 간의 상호작용을 쉽게 만들어주는 라이브러리))

   - **axio**(HTTP 요청을 간편하게 처리할 수 있는 Promise 기반의 클라이언트)

   - **lodash**(자바스크립트 유틸리티 라이브러리)

4. **ES 모듈 (ES Modules)**

   ES6(ECMAScript 2015)에서 도입된 모듈 시스템인 ES 모듈을 지원.

   ES 모듈은 import와 export 키워드를 사요하여 모듈을 정의하고 사용 가능.

### Node.js 백엔드에서 선호되는 이유

1. **비동기 I/O 및 이벤트 기반 아키텍처**

2. **단일 스레드 모델**(컨텍스트 전환의 오버헤드가 적다)

3. **JS 사용**(프론트와 백이 같은 언어 사용)

4. **NPM (Node Package Manager)**(라이브러리를 쉽게 관리할 수 있도록 돕는 도구)

5. **활발한 커뮤니티와 거대한 생태계**

6. **마이크로서비스 아키텍처에 적합**(경량의 구조와 빠른 응답 속도, 작은 서비스 단위로 기능을 나누고 배포가능)

7. **실시간 애플리케이션에 강점**(WebSocket을 통한 실시간 양방향 통신을 쉽게 구현가능)

8. **빠른 개발 속도**

### Node.js의 장단점

1. **_장점_**

   1. **비동기 및 이벤트 기반**(높은 동시성)

   2. **단일 언어 사용**

   3. **빠른 성능**

   4. **강력한 패키지 생태계**

   5. **마이크로서비스 아키텍처에 적합**(경량화된 구조로 쉽게 구현)

   6. **실시간 애플리케이션 지원**(WebSocket 프로토콜 이용에 적합한 구조)

2. **단점**

   1. **콜백 헬**(ES6 이후 해결)

   2. **CPU 집약적인 작업에 약함**(단일 스레드)

   3. **비동기 처리의 복잡성**

   4. **성숙도 문제**(비교적 새로운 기술)

   5. **기본적으로 제공되지 않는 기능**(특정 기능을 위해 외부 라이브러리나 추가적인 설정 필요)

### npm

package.json은 Node.js 프로젝트의 메타데이터를 포함하는 파일, 프로젝트의 설정, 의존성, 스크립트 등을 관리.

1. **주요 구성 요소**

   - **name**: 프로젝트의 이름.

   - **version**: 프로젝트의 버전, 주로 semver(Semantic Versioning) 형식.

   - **description**: 간단한 설명.

   - **main**: 앱의 진입점 파일.

   - **scripts**: 자주 쓰는 명령어 정의.

   - **dependencies**: 실행시 필요한 패키지들.

   - **devDependencies**: 개발 과정에만 필요한 패키지들.

   - **keywords**: 프로젝트와 관련된 키워드 목록, npm 레지스트리에서 검색할 때 유용.

   - **author**: 작성자 이름.

   - **license**: 프로젝트의 라이선스 정보.

### SemVer

Semantic Versioning, 소프트웨어의 버전 번호를 체계적으로 관리하기 위한 규칙.

```
MAJOR.MINOR.PATCH
```

1. **_구성_**

   1. **MAJOR(주 버전)**(주요 변경사항, 하위 호환성을 깨트릴때 변경)

   2. **MINOR(부 버전)**(새로운 기능추가, 하위 호환성 유지)

   3. **PATCH(수정 버전)**(버그 수정이나 사소한 변경사항)

2. **_장점_**

   1. **명확한 의미 전달**

   2. **호환성 관리**

   3. **자동화**(CI/CD 파이프라인에서 버전관리 자동화에 유용)

3. **_사용 사례_**

   오픈 소스 프로젝트, 라이브러리, API 등 다양한 소프트웨어 개발에서 널리 사용.

### npm install

1. **package.json 확인**: 명령 실행시, 의존성 목록 확인.

2. **의존성 다운**

3. **package-lock.json 생성/업데이트**: npm install 실행시 package-lock.json 파일 생성 혹은 업데이트. 해당 파일은 패키지의 정확한 버전 및 의존성 트리 기록한다.

4. **노드 모듈 설치**: node_modules 디렉토리에 설치.

5. **스크립트 실행 (선택 사항)**: pacakge.json의 scripts 섹션에 정의된 postinstall 스크립트가 있는 경우, 설치 완료후 자동으로 실행.

6. **캐시 사용**: 의존성 다운시 로컬 캐시로 이미 다운로드된 패키지 재사용.

### dependence와 devDependence 차이

1. **_dependencies_**

   1. **용도**: 실행시 필요한 패키지.

   2. **설치 방법**: npm install \<package>.

   3. **예시**: Express.js, React, Axios 등.

2. **_devDependencies_**

   1. **용도**: 개발시 필요한 패키지.

   2. **설치 방법**: npm install \<package> --save-dev.

   3. **예시**: Jest, ESLint, Webpack 등과 같이 개발 도구나 테스트 프레임워크.

### Node.js가 싱글 스레드지만 병렬작업이 가능한 이유

1. **이벤트 루프**: 비동기적으로 관리.

2. **비동기 I/O**: Node.js는 비동기 I/O를 사용, 동시 작업 가능.

3. **libuv**: 내부 라이브러리, I/O 작업용 스레드풀 사용, CPU 집약적인 작업은 별도의 스레드 실행.(멀티 스레딩)

4. **클러스터링**: Node.js는 클러스터 모듈을 통해 여러 프로세스 생성.(멀티 프로세스)

### 클러스터링

- **정의**: Node.js 애플리케이션을 여러 프로세스로 나누어 실행하는 기법.(다중 CPU 활용가능)

- **작동 방식**: 클러스터 모듈을 사용하여 마스터 프로세스가 여러 워커 프로세스를 생성하고, 각 워커가 요청을 처리합니다. 요청은 마스터 프로세스를 통해 분산.

- **장점**: 확장성과 성능 증가, 안정성이 높음.

## ES6의 추가요소들 및 문제해결 방안

### var, let, const

1. **_var_**

   - **스코프**: 함수 스코프(function scope)를 가집니다. 함수 내에서만 유효.

   - **호이스팅**: 변수 선언이 해당 스코프의 최상단으로 끌어올려지는 호이스팅(hoisting) 현상이 있습니다.(초기화 전은 undefined)

   - **재선언 가능**

   2. **let**

      - **스코프**: 블록 스코프.

      - **호이스팅**: 이루어지지만 TDZ가 존재.

      - **재선언 불가**

   3. **const**

      - **스코프**: 블록 스코프.

      - **호이스팅**: 이루어지지만 TDZ가 존재.

      - **재선언 불가**

      - **불변성**

### 일시적 사각지대(Temporal Dead Zone, TDZ)

1. **정의**: JS에서 let이나 const로 선언된 변수가 초기화되기 전까지 접근할 수 없는 상태.

2. **스코프**: TDZ는 블록 스코프에서 발생합니다.

3. **호이스팅과의 관계**: 변수는 호이스팅이 발생하지만, 실제 초기화는 선언된 위치에서 이루어집니다. 이때문에 TDZ가 필요.

### let과 const(자필 및 chatGPT)

let과 const는 윈도우 객체에 추가되지 않는다. 네임 스페이스의 오염 방지나, let과 const 변수를 더 안전하게 보관하기 위해 추가된 규칙이다.

### 스코프

변수와 함수가 유효하고 접근 가능한 범위를 의미합니다. 스코프는 변수의 생명주기와 접근 가능성을 정의합니다.

- **주요 유형의 스코프**

  1.  **전역 스코프**: 코드의 최상위 레벨에서 선언된 변수, 프로그램의 모든 부분에서 접근가능.

  2.  **블록 스코프**: {}로 둘러싸인 코드 블록 내에서만 유효.

  3.  **함수 스코프**: 함수 내에서만 유효.

### 변수의 생성과정

**_과정_**

1.  **선언(Declaration)**: 변수의 이름과 데이터 타입 정의.

2.  **초기화(Initialization)**: 초기 값을 할당.

3.  **메모리 할당 (Memory Allocation)**: 선언 및 초기화되면, 변수에 메모리 할당.

4.  **스코프 및 라이프타임 설정**

    1. **스코프(Scope)**: 변수가 유효한 범위.

    2. **라이프타임(lifetime)**: 변수가 메모리에 존재하는 기간.

5.  **접근 (Access)**: 프로그램의 다른 부분에서 해당 변수를 읽거나 수정할 수 있습니다.

6.  **메모리 해제 (Memory Deallocation)**: 변수의 라이프타임이 끝나면 메모리 해제.(자동 수행(지역 변수), 명시적 수행(동적 할당 메모리))

### 라이프 타임

변수나 객체가 메모리에서 존재하는 기간을 의미합니다.

1. **_라이프타임의 유형_**

   1. **정적 라이프타임 (Static LifeTime)**: 프로그램 시작시 메모리에 할당, 종료시 메모리 할당 해제.(전역 변수나 정적 변수)

   2. **자동 라이프타임 (Automatic Lifetime)**: 블록(주로 함수) 내에서 선언되며, 블록에 따라 메모리 할당 및 해제.(지역 변수)

   3. **동적 라이프타임 (Dynamic Lifetime)**: 명시적으로 메모리 할당 및 해제.(동적 메모리 할당된 객체)

   4. **_라이프타임의 중요성_**

      1. **메모리 관리**: 메모리 할당과 해제를 적절히 관리가능.

      2. **변수의 유효성**: 라이브러리를 통해 변수의 유효 범위 확인가능.

      3. **성능 최적화**: 메모리 사용을 최적화, 변수의 라이프타임을 조절.

### 모든 브라우저에서 ES6 스펙에 대한 지원이 완벽하지 않으며, 해결 방안은?

**브라우저 지원 전략**이며, 지원 현황 분석 및 특정 기능이나 코드를 지원하는 대체 방안 마련합니다.

- **전략들**

  1.  **폴리필(Polyfills) 사용**

      - **정의**: 특정 ES6 기능이 지원되지 않는 브라우저에서 해당 기능을 구현하는 코드를 제공하는 모듈.

      - **예시**:core-js

  2.  **트랜스파일러(Transpilers) 사용**

      - **정의**: ES6+ 코드를 ES5로 변환할 수 있는 모듈.

      - Babel 설정으로 어떤 버전의 JS로 변환할지 지정가능.

  3.  **브라우저 호환성 확인**: 프로젝트에서 사용할 기능이 실제로 지원되는 확인.

  4.  **대체 라이브러리 사용**

  5.  **조건부 로딩 및 기능 감지**: 코드에서 특정 기능이 지원되는지 감지하고, 지원하지 않다면 대체 방법을 제공.(Modernize같은 라이브러리 사용 추천)

### Babel

JS의 최신 버전을 이전 버전의 JS로 변환해주는 트랜스파일러입니다.

1.  **_주요 기능_**

    1. **트랜스파일링**: 최신 JS 코드를 ES5 또는 다른 버전으로 변환합니다.

    2. **플러그인 시스템**: Babel은 다양한 플러그인을 사용하여 특정 문법을 변환하거나 기능을 추가할 수 있습니다.

    3. **프리셋(Presets)**: 여러 개의 플러그인을 그룹으로 묶어 제공하는 기능입니다.

    4. **폴리필 지원**: Babel은 새로운 API를 사용할 수 있도록 폴리필을 추가하는 방법도 지원.

2.  **사용 방법**

    1. **설치**: Babel을 프로젝트에 설치합니다.

    ```bash
    npm install --save-dev @babel/core
    @babel/cli @babel/preset-env
    ```

    2. **설정**: Babel 설정 파일을 만들어 사용할 플러그인이나 프리셋을 지정합니다.

    설정 파일은 .babelrc 또는 babel.config.json 형식으로 만들 수 있습니다.

        **예시 (babel.config.json)**

        ```json
        {
        "presets": ["@babel/preset-env"]
        }
        ```

    3. **트랜스파일링**: Babel CLI를 사용해 파일을 변환할 수 있습니다.

    ```bash
    npx babel src --out-dir dist
    ```

3.  **요약**: 최신 JS 기능을 사용하면서도 다양한 환경에서 코들 실행할 수 있도록 해주는 도구.

### webpack

현대 웹 애플리케이션을 위한 모듈 번들러.(js, css, 이미지, 폰트 등의 자원을 하나 또는 여러 파일로 묶음)

- **_주요 기능_**

  1.  **모듈화**

  2.  **의존성 관리**

  3.  **코드 스플리팅**(애플리케이션의 로딩 성능을 개선하기 위해 코드를 여러 덩어리로 나누고, 필요한 시점에서 로드)

  4.  **트리 쉐이킹**(사용하지 않는 코드 자동 제거)

  5.  **플러그인 및 로더**

## react

### React

사용자 인터페이스(UI를 구축하기 위한 JS 라이브러리, Facebook에서 개발 및 관리)

**_주요 특징_**

1. **컴포넌트 기반**(독립적 컴포넌트)

2. **가상 DOM**(이전 가상 DOM과 비교, 부분 업데이트 가능)

3. **선언형 프로그래밍**(UI를 설명하는 선언적 방식을 사용)

4. **단방향 데이터 흐름**(컴포넌트가 부모에서 자식으로.)

5. **생태계**(거대하다.(Redux, React Router 등))

### 상태관리

애플리케이션의 데이터와 UI 상태를 관리하는 과정을 의미합니다.

- **_주요 요소_**

  1.  **상태(State)**: 애플리케이션에서 변환하는 데이터.

  2.  **상태 업데이트**: 사용자의 행동이나 이벤트에 따라 상태를 변경하는 과정입니다.

  3.  **UI와 상태의 연결**: 상태가 변경되면 UI도 자동으로 업데이트되도록 연결하는 방법입니다.

  4.  **상태 관리 라이브러리**: Redux, MobX, Recoil 등과 같은 라이브러리를 사용하여 복잡한 상태를 관리할 수 있습니다.

### React의 동작원리

1. **컴포넌트 기반 아키텍처**: React는 UI를 독립적인 컴포넌트로 나누어 구성합니다.(상태와 속성 보유, 다른 컴포넌트 보유 가능)

2. **가상 DOM**: 가상 DOM으로 이전의 가상 DOM과 비교(diffing) 실제 DOM에 필요한 최소 변경만 수행

3. **선언형 프로그래밍**: 자동으로 UI를 렌더링하여 최신 상태를 반영. 개발자는 UI의 최종결과를 정의, 효율적으로 처리.

4. **단방향 프로그래밍**: 부모에서 자식으로.

5. **사이드 이펙트 처리**: useEffect 훅과 같은 방법으로 업데이트 후의 부작용 관리.

### 컴포넌트

React에서 UI를 구성하는 독립적인 단위, 각각의 컴포넌트는 특정한 기능이나 UI 조각을 담당합니다.

**_주요 특징_**

1. **재사용성**(독립적으로 작성됨)

2. **상태와 속성**

   - **상태(State)**: 각 컴포넌트는 자신의 상태를 가지며, 변경되면 자동으로 재렌더링.

   - **속성(Props)**: 부모 컴포넌트로부터 전달받는 데이터, 속성을 통해 컴포넌트 간에 데이터를 전달.

3. **생명주기**: 생성, 업데이트 삭제의 생명주기 관리를 위해 클래스 컴포넌트에서는 생명주기 메서드를, 함수형 컴포넌트에서는 훅을 사용.

4. **컴포넌트 종류**

   - **함수형 컴포넌트**: 상태와 생명주기 훅 사용.

   - **클래스형 컴포넌트**: 상태와 생명주기 메서드 포함.

5. **합성**: 컴포넌트 중첩 가능.

### 훅

React 16.8에서 도입된 기능으로, 함수형 상태 관리와 생명주기 메서드의 기능을 사용할 수 있게 해줍니다.

1. **useState**: 상태를 관리할 수 있는 훅입니다.

   ```js
   const [coount, setState] = setState(0);

   const increment = () => {
     setCount(count + 1);
   };
   ```

2. **useEffect**: 컴포넌트가 렌더링된 후에 특정 작업을 수행할 수 있도록 해주는 훅입니다.

   ```js
   useEffect(() => {
     // 컴포넌트가 마운트될 때 실행되는 코드
     console.log("component mounted");

     // cleanup function (언마운트될 때 실행)
     return () => {
       console.log("Component unmounted");
     };
   }, []);
   ```

3. **useContext**: React의 Context API와 함께 사용하여, 컴포넌트 간에 데이터를 쉽게 공유할 수 있게 해주는 훅입니다.

   ```js
   const value = useContext(MyContext);
   ```

4. **useReducer**: Redux와 유사한 패턴 사용, useState보다 복잡한 상태 로직을 다루기 위한 훅.

   ```js
   const [state, dispatch] = useReducer(reducer, initialState);
   ```

5. **커스텀 훅**: 사용자 정의 훅을 만들어 공통 로직을 재사용할 수 있습니다.

   ```js
   function useFetch(url) {
     const [data, setData] = useState(null);

     useEffect(() => {
       fetch(url)
         .then((response) => response.json())
         .then((data) => setData(data));
     }, [url]);

     return data;
   }
   ```

### 라이프사이클의 메서드 종류는?

1. **마운트 단계**

   - **constructor(props)**: 컴포넌트 생성시 호출, 초기 상태 설정.

   - **componentDidMount()**: 컴포넌트가 마운트된 후에 호출.

2. **업데이트 단계**

   - **componentDidUpdate(prevProps, prevState)**: 컴포넌트가 업데이트된 후에 호출, 이전의 props와 state에 대한 접근이 가능, 변경 사항에 따라 추가 작업 수행.

   - **shouldComponentUpdate(nextProps, nextState)**: 컴포넌트가 업데이트될지 여부를 결정하는 메서드입니다. 기본적으로 true를 반환, 성능 최적화를 위해 false를 반환 가능.

   - **getSnapshotBeforeUpdate(prevProps, prevState)**: DOM이 업데이트되기 전에 호출됩니다.(useLayout 대치)

3. **언마운트 단계**

   **componentWillUnmount()**: 컴포넌트가 언마운트될 때 호출.

4. **에러 처리**

   **componentDidCatch(error, info)**: 자식 컴포넌트에서 에러가 발생했을 때 호출.

### Angular, Vue.js, React.js의 차이는?

1. **_Angular_**

   - **타입**: 프레임워크

   - **개발사**: Google

   - **언어**: Typescript 기반

   - **특징**:

     1. **완전한 솔루션**: 라우팅, 상태 관리, HTTP 클라이언트 등 다양한 기능을 내장하고 있어, 대규 애플리케이션 개발에 적합합니다.

     2. **양방향 데이터 바운딩**: 모델과 뷰 간의 데이터 흐름이 자동으로 동기화.

     3. **모듈화**

     4. **MVC 아키텍처**

2. **_React_**

   1. **타입**: 라이브러리

   2. **개발사**: Facebook

   3. **언어**: JavaScript(주로 JSX 사용)

   4. **특징**:

      1. **컴포넌트 기반**

      2. **가상 DOM**

      3. **단방향 데이터 흐름**

      4. **커뮤니티 및 생태계**

3. **_Vue.js_**

   1. **타입**: 프레임워크

   2. **개발사**: Evan You(개인 개발자)

   3. **언어**: JavaScript

   4. **특징**:

      1. **진입 장벽이 낮음**

      2. **양방향 데이터 바인딩**

      3. **컴포넌트 기반**

      4. **반응형**

4. **_요약_**

   - **Angular**는 전체적인 솔루션을 제공하는 완전한 프레임워크, 대규모 애플리케이션에 적합.(RxJS 내장)

   - **React**는 UI 라이브러리로서 유연성과 성능을 강조합니다.

   - **Vue.js**는 배우기 쉽고 직관적, 규모와 상관없이 개발에 적합.

### Angular의 디자인 원칙

- **모듈화**

- **컴포넌트 기반**

- **양방향 데이터 바인딩**

- **의존성 주입**

### Virtual dom

실제 DOM을 직접 조작하는 대신 메모리 내에서 DOM의 가벼운 복사본을 생성하여 작업하는 방식.

1. **_Virtual DOM의 작동 원리_**

   1. **렌더링**: 애플리케이션의 상태가 변경되면, 새로운 Virtual DOM 생성.

   2. **비교(디프)**: 새로운 Virtual DOM과 이전 Virtual DOM을 비교하고 계산한다.

2. **_최소화된 업데이트_**: 변경된 부분만 실제 DOM에 적용.

3. **장점**

   1. **성능 향상**

   2. **효율적인 렌더링**

   3. **더 나은 사용자 경험**

4. **단점**

   1. **메모리 사용**: Virtual DOM을 유지하기 위한 메모리 필요

   2. **추가적인 추상화**: (DOM과 다르게 동작하는 추상적인 레이어를 다루어야 합니다)

## 바닐라 js

### Typescript 쓰는 이유

Typescript (TS)는 JavaScript의 상위 집합으로 주로 다음과 같은 이유로 사용됩니다.

1. **정적 타입**(오류 발견 쉬움)

2. **개발 도구 지원**(IntelliSense, 자동 완성 등 다양한 개발 도구 지원)

3. **대규모 프로젝트**(코드 유지보수와 협업이 용이(타입이 명확하니까))

4. **최신 JavaScript 기능**(최신 ECMAScript 기능을 사용 가능, 하위 호환성 유지)

### ECMA

"European Computer Manufactures Association", 컴퓨터 및 정보 기술 관련표준을 개발하는 비영리 조직.

- **표준화**

- **기술 규격**(문법, 동작 방식, API 규격)

### 하위 호환성

이전 버전에서 작성된 코드나 데이터가 새로운 버전에서도 정상적으로 작동하도록 보장하는 개념.

1. **_중요성_**

   1. **사용자 경험 유지**

   2. **비용 절감**(기존 시스템 업데이트나 수정이 적음)

   3. **신뢰성**

2. **_필요한 상황_**

   - **API 변화**

   - **데이터 형식**(이전 데이터가 새로운 스키마에서 읽힐 수 있어야함)

   - **소프트웨어 업그레이드**(기존 파일이나 설정의 손상이 없도록)

3. **_도전 과제_**

   1. **기능 추가와 호환성**

   2. **성능**

   3. **복잡성 증가**

### null과 undefined의 차이

1. **정의**

   1. **null**(명시적 값이 없음, 객체 타입)

   2. **undefined**(초기화 되지 않은 상태, 함수가 명시적으로 값을 반환하지 않을 때 포함)

2. **사용 용도**

   1. **null**(일부러 값 비움)

   2. **undefined**(아직 값 초기화 안 함, 인자가 제공되지 않은 경우나 객체 속성이 없을 경우)

3. **타입**

   1. **null**(오류지만, 객체 타입)

   2. **undefined**(undefined)

4. **동등성 비교**

   1. **동등 비교(==)**(같음)

   2. **일치 비교(===)**(다름)

5. **결론**

   1. null은 명시적 값 없음, 의도적 사용.

   2. undefined는 초기화 안 된 값, 자동적 사용.

### 클로저(Closure)

함수와 함수가 선언될 때의 렉시컬 환경(lexical environment)를 함께 기억하는 기능.

**주요 개념**

- **함수의 접근 범위**: 외부함수가 반환된 후에도 내부 함수는 외부 함수의 스코프를 **유지**하기 때문에 해당 변수에 접근 가능.

- **상태 유지**: 클로저를 사용하면 함수가 호출된 상태를 유지 가능.(외부 함수의 변수나 함수들을 사용가능)

### 실행 컨텍스트(Excution Context)

실행 컨텍스트(Execution Context)는 JS 코드가 실행될 때 생성되는 환경, 그 이후 함수호출 시마다 생성(사용가능한 변수, 함수, 객체 정의)

1. **주요 구성 요소**

   1. **변수 환경(Variable Environment)**(현재 실행 컨텍스트 내에서 정의된 변수와 그 값 저장)

   2. **렉시컬 환경(Lexical Environment)**(실행 컨텍스트가 생성될 때의 스코프를 나타냅니다. 이는 외부 함수의 변수에 대한 접근을 관리.)

   3. **this 바인딩(this Binding)**(this가 참조하는 객체 정의)

2. **실행 컨텍스트의 단계**

   1. **전역 컨텍스트**: 코드가 실행될 때 가장 먼저 생성되는 컨텍스트, 전역 변수와 함수 정의. this는 전역 객체 참조.

   2. **함수 호출 컨텍스트**: 함수가 호출될 때마다 새로운 실행 컨텍스트 생성(각각 변수 환경과 렉시컬 환경 소유)

### 브라우저 엔진은?

웹 페이지를 렌더링하고 실행하는 핵심 컴포넌트.

1. **종류**

   1. **렌더링 엔진**: HTML, CSS, JS를 해석하고 화면에 표시.

   2. **JS 엔진**: JS 코드를 실행.

2. **엔진들의 상세설명**

   - **렌더링 엔진**

     1. **Blink**

        - **브라우저**: chrome, Chromium 기반 브라우저(소프트웨어 코드 베이스)

        - **기능**: 빠른 성능과 최신 웹 표준 지원.

        - **특징**: 오픈 소스, 최적화로 로딩 속도 개선, 실험적 기능 추가.

     2. **Gecko**

        - **브라우저**: Mozilla Firefox

        - **기능**: 웹 표준 지원, 안정성과 보안 중심.

        - **특징**: Mozilla의 오픈 소스 프로젝트, 접근성 및 개인 정보 보호 강함, 다양한 플러그인 및 확장 프로그램 지원.

   - **자바스크립트 엔진**

     1. **V8**

        - **브라우저**: Google Chrome, Node.js

        - **기능**: 고속, JIT 컴파일 사용.

        - **특징**: 크로스 플랫폼, 최신 ECMAScript 기능 지원.

     2. **SpiderMonkey**

        - **브라우저**: Mozilla Firfox

        - **기능**: JIT 컴파일 사용.

        - **특징**: 다양한 최신 JS 기능을 지원, WebAssembly와 같은 새로운 웹 기술에도 대응.

### JIT

프로그램 실행 중에 코드의 일부를 런타임에 컴파일하여 성능을 높임.

1. **_작동 방식_**

   1. **소스 코드**: 원래의 소스 코드가 인터프리터에 의해 실행.

   2. **컴파일**: 자주 실행되는 코드(핫스팟)을 감지하면 JIT 컴파일러가 해당 코드를 기계어로 컴파일.

   3. **캐시에 저장**

2. **_장점_**

   - **성능 향상**

   - **동적 최적화**(런타임에 코드 실행 패턴을 분석하고 최적화)

3. **_단점_**:

   - **메모리 사용**(추가적인 메모리 사용)

   - **초기 지연**

### 컴파일

고급 프로그래밍 언어로 작성된 소스코드를 기계어 또는 중간 코드로 변환하는 과정입니다.

### 자바스크립트의 Number Type과 다른 언어의 차이는?

1. **_자바스크립트의 Number Type_**

   1. **단일 숫자 타입**

   2. **NaN과 Infinity**

   3. **정확도 제한**(15~17 자리, 정밀한 수치 계산에선 문제발생)

2. **_다른 언어의 숫자 타입_**

   1. **\*C, C++**: int(정수), float(단정도 부동 소수점), double(배정도 부동 소수점), long(긴 정수)

   2. **Java**: int, long, float, double,BigInteger(큰 정수[래퍼타입]), BigDecimal(정밀한 부동 소수점[래퍼타입]).

   3. **Python**: int(메모리 동적 할당 가능), float

3. **_단일 타입 이유_**

   1. **단순성**(하나로 처리 가능)

   2. **부동 소수점 사용**(동적 웹페이지를 다루기 때문에 정수와 부동소수점 통합)

   3. **유연성**(여러 데이터 유형을 수용가능)

   4. **복잡성 감소**(타입 변환 등에 들일 수고가 줄어듬)

### 배정도, 단정도의 뜻(개인질문)

부동소수점 표현 방식.

1. **_단정도 (Single Precision)_**

   1. **정의**: 4바이트 부동 소수점.

   2. **구성**

      - **1비트**: 부호 비트(Sign bit)

      - **8비트**: 지수(exponenet)

      - **23비트**: 가수(maintissa 또는 Significand)

   3. **정확도**: 약 7자리

2. **_배정도 (Double Precision)_**

   1. **정의**: 8바이트 부동 소수점.

   2. **구성**

      - **1비트**: 부호 비트(Sign bit)

      - **8비트**: 지수(exponenet)

      - **52비트**: 가수(mantissa 또는 significand)

   3. **정밀도**: 약 15~17자리

### 배열과 실제 자료구조 배열의 차이점은?

1. **고정 크기 vs 가변 크기**

   1. **실제 배열**: 일반적으로 고정 크기.

   2. **js 배열**: 가변 크기.

2. **자료형 제한**

   1. **실제 배열**: 동일한 데이터 타입만 포함.

   2. **js 배열**: 데이터 타입 혼합 가능.

3. **메모리 할당**

   1. **실제 배열**: 메모리 연속적으로 할당.

   2. **js 배열**: 메모리가 비연속적.

4. **메서드 및 기능**

   1. **실제 배열**: 기본적인 접근 및 수정 기능.

   2. **js 배열**: 다양한 내장 메서드 제공.

5. **사용 목적**

   1. **실제 배열**: 알고리즘 및 데이터 구조에서 특정한 용도.(스택, 큐)

   2. **js 배열**: 고급 언어에서 사용하는 데이터 구조, 데이터 집합 표현.

6. **요약**

   - js 배열은 가변 크기, 다양한 데이터 타입포함 가능.

   - 실제 배열은 고정 크기, 단일 데이터 타입포함.

   - js 배열은 다양한 내장 메서드 제공.

### DTO(개인질문)

### Call, Apply, Bind

Call, Apply, Bind는 JS에서 함수의 this 값을 명시적으로 설정하고 호출하는 방법을 제공하는 메서드.

1. **call()**

   - **정의**: call 메서드는 주어진 this 값과 인수로 함수의 실행을 호출.

   - **사용법**

     ```js
     func.call(thisArg, arg1, arg2, ...)
     ```

   - **예제**

     ```js
     function greet(greeting) {
       console.log(`${greeeting}, ${this.name}`);
     }
     const person = { name: "Alice" };
     greet.call(person, "Hello"); // *Hello, Alice"
     ```

2. **apply()**

   - **정의**: apply 메서드는 call과 유사하지만, 인수를 배열로 전달

   - **사용법**

   ```js
   func.apply(thisArg, [argsArray]);
   ```

   - **예제**

   ```js
   function greet(greeting, punctuation) {
     console.log(`${greeting}, ${this.name}${punctuation}`);
   }
   const person = { name: "Bob" };
   greet.apply(person, ["Hi", "i"]); // "Hi, Bob!"
   ```

3. **bind()**

   - **정의**: bind 메서드는 함수를 호출하지 않고, 특정 this 값으로 새 함수를 생성. 이후에 함수 호출 가능.

   - **사용법**

   ```js
   const newFunc = func.bind(thisArg[, arg[, arg, arg2[, ....]]])
   ```

   - **예제**

   ```js
   function greet(greeting) {
     console.log(`${greeting}, ${this.name}`);
   }
   const person = { name: "Charlie" };
   const greetCharlie = greet.bind(person);
   greetCharlie("Hey"); // "Hey, Charlie"
   ```

4. **요약**

- **call**: 즉시 호출하며 인수를 개별적으로 전달.

- **applye**: 즉시 호출하며 인수를 배열로 전달.

- **bind**: 새로운 함수를 생성, 나중에 호출 가능, 인수를 미리 설정가능.

### this

1. **현재 객체 참조**: 메서드 내에서 this는 메서드가 속한 객체를 참조합니다.

2. **전역 객체 참조**: 전역 컨텍스트에서 this는 전역 객체(브라우저에서는 window, Node.js에서는 global)를 참조합니다.

3. **클래스 인스턴스 참조**: 클래스 메서드 내에서 this는 해당 클래스의 인스턴스를 가리킵니다.

4. **화살표 함수**: this가 외부 컨텍스트에서 결정됩니다. this는 자신을 감싸고 있는 함수나 객체의 this를 유지합니다.

5. **메서드 체이닝**: this는 이전 메서드 호출의 결과 객체를 참조.

this는 호출되는 문맥에 따라 달라짐.

### useStrict

엄격 모드를 활성화하는 지시어.

1. **_주요 특징_**

   1. **변수 선언을 필수로**

   2. **객체의 속성 수정 금지**

   3. **변수 이름 중복 금지**

   4. **this의 기본 값 변경**: 전역 객체가 this에서 해제

   5. **전역 객체의 속성 방지**(var가 전역객체에 추가되지 않음)

2. **_사용 방법_**

   - **전역에서 사용**: 스크립트 시작 부분에 "use strict";.

   - **함수 내에서 사용**: 함수의 시작 부분.

### useStrict 모드에서의 this는?

1. **기본값이 undefined**

2. **객체의 메서드에서의 this**: 일반 모드와 같다.

3. **call, applye, bind 사용 시**: 일반 모드와 같다.

4. **생성자 함수에서의 this**: 일반 모드와 같다.

## _컴퓨터과학_

## 컴퓨터과학 기초

### 프로세스와 스레드 차이

- **프로세스**

  1.  **정의**: 실행 중인 프로그램의 인스턴스. 각 프로세스는 독립된 메모리 공간 보유, 코드, 데이터, 시스템 자원 포함.

  2.  **자원 할당**: 운영체로부터 자원 할당받음, 서로 독립적.

  3.  **문맥 전환 비용**: 상대적으로 큰 편.(메모리 공간이 다름)

- **스레드**

  1.  **정의**: 프로세스 내에서 실행되는 작은 단위로 내부의 자원 공유 가능.(여러 스레드가 하나의 프로세스에서 동시 실행 가능)

  2.  **자원 공유**: 데이터 전송이 빠르고 효율적.

  3.  **문맥 전환 비용**: 상대적으로 비용이 적음.(메모리 공간이 같음)

### 성능 최적화 방법

1. **코드 최적화**

2. **이미지 최적화**

3. **캐싱**

4. **비동기 로직**

5. **DN 사용**

6. **데이터베이스 최적화**

7. **서버 성능 모니터링**(스케일 업 또는 스케일 다운)

### 정규화 (Normal FOrm)

데이터의 중복을 줄이고 무결성을 높이기 위해 사용하는 과정.

1. **정규화의 목적**

   1. **중복 최소화**

   2. **무결성 유지**: 데이터의 일관성, 정확도 보장. 하나의 데이터 변경이 모든 관련 데이터에 반영.

   3. **쿼리 효율성 향상**(데이터 구조 명확해짐)

2. **정규형 (Normal Form)**

   1. **제 1정규형 (1NF)**

      - 각 컬럼은 더이상 나눌 수 없는 단일값.

      - 중복된 행이 없음.

   2. **제 2정규형 (2NF)**

      - 제 1정규형 만족, 기본키에 대해 완전 함수 종속.(기본키의 모든 값에 의존해야 한다)

   3. **제 3정규형 (3NF)**

      - 제 2정규형 만족, 기본 키에 대해 이행적 함수 종속 X.(A->B, B->C, A->C는 성립되어선 안된다.)

   4. **BCNF (Boyce-Codd Normal Form)**

      - 제 3정규형 만족, 모든 결정자 후보 키. 비주요 속성이 다른 비주요 속성에 의존하면 안된다.

3. **정규화의 장덤과 단점**

   - **장점**: 데이터 중복 감소, 무결성 증가, 업데이트 및 관리의 용이성

   - **단점**: 과도한 정규화는 쿼리 성능 저하, 복잡한 조인 필요시 성능 저하, 설계와 유지 관리의 복잡함

### CDN

- **정의**: 전 세계에 분산된 서버 네트워크.

- **작동 원리**: 사용자의 지리적 위치에 가장 가까운 서버에서 정적 콘텐츠 제공.

- **장점**

  - **속도 향상**(데이터 전송 거리 감소)

  - **트래픽 분산**

  - **보안**(DDos 공격 방어 및 SSL 지원 기능 제공)

### 스케일 업(Scale Up)

- **정의**: 기존 서버의 하드웨어 업그레이드.

- **장점**

  - **간단한 관리**

  - **즉각적인 성능 향상**

- **단점**

  - **비용 문제**

  - **한계**(특정 한계에 도달시 더 이상 확장 불가)

### 스케일 아웃

- **정의**: 여러 대의 서버를 추가하여, 시스템 확장.

- **장점**

  - **유연성**

  - **비용 효율성**

- **단점**

  - **복잡성**: 여러 서버를 관리 필요.

  - **데이터 일관성**: 데이터 분산으로 인해.

### 자료구조

1. **배열**

   - **설명**: 동일 타입 데이터, 연속적 메모리 구조, 인덱스 접근 가능.

   - **특징**: 고정된 크기, 랜덤 액세스(순차접근 필요X)가 가능, 삽입과 삭제가 비효율.

2. **연결 리스트(Linked List)**

   - **설명**: 각 요소가 다음 요소에 대한 포인터를 포함하는 구조입니다.

   - **특징**: 동적으로 크기 조정 가능, 삽입과 삭제 용이, 랜덤 액세스 불가.

3. **스택(Stack)**

   - **설명**: LIFO 원칙 데이터 저장.

   - **특징**: 함수 호출 시의 실행 컨텍스트를 저장하는 데 자주 사용.

4. **큐(Queue)**

   - **설명**: FIFO 원칙.

   - **특징**: 프로세스 스케줄링이나 데이터 전송에서 유용하게 사용.

5. **해시 테이블 (Hash Table)**

   - **설명**: 키-값 쌍을 저장, 함수 사용 데이터에 빠른 접근.

   - **특징**: 평균적으로 0(1)의 시간 복잡도, 충돌 해결(두 개의 키가 동일한 해시값 보유) 필요.

6. **트리(Tree)**

   - **설명**: 계층적 구조, 노드는 자식 노드 보유가능. (이진 트리, AVL 트리, 이진 탐색 트리 등.)

   - **특징**: 트리 사용시 데이터 검색 및 정렬이 효율적.

7. **그래프(Graph)**

   - **설명**: 노드(정점)와 이들을 연결하는 간선으로 구성. (방향성 및 비방향성 그래프)

   - **특징**: 복잡한 관계 모델링, 최단 경로 알고리즘 등 사용.

### 큐와 스택 차이

- **스택 (Stack)**

  - **정의**: LIFO.

  - **작동 방식**:

    - **푸시(push)**: 추가.

    - **팝(pop)**: 삭제.

  - **특징**

    - 함수 호출 관리, Undo 기능 구현 등.

    - 최근의 데이터에 빠른 접근 가능.

- **큐 (Queue)**

  - **정의**: FIFO.

  - **작동 방식**

    - **인큐(enqueue)**: 추가.

    - **디큐(dequeue)**: 삭제.

  - **특징**:

    - 주로 프로세스 스케줄링, 데이터 전송 및 버퍼 관리 등.

    - 선입선출 구조로 순서가 중요한 상황에서 유용합니다.

### BST

1. **_주요 특징_**

   1. **이진 트리 구조**: 최대 두 자식 노드.

   2. **정렬된 구조**: 가운데 노드는 중간값 ,왼쪽 서브트리는 작은 값, 오른쪽 값은 큰 값 저장.

   3. **빠른 검색**: BST는 O(log n)의 시간 복잡도의 데이터 검색, 트리의 높이가 log n.

   4. **순회**: 중위 순회(in-order traversal)를 수행하면 BST에 저장된 값들 오름차순 정렬 출력.

2. **주요 연산**

   1. **삽입(Insert)**: 루트에서 시작하여 왼쪽 또는 오른쪽 서브트리.

   2. **검색(Search)**: 삽입과 같은 방식으로, 값을 찾으면 해당 노드 반환, 찾지 못하면 null 또는 특정 값 반환.

   3. **검색(Delete)**

      1. **리프 노드**: 단순 제거.

      2. **하나의 자식 노드**: 해당 노드 제거, 자식 노드를 그 위치에.

      3. **두 개의 자식 노드**: 일반적으로 오른쪽 서브트리에서 가장 작은 값이나 왼쪽 서브트리에서 가장 큰 값으로 대체.

3. **장점**

   1. **효율적인 검색 및 업데이트**(O(log n))

   2. **정렬된 데이터 유지**(중위 순회로 쉽게 작업가능)

4. **단점**

   1. **불균형**(최악의 경우 BST는 편향된 구조가 이루어지며 높이가 n이 되고, 시간 복잡도가 O(n)으로 증가.)

   2. **메모리 사용**(각 노드에 추가적인 포인터(왼쪽, 오른쪽 자식)를 저장함.)

### 자가 균형 이진 검색 트리

일반적인 BST는 불균형해질 수 잇지만, 자가 균형 트리는 항상 균형을 유지하고 최악의 경우에도 O(log n)의 시간 복잡도 유지.

1. **주요 특징**

   1. **균형 유지**: 트리의 높이를 최소화 연산의 효율성 보장. 균형 조건을 위반 시, 회전 연산을 통해 트리 재구성.

   2. **이진 검색 트리 성질**: 각 노드는 최대 두 개의 자식을 가지며, 왼쪽 서브트리는 해당 노드보다 작고, 오른쪽 서브트리는 해당 노드보다 큽니다.

2. **자가 균형 이진 검색 트리의 종류**

   1. **AVL 트리**:

      1. AVL 트리는 각 노드 높이 차리를 1로 유지. 2 이상이 되면 회전 연산.

      2. 삽입과 삭제 시 최대 1회의 회전.

   2. **Red-Black 트리**:

      1. Red-Black 트리는 각 노드에 색(빨간색 또는 검은색)을 부여, 특정 규칙을 유지.

      2. 삽입과 삭제 시 두 가지 경우의 회전이 필요할 수 있으며, 최악의 경우에도 O(log n) 시간 복잡도.

   3. **Splay 트리**

      1. Splay 트리는 최근 접근한 노드를 루트로 이동시키는 방식으로 자가 균형 유지.

      2. 데이터의 접근 패턴에 따라 동적으로 트리 조정.

3. **장점**

   1. **효율적인 검색**: 자가 균형을 통해 트리의 높이를 제한하여 시간 복잡도를 O(log n)으로 유지.

   2. **동적 데이터 처리**: 자주 변하는 데이터에 대해 성능 최적화, 효율적인 데이터 관리 가능.

4. **단점**

   1. **복잡한 구현**

   2. **메모리 오버헤드**(추가적인 정보 저장)

### 시간 복잡도

알고리즘이 입력 크기에 따라 얼마나 많은 시간을 소요하는지를 분석하는 방법.

1. **_주요 개념_**

   1. **입력 크기**: 입력의 크기는 n으로 표시.(배열의 길이, 리스트의 요소 수, 그래픽의 노드 수)

   2. **알고리즘의 실행 시간**(최악의 경우, 평균의 경우, 최선의 경우)

   3. **빅오 표기법(Big o Notation)**(최악의 경우)

      1. **O(1)**(상수 시간(입력 크기에 관계 X))

      2. **O(log n)**(로그 시간(이진 탐색))

      3. **O(n)**(선형 시간(배열 한바퀴 순회))

      4. **O(n log n)**(선형 로그 시간 (합병 정렬, 퀵 정렬 등))

      5. **O(n^2)**(이차 시간(버블 정렬, 선택 정렬 등))

      6. **O(2^n)**(지수 시간 (피보나치 수열의 재귀적 계산 등))

2. **시간 복잡도의 중요성**

   1. **성능 평가**

   2. **효율적인 알고리즘 선택**

   3. **자원 관리**

### 트랜잭션 데드락

데이터베이스나 멀티스레딩 환경에서, 두 개 이상의 트랜잭션이 서로의 자원을 점유한 상태로 서로의 자원을 기다리고 있는 상황.

- **주요 특징**

  - **상호 배제**(동시 접근을 막는다)

  - **보유 및 대기**(최소한 하나의 자원을 보유하고 있고, 다른 자원 요청시 대기)

  - **비선점**(다른 트랜잭션에 빼앗기지 않는다.)

  - **순환 대기**(트랜잭션들 간 자원을 점유하고 대기하는 순환구조)

- **데드락 해결 방법**

  - **시간 초과(Timeout)**(시간 초과시 트랜잭션 종료)

  - **탐지 및 회복**(주기적으로 데드락 상태 감지, 하나 이상의 트랜잭션 종료)

  - **예방**(사전에 규칙 설정)

  - **순서 지정 방법**(트랜잭션이 자원을 요청하는 수선를 지정)

### 좀비프로세스

운영 체제에서 종료된 프로세스이지만, 여전히 프로세스 테이블에 남아 있는 상태.

1. **좀비 프로세스의 특징**

   1. **종료 상태 유지**(좀비 프로세스는 이미 실행을 마친 상태, 종료 코드와 같은 정보 보유)

   2. **부모 프로세스 필요**(자식 프로세스 종료시, 부모 프로세스가 wait() 시스템 호출로 종료 상태를 수집 필요.)

   3. **자원 소모**(자원 소모는 없지만, 프로세스 테이블 항목을 차지)

2. **좀비 프로세스 해결 방법**

   1. **부모 프로세스 수정**(부모 프로세스에서 자식 프로세스의 종료 상태 수집하도록 코드 수정.(wait() 또는 waitId() 함수))

   2. **부모 프로세스가 종료**(부모 프로세스 종료시, 좀비 프로세스는 init 프로세스(또는 시스템의 첫 번째 프로세스)로 대체되어, 해당 프로세스가 종료 상태를 수집.)

## 가상화

### Docker

컨테이너 기술로, 애플리케이션 가상화하여 독립적인 환경에서 실행할 수 있게 해줍니다.

### 컨테이너

애플리케이션과 그 실행에 필요한 모든 의존성을 패키징하여 격리된 환경에서 실행할 수 있게 해주는 경량화된 가상화 기술입니다.

- **주요 특징**

  1.  **격리성**(서로 독립적)

  2.  **경량**(VM에 비해 적은 리소스 필요, 빠른 시작과 종료 가능)

  3.  **이식성**(컨테이너 이미지를 다양한 환경에서 일관되게 실행 가능)

  4.  **버전 관리**(특정 상태로 쉽게 롤백 가능)

### 컨테이너의 가상화

가상화의 한 형태, 애플리케이션과 그에 필요한 라이브러리, 종속성 등을 패키징하여 격리된 환경에서 실행할 수 있도록 하는 기술입니다.

### Docker와 VM의 차이는?

1. **구조**

   1. **VM (가상 머신)**

      1. 하이퍼 바이저 기반

      2. 독립된 운영체제, 하드웨어 리소스 가상화, 동시 실행 가능.

      3. 전체 시스템 포함.

      4. 예: VMware, VirtualBox, Hyper-V 등.

   2. **Docker**

      1. 컨테이너 기술 사용

      2. 경량, 동시 실행 가능.

      3. 커널 공유, 라이브러리와 종속만 포함

2. **_성능_**

   1. **VM**: 느린 시작, 많은 리소스 소모.

   2. **Docker**: 빠른 시작, 적은 오버헤드, 높은 성능, 높은 자원 효율성.

3. **_유연성 및 배포_**

   1. **VM**: **테스트 용이**(다양한 운영체제 호환), **배포 및 관리의 어려움**(이미지가 크고 복잡)

   2. **Docker**: **호환성**(애플리케이션 이식 가능), **용량이 적음**, **배포 도구**(Docker Hub)

4. **_관리 및 오케스트레이션(Orchestration(자동화 및 조정))_**

   1. **VM**

      1. VM 관리 및 오케스트레이션 복잡, 각 VM 업데이트 및 패치 필요.

      2. **관리 도구 필요**(vSphere, OpenStack 등)

   2. **Docker**

      1. **쉬운 배포**(관리 도구 제공(Docker Compose, Kubernetes))

5. **결론**

   - **VM**: **안전한 가상화 환경**, **큰 리소스 소모**

   - **Docker**: **경량**, **빠르고 효율적인 배포 및 관리**

## 버전관리

### 버전 관리 시스템

1. **변경 이력 관리**

   - **기능**: 파일의 모든 변경 사항을 추적, 백업이 쉬움.

   - **장점**: 코드의 변화를 기록, 실수로 인한 변경을 복구 가능.

2. **협업 지원**

   **기능**: 동시 작업 가능.

   **장점**: 분산 작업 충돌 최소화 및 통합.

3. **브랜칭과 머징**

   - **기능**: 독립적인 작업이 가능한 **브랜칭**, 통합하는 **머징**.

   - **장점**: 새로운 기능 및 수정 작업 테스트 용이.

4. **분산 버전 관리**

   - **정의**: **로컬 작업가능**(각자의 작업환경에서 코드베이스 복사본 보유)

   - **예시**: Git, Mecurial.

   - **장점**: 서버 의존성 적음, 로컬 작업가능.

5. **중앙 집중식 버전 관리 시스템**

   - **정의**: **중앙화**(모든 변경 사항이 서버에 저장)

   - **예시**: Subversion(SVN), CVS

   - **특징**: **관리 용이**(서버의 의존성 큼)

### git이란?

소스 코드 버전 관리 시스템(VCS).

1. **분산 버전 관리**

2. **효율적인 브랜칭과 머징**

3. **버전 이력 관리**(파일의 변경 이력 기록, 백업 용이)

4. **변경 사항 추적**

5. **협업 지원**(충돌 최소화)

6. **오픈 소스**

7. **강력한 커맨드라인 인터페이스**

8. **GibHub과 같은 플랫폼**(원격 저장소에서 코드 관리 및 협업이 쉽다)

### Github

git 버전 관리 시스템 기반, 웹 기반 호스팅 서비스.

1. **특징**

   1. **소스 코드 호스팅**: 중앙 저장소 제공.

   2. **버전 관리**: git 기능 모두 지원.

   3. **협업 기능**

   4. **이슈 관리**: 이슈 트래커 제공.

   5. **프로젝트 관리 도구**

   6. **GitHub Actions**(CI/CD 자동화 도구.)

   7. **오픈 소스 지원**(오픈 소스 프로젝트 지원)

   8. **커뮤니티 및 네트워킹**(서로의 코드를 보고 피드백을 주고받을 수 있는 커뮤니티 제공)

   9. **GitHub Pages**: 정적 웹사이트 호스팅 기능.

   10. **API와 통합**: 다양한 API를 제공. 서드 파티 도구와의 호환성 제공.

## Jekins

오픈 소스 자동화 서버, CI/CD 지원하기 위해 사용.

1. **특징**

   1. **지속적 통합 및 배포**

   2. **플러그인 아키텍퍼**

   3. **자동화 빌드**

   4. **모니터링 및 보고**

   5. **다양한 언어 및 플랫폼 지원**

   6. **분산 빌드**

   7. **사용자 친화적인 인터페이스**

   8. **보안 및 권한 관리**

   9. **스크립팅 및 커스터마이징**

   10. **활발한 커뮤니티 및 지원**
