# 목차

- **웹**

  - **웹 기초**

    1.  **문서객체모델**
    2.  **JSON**
    3.  **세션, 쿠키, 캐시**
    4.  **CORS(Cross-Origin Resource Sharing)**
    5.  **적응형과 반응형의 차이**
    6.  **SSR, CSR**
    7.  **SEO**
    8.  **SERP**
    9.  **크롤링(Crawling)**
    10. **인덱싱 (Indexing)**
    11. **DNS(domain name system)**

  - **웹 프로토콜 및 응용**

    1. **RESTful API**
    2. **OSI 7계층**
    3. **TCP/IP 4계층 및 5계층 모델**
    4. **TCP, UDP**
    5. **웹 프로토콜**
    6. **HTTP들의 버전**
    7. **SSL/TLS**
    8. **웹 보안**
    9. **MFA**
    10. **IDP/IPS (Intrusion Detection System / Intrusion Prevention System)**
    11. **HTTP와 HTTPS의 차이**
    12. **HTTP 상태 코드**
    13. **3 Way-HandShake 및 4 Way-HandShake**
    14. **세션 기반 인증과 토큰 기반 인증**
    15. **google.com을 입력했을 때**
    16. **크로스 브라우징**
    17. **웹 접근성**
    18. **JWT**
    19. **대칭 비밀 키 암호화와 비대칭 키 암호화 방식**
    20. **퍼블릭 IP와 프라이빗 IP**
    21. **ISP(Internet Service Provider)**
    22. **IPv4, IPv6의 차이**
    23. **IPSec**
    24. **OAuth(번외)**
    25. **서드파티**
    26. **WAS**
    27. **WS**

- **코딩**

  - **콜백함수**

    1. **AJAX**
    2. **동기와 비동기**
    3. **async/await 외의 비동기 처리 방법**
    4. **RxJS**
    5. **데이터의 스트림 형태**
    6. **Promise**
    7. **메서드 체이닝이란? 장단점은?**
    8. **콜백 함수**
    9. **프라미스와 콜백함수의 차이점과 각각의 장단점은?**
    10. **콜백 지옥**

  - **코딩이론**

    1.  **추상화**
    2.  **원시 타입과 참조타입에 대해서**
    3.  **가비지 컬렉터(Garbage Collector, GC)**
    4.  **리팩토링**
    5.  **클린 코드와 리팩토링 차이**
    6.  **순환참조**
    7.  **Call By Value와 Call By Reference**
    8.  **TDD**
    9.  **CICD**
    10. **트러블 슈팅 경험**

  - **프론트엔드**

    1.  **CSS 적용 순서**
    2.  **모달과 팝업의 차이**
    3.  **inline과 inline block의 차이**
    4.  **이벤트 위임**
    5.  **GraphQL**
        1. **템플릿 엔진**
    6.  **디자이너가 psd 파일 또는 jpg 파일만 주었을 때 구현 가능?(해당 이미지를 청사진으로서 활용하는 경우의 고려사항)**

  - **백엔드**

    1. **백엔드 프레임워크의 종류**
       1. **AOP**
       2. **프레임워크(JS 기반)**
       3. **의존성 주입 (Dependency Injecction)**
       4. **의존성 주입이 유용한 이유(자필)**
       5. **Angular의 디자인 원칙**
       6. **Waterline**
       7. **런타임**
    2. **프레임워크와 라이브러리 모듈**
    3. **Express**

  - **아키텍처 및 프로그래밍 패러다임**

    1.  **프로토타입**
    2.  **아키텍처**
    3.  **MSA**
    4.  **데코레이터 패턴이란**
    5.  **싱글톤 패턴**
    6.  **MVC 패턴**
    7.  **클라이언트 서버 구조**
        1. **클라이언트 서버 모델의 특징**
        2. **플러그인 기반 아키텍처**
    8.  **마이크로 서비스와 모놀리틱 서비스**
        1. **이벤트 기반 아키텍처**
    9.  **OOP(객체 지향 프로그래밍)의 지향점**
    10. **병렬 프로그래밍**
    11. **함수형 프로그래밍**
        1. **Hydration(번외)**
        2. **순수 함수**
    12. **OOP와 함수형 프로그래밍의 차이점**
    13. **OOP 특징과 원칙**
    14. **동시성 모델**

  - **db**

    1. **db 관계형 비관계형 차이**
    2. **db의 종류**
    3. **ORM**
    4. **인덱스**
    5. **트랜잭션**

- **js**

  - **nodeJs**

    1. **Node.js**
       1. **Node.js는 단일 스레드?(개인적 해석, 인터넷 서치)**
       2. **스레드풀**
       3. **CPU 집약적인 작업**
    2. **Node.js 이벤트 큐 동작 원리**
    3. **이벤트 루프**
    4. **Node.js의 모듈 종류는?**
    5. **Node.js가 BackEnd에서 선호되는 이유**
    6. **Node.js의 장단점**
    7. **npm**
    8. **SemVer**
    9. **npm install**
    10. **dependence와 devDependence 차이**
    11. **Node.js가 싱글 스레드지만 병렬작업이 가능한 이유**
    12. **클러스터링**

  - **ES6의 추가요소들 및 문제해결 방안**

    1. **var, let, const**
    2. **일시적 사각지대(Temporal Dead Zone, TDZ)**
       1. **let과 const(자필 및 chatGPT)**
    3. **스코프**
    4. **변수의 생성과정**
       1. **라이프 타임**
    5. **모든 브라우저에서 ES6 스펙에 대한 지원이 완벽하지 않으며, 해결 방안은?**
    6. **Babel**
    7. **Webpack**

  - **react**

    1.  **React**
    2.  **상태관리**
    3.  **React의 동작원리**
    4.  **컴포넌트**
    5.  **클래스 컴포넌트와 함수형 컴포넌트의 차이는?**
    6.  **훅**
    7.  **라이프사이클의 메서드 종류는?**
    8.  **Angular, Vue.js, React.js의 차이는?**
    9.  **Virtual dom**

  - **바닐라 js관련**

    1. **Typescript 쓰는 이유**
    2. **ECMA**
       1. **하위 호환성**
    3. **null과 undefined의 차이**
    4. **클로저(Closure)**
    5. **실행 컨텍스트(Excution Context)**
    6. **브라우저 엔진은?**
    7. **JIT**
    8. **컴파일**
    9. **자바스크립트의 Number Type과 다른 언어의 차이는?**
       1. **배정도, 단정도의 뜻(개인질문)**
       2. **체이닝**
    10. **배열과 실제 자료구조 배열의 차이점은?**
        1. **DTO(개인질문)**
        2. **직렬화, 역직렬화(개인용)**
    11. **Call, Apply, Bind**
    12. **this**
    13. **useStrict**
    14. **useStrict 모드에서의 this는?**

- **컴퓨터과학**

  - **컴퓨터과학 기초**

    1. **프로세스와 스레드 차이**
    2. **성능 최적화 방법**
       1. **정규화 (Normal Form)**
       2. **CDN(Content Delivery Network)**
       3. **스케일 업(Scale Up)**
       4. **스케일 아웃(Scale Out)**
    3. **자료구조**
    4. **큐와 스택 차이**
    5. **BST**
       1. **자가 균형 이진 검색 트리**
    6. **시간 복잡도**
    7. **트랜잭션 데드락**
    8. **세마포어와 뮤텍스, 조건 변수**
       1. **데이터 경쟁(Data Race)**
    9. **좀비프로세스**
    10. **프로토콜(웹 X)(개인질문)**

  - **가상화**

    1. **Docker**
       1. **컨테이너**
       2. **컨테이너의 가상화**
    2. **Docker와 VM의 차이는?**

  - **버전관리**

    1. **버전 관리 시스템**
    2. **git이란?**
    3. **GitHub**
    4. **Jenkins**

## _웹_

## 웹 기초

### 문서객체모델

문서 객체 모델(DOM)은 HTML 및 XML 문서의 구조화된 표현을 제공하는 프로그래밍 인터페이스입니다. DOM은 문서의 모든 요소, 속성들을 객체로 표현합니다.

1. **_주요 개념_**

   1. **트리 구조**
   2. **노드 타입**
      1. Element Node(기본 태그, \<div> 등)
      2. Text Node
      3. Attribue Node
      4. Document Node
   3. **인터페이스**(언어에 독립적인 API 제공)

2. **_주요 기능_**

   1. **문서 탐색**(다른 노드나 관련 노드를 찾기 편하다)
   2. **내용 변경**(속성이나 텍스트)
   3. **노드 추가 및 삭제**
   4. **이벤트 처리**

3. **_결론_**

DOM은 웹 페이지를 동적으로 조작할 수 있게 해주는 인터페이스다.

### JSON

데이터 교환 형식이며, 텍스트 기반의 포맷이다.

1. **형식**(키-값 쌍의 형태로 구성된다.)
2. **가독성**
3. **언어 독립성**
4. **데이터 유형**(문자열, 숫자, 배열, 객체, 불리언, 널)
5. **사용 용도**(데이터 전송, 설정 파일, 데이터 저장 등)

### 세션, 쿠키, 캐시

1. **_세션(session)_**

   - **정의**: 사용자가 웹사이트에 접속하는 동안의 상태 정보

   - **저장 위치**: 서버에서 저장, 사용자 브라우저에선 세션 ID가 쿠키로 저장된다.

   - **사용 목적**: 로그인 상태 유지, 장바구니 정보 저장 등.

   - **특징**:세션은 일반적으로 사용자가 브라우저를 닫거나 세션 타임아웃이 발생하면 만료됩니다.

2. **_쿠키(Cookie)_**

   - **정의**: 사용자의 정보를 저장하는 작은 데이터 파일

   - **저장 위치**: 클라이언트의 브라우저

   - **사용 목적**: 사용자 인증, 개인화된 설정, 방문 기록 등.

   - **특징**: 쿠키는 만료 기간을 설정할 수 있어 영구적으로 저장될 수 있습니다.

3. **_캐시(Cache)_**

   - **정의**: 임시 저장된 자주 요청되는 데이터

   - **저장 위치**: 클라이언트(브라우저) 및 서버

   - **사용 목적**: 웹 페이지 로딩 속도 향상, 서버 부하 감소 등.

   - **특징**: 만료 기간이나 정책에 따라 갱신됩니다.

### CORS(Cross-Origin Resource Sharing)

웹 브라우저는 다른 출처의 리소스에 대한 요청을 제한하여 보안을 강화합니다.

CORS은 웹 애플리케이션에서 리소스가 다른 출처(origin)에서 요청될 때 보안을 관리하는 메커니즘입니다.

1. **_출처(origin)_**

   - **구성**: 프로토콜, 도메인, 포트번호

2. **_CORS 정책_**

   - **기능**: 서버는 응답 헤더에 특정 CORS 헤더를 포함하여 요청이 허용되는 출처를 명시합니다.

   - **주요 헤더**: Access-Control-Alllow-Origin

3. **_요청 유형_**

   - **단순 요청(Simple Request)**: GET, POST, (특정 조건 하에) 요청 등.

   - **사전 요청(Preflight Request)**: 브라우저가 실제 요청 전에 OPTIONS 메서드를 사용해 서버에 권한을 확인합니다.

4. **_보안_**

   - **보안**: CORS는 출처를 명시적으로 관리합니다.

### 적응형과 반응형의 차이

적응형(adaptive)
반응형(Responsive)

1. **_정의_**

   - **적응형**: 특정 화면 크기나 해상도에 맞춰 미리 여러 레이아웃을 제공하는 방식입니다.

   - **반응형**: 하나의 레이아웃을 사용하며, 화면 크기에 따라 요소의 크기와 위치가 동적으로 조정됩니다.

2. **_작동 방식_**

   - **적응형**: 특정 브레이크포인트(예: 480px 등)에서 서로 다른 레이아웃을 로드합니다.

   - **반응형**: 화면 크기에 맞춰 하나의 레이아웃이 유동적으로 변화합니다.

3. **_장단점_**

   - **적응형**:

     1. **_장점_**: 특정 화면에 맞춘 레이아웃 제공으로, 사용자 경험이 향상될 수 있습니다.

     2. **_단점_**

        1. 개발 및 유지보수가 복잡해집니다.

        2. 시간과 비용이 더 소요될 수 있습니다.

   - **반응형**:

     1. **_장점_**

        1. 유지보수가 용이합니다.

        2. 수정이 쉽다.

     2. **_단점_**

        1. 사용자 경험이 적응형에 비해 뒤떨어질 수 있다.

        2. 유동적인 레이아웃의 구현을 위해 CSS가 도리어 복잡해질 수 있다.

### SSR, CSR

- **_SSR_**

  1. **_정의_**

     - 서버에서 HTML을 생성하여 클라이언트에 전달하는 방식입니다.

  2. **_특징_**

     - **초기 로딩 속도 빠름**

     - **SEO 최적화**

     - **javaScript가 비활성되어도 정상적인 페이지 표시**

  3. **_단점_**

     - **서버 부하**

     - **상호작용 성능 느림**

- **_CSR_**

  1.  **_정의_**

      - 클라이언트(브라우저)에서 JavaScript로 데이터를 가져오고, DOM을 조작하여 HTML을 생성하는 방식입니다.

  2.  **_특징_**

      - **빠른 사용자 경험**

      - **서버 부하 감소**

  3.  **_단점_**

      - **초기 로딩 속도 느림**

      - **SEO 문제**

      - **JavaScript 비활성시 비정상적인 페이지 표시**

### SEO

SEO는 웹사이트나 웹페이지를 검색 엔진 결과 페이지에서 높은 순위에 노출시키기 위한 전략과 기법을 의미합니다.

1. **_주요 요소_**

   - **온페이지 SEO (On-page SEO)**

     - **키워드 최적화**(사용자들이 자주 검색하는 키워드)

     - **메타 태그**

     - **콘텐츠 품질**

     - **간결한 URL 구조**

     - **내부 링크**(해당 웹사이트가 가진 다른 페이지와 링크)

   - **오프페이지 SEO(Off-page SEO)**

     - **백링크**(다른 웹사이트에서 자신의 웹사이트로 연결되는 링크)

     - **소셜 미디어**

   - **기술적 SEO (Technical SEO)**

     - **사이트 속도**

     - **모바일 최적화**

     - **사이트 구조**(크롤링과 인덱스가 쉬운 구조)

     - **사용자 경험**

2. **_SEO의 중요성_**

   - **트래픽 증가**

   - **브랜드 신뢰성**

   - **비용 효율성**

### SERP

SERP는 검색 엔진에서 사용자가 검색한 키워드에 대한 결과 페이지를 의미합니다.

1. **_SERP의 주요 구성 요소_**

   1. **유기적 검색 결과(Organic Results)**(유동적인 검색결과)

   2. **광고**(광고비가 지불된 유료 광고)

   3. **스니펫(Feature Snippets)**(질문에 대한 직접적인 답변이나 요약, 상단에 강조 표시)

   4. **지역 정보(Local Results)**(특정 지역에 대한 검색일 경우, 지역 정보와 지도와 주소가 표시)

   5. **관련 질문(People Also Ads)**

   6. **이미지/비디오 결과**

2. **SERP의 중요성**

   1. **가시성**

   2. **사용자 경험**

   3. **비즈니스 기회**

### 크롤링 (Crawling)

1.  **_정의_**

    - 크롤링은 검색 엔진 봇(크롤러 또는 스파이더)이 웹 페이지를 탐색하여 새로운 콘텐츠를 발견하고, 기존의 페이지를 업데이트하는 과정입니다. 크롤러는 링크를 따라 이동합니다.

2.  **_과정_**

    1.  **시작점**(초기 URL 목록을 기반으로 시작)

    2.  **페이지 수집**(지정된 URL에 접속, 페이지의 콘텐츠를 가져온다)

    3.  **링크 추적**(페이지 내의 링크를 분석, 새로운 URL을 큐에 추가하고 지속적으로 크롤링 진행)

    4.  **재방문**(정기적인 지속적 업데이트)

3.  **_중요성_**

    - **신규 콘텐츠 발견**

    - **업데이트 유지**

### 인덱싱 (Indexing)

1.  **_정의_**

    - 인덱싱은 크롤링을 통해 수집된 웹 페이지의 콘텐츠를 분석하고, 이를 검색 엔진의 데이터베이스에 저장하고 정리하는 과정이다.

2.  **_과정_**

    1. **데이터 분석**(텍스트, 메타 태그, 이미지 등을 분석하고 중요한 정보 추출)

    2. **구조화**(키워드와 관련된 구조로 정리하여 인덱스 생성)

    3. **저장**(db에 저장)

3.  **중요성**

    1. **검색 효율성**(db의 인덱스)

    2. **정확한 검색 결과**

### DNS(domain name system)

인터넷에서 도메인 이름을 IP 주소로 변환하는 시스템입니다.

1. **_주요 기능_**

   1. **도메인 이름 해석**(이름을 IP로 변환)

   2. **주소 캐싱**(자주 요청되는 이름과 IP 주소 쌍을 캐싱)

   3. **부하 분산**(여러 IP 주소를 도메인 이름에 매핑)

2. **_DNS의 구조_**

   1. **DNS 리졸버**(도메인 이름을 IP 주소로 변환하는 역할)

   2. **루트 DNS 서버**(최상위 DNS 서버, 특정 도메인의 네임 서버에 대한 정보 제공)

   3. **TLD(최상위 도메인)(Top-Level-Domain) 서버**(특정 도메인(.com, .org 등)에 대한 정보 저장)

   4. **권한 있는 네임 서버**(특정 도메인에 대한 IP 주소와 관련된 정보를 저장)

## 웹 프로토콜 및 응용

### RESTful API

Restful API는 Representational State Transfer(REST) 원칙을 따르는 웹 서비스 인터페이스입니다.(클라이언트-서버 아키텍처)

1. **자원(Resource)**

   URI(하나의 리소스를 가리키는 문자열)를 사용하여 자원을 식별합니다.

2. **HTTP 메서드**

   1. **GET**(조회)

   2. **POST**(생성)

   3. **PUT**(전체 갱신)

   4. **PATCH**(부분 갱신)

   5. **DELETE**(삭제)

3. **상태 비저장성(Stateless)**

   REST API의 각 요청은 독립적이며, 서버는 클라이언트의 상태를 저장하지 않습니다.

4. **표현(Representation)**

   자원은 다양한 형식(예: JSON, XML)으로 표현될 수 있습니다.

5. **캐싱(Caching)**

   응답 캐시

6. **계층화(Layered System)**

   여러 계층으로 구성될 수 있으며, 클라이언트는 중간 서버의 존재를 알지 못합니다.

### OSI 7계층

OSI 7계층(Open Systems Interconnection model)은 네트워크 통신을 표준화하기 위해 제안된 개념적 모델입니다.

1. **물리 계층 (Physical Layer)**

   - **역할**: 전기적, 기계적, 절차적 특성을 정의하여 실제 데이터를 전송하는 계층입니다.

   - **예시**: 케이블, 리피터, 허브, 전기 신호 등

2. **데이터 링크 계층(Data Link Layer)**

   - **역할**: 물리적 네트워크에서 데이터의 오류 감지 및 수정, 그리고 MAC 주소를 사용한 노드 간의 데이터 전송을 담당합니다.

   - **예시**: 이더넷, Wi-Fi, PPP(점대점 프로토콜)

3. **네트워크 계층 (Network Layer)**

   - **역할**: 데이터 패킷의 경로 설정 및 전달을 담당하며, 논리적 주소(예: IP 주소)를 사용하여 네트워크 간 통신을 가능하게 합니다.

   - **예시**: IP(인터넷 프로토콜), ICMP(인터넷 제어 메시지 프로토콜)

4. **전송 계층 (Transport Layer)**

   - **역할**: 종단 간 (end-to-end) 통신을 관리하며, 데이터의 전송 오류를 감지하고 복구합니다. 흐름 제어 및 세분화된 데이터 전송도 지원합니다.

   - **예시**: API(응용 프로그램 프로그래밍 인터페이스), 소켓

5. **세션 계층 (Session Layer)**

   - **역할**: 통신 세션을 관리하고, 세션의 생성, 유지 및 종료를 담당합니다. 데이터 교환의 동기화도 지원합니다.

   - **예시**: API(응용 프로그램 프로그래밍 인터페이스), 소켓

6. **표현 계층 (Presentation Layer)**

   - **역할**: 데이터의 형식과 표현을 변환하여 서로 다른 시스템 간의 데이터 호환성을 보장합니다. 데이터 압축 및 암호화도 이 계층에서 수행됩니다.

   - **예시**: JPE6, GIF, ASCII

7. **응용 계층 (Application Layer)**

   - **역할**: 최종 사용자가 직접 사용하는 응용프로그램과 네트워크 간의 인터페이스를 제공합니다. 사용자와 네트워크의 상호작용을 처리합니다.

   - **예시**: HTTP, FTP, SMTP, DNS

### TCP/IP 4계층 및 5계층 모델

TCP/IP 모델은 인터넷과 같은 네트워크에서 데이터 통신을 위한 프로토콜을 정의하는 구조.

- **TCP/IP 4계층 모델**

  1.  **네트워크 인터페이스 계층(Network Interface Layer)**

      - **역할**: 물리적 네트워크에서 데이터 전송을 담당하며, 하드웨어와 관련된 데이터 링크 및 물리적 전송을 포함합니다.

      - **예시**: Ethernet, Wi-Fi, ARP(Address Resolution Protocol)

  2.  **인터넷 계층 (Internet Layer)**

      - **역할**: 데이터 패킷의 주소 지정 및 라우팅을 담당합니다.

      - **예시**: IP (Internet Protocol),
        ICMP (Internet Control Message Protocol)

  3.  **전송 계층 (Transport Layer)**

      - **역할**: 종단 간 데이터 전송을 관리하며, 신뢰성, 흐름 제어 및 오류 검출을 제공합니다.

      - **예시**: TCP (Transmission Control Protocol), UDP (User Datagram Protocol)

  4.  **응용 계층 (Application Layer)**

      - **역할**: 최종 사용자와의 상호작용을 처리하며, 애플리케이션 프로토콜을 포함합니다.

      - **예시**: HTTP, FTP, SMTP, DNS

  - **TCP/IP 5계층 모델**

    1. **물리 계층(Physical Layer)**

       - **역할**: 전기적 신호, 케이블 및 하드웨어와 관련된 요소를 다룹니다.

    2. **데이터 링크 계층(Data Link Layer)**

       - **역할**: 물리적 네트워크의 데이터 전송 및 오류 감지를 담당합니다.

    3. **인터넷 계층 (Internet Layer)**

       - **역할**: 데이터 패킷의 주소 지정 및 라우팅을 담당합니다.

    4. **전송 계층 (Transport Layer)**

       - **역할**: 종단 간 데이터 전송을 관리하며, 신뢰성, 흐름 제어 및 오류 검출을 제공합니다.

    5. **응용 계층 (Application Layer)**

       - **역할**: 최종 사용자와의 상호작용을 처리하며, 애플리케이션 프로토콜을 포함합니다.

### TCP, UDP

1. **TCP (Transmission Control Protocol)**

   1. **연결 지향**(데이터 전송 전에 연결 설정)

   2. **신뢰성**(데이터 손실 확인)

   3. **순서 보장**

   4. **흐름 제어**

   5. **사용 예**(웹 페이지 로딩, 파일 전송, 이메일 등)

2. **UDP (User Datagram Protocol)**

   1. **비연결 지향**

   2. **신뢰성 없음**

   3. **순서 보장 없음**

   4. **흐름 제어 없음**

   5. **사용 예**(실시간 게임, 비디오 스트리밍, 음성 통화(VoIP) 등)

3. **요약**

   - **TCP**: 신뢰성과 순서 보장이 필요한 데이터 전송에 적합합니다.

   - **UDP**: 빠른 전송 속도가 필요한 경우에 적합합니다.

### 웹 프로토콜

웹에서 클라이언트와 서버 간의 통신을 정의하는 규칙과 규약의 집합입니다.

1. **주요 웹 프로토콜**

   1. **HTTP (Hypertext Transfer Protocol)**

      가장 널리 사용되는 웹 프로토콜, 요청-응답 모델.

   2. **HTTPS (Hypertext Transfer Protocol Secure)**

      HTTP의 보안 버전, SSL/TLS 프로토콜 사용.

   3. **FTP (File Transfer Protocol)**

      클라이언트와 서버 간의 파일 전송 및 관리를 지원, 사용자 인증(로그인) 기능을 제공한다.

   4. **SFTP (SSH File Transfer Protocl)**

      SSL(Secure Shell) 프로토콜을 사용하여 안전한 파일 전송을 지원합니다.

   5. **IMAP (Internet Message Access Protocol)**

      이메일 클라이언트가 서버에 저장된 이메일에 접근하고 관리할 수 있도록 하는 프로토콜이다. 메일이 남기에 여러 디바이스에서 확인 가능.

   6. **POP3(Post Office Protocol version 3)**

      이메일 클라이언트가 서버에서 이메일을 다운로드하여 로컬로 저장하는 프로토콜입니다. 이메일 다운 후 서버에서 삭제된다.

2. **웹 프로토콜의 중요성**

   - **상호운용성**(다양한 클라이언트와 통신 가능)

   - **보안**

   - **성능**

### HTTP들의 버전

1. **_HTTP/1.1_**

   - **_출시 연도_**: 1999년

   - **_주요 특징_**:

     1. **지속적 연결**(여러 요청과 응답을 하나의 TCP 연결에서 처리 가능)

     2. **요청/응답 다양한 헤더**

     3. **Chunked 전송 인코딩**(데이터를 여러 조각(chunk)로 나누어 전송 가능)

     4. **HTTP 캐시**(미리 받아온 데이터 저장 가능)

   - **_단점_**

     1. **헤드 오버로드**(매 요청마다 TCP 연결 설정)

     2. **동시성**(여러 요청에 다수의 TCP 연결 생성 필요)

2. **_HTTP/2_**

   - **_출시 연도_**: 2015년

   - **_주요 특징_**:

     1. **이진 프로토콜**(이전은 문자열, 해당 버전에선 이진 형식)

     2. **멀티 플렉싱**

     3. **서버 푸시**(서버는 클라이언트의 요청 없이도 필요한 자원을 미리 전송(css,js 등))

     4. **헤더 압축**(HPACK)

     5. **지속적 연결**

   - **_단점_**:

     1. **복잡성**

     2. **TCP 사용**(여전히 TCP)

3. **_HTTP/3_**

   - **_출시 연도_**: 2020년

   - **주요 특징**:

     1. **QUIC 프로토콜**(UDP 기반 프로토콜)

     2. **무연결성**(각 요청은 독립적이므로 다른 요청에서 패킷이 손실되도 지장없이 동작)

     3. **0-RTT 연결**(이전에 연결된 클라이언트는 연결 설정 없이 데이터 즉시 전송 가능)

     4. **내장 암호화**(QUIC은 모든 데이터 암호화)

     5. **멀티플렉싱 및 헤더 압축**(이전 버전 기능)

   - **단점**:

     1. **UDP 기반**(패킷 손실 시 재전송 방식이 TCP와 다르게 동작할 가능성)

     2. **서버 지원 필요**(HTTP/3를 지원하는 웹 서버가 적다)

4. **요약**

   1. **HTTP/1.1**: 텍스트 기반, 요청/응답 모델, 다수의 연결 필요.

   2. **HTTP/2**: 이진 프로토콜, 멀티 플렉싱, 서버 푸시, 헤더 압축.

   3. **HTTP/3**: QUIC 기반, 무연결성, 0-RTT 지원, 내장 암호화.

### SSL/TLS

SSL("Secure Sockets Layer")과 TLS("Transport Layer Security")는 인터넷에서 데이터 전송 시 보안을 제공하는 프로토콜입니다. SSL은 초기 버전, TLS는 후기 버전입니다.

1. **목적**

   데이터 암호화, 인증 및 무결성 보장.

2. **SSL과 TLS의 관계 및 성능**

   1. **TLS는 SSL의 후속 프로토콜**(실제로 TLS 1.0은 SSL 3.0의 개선 버전으로 간주. 같이 묶어 불리는 경우가 많습니다)

   2. **성능 개선**:

      - 암호화 및 복호화 과정 최적화, 성능 향상. TLS 1.2와 TLS 1.3은 특히.

      - TLS 1.3에서는 핸드쉐이크 과정이 간소화되었습니다.

   3. **HTTP/3와의 통합**:

      HTTP/3는 QUIC 프로토콜을 사용하며, QUIC는 TLS 1.3을 내장하고 있다.

### 웹 보안

1. **HTTPS 사용**(SSL/TLS)

2. **인증 및 권한 부여**(강력한 비밀번호 정책과 다단계 인증)

3. **입력 검증**(사용자 입력 검증으로 SQL 인젝션, 크로스 사이트 스크립팅(XSS) 등의 공격 방지)

4. **정기적인 업데이트**(알려진 취약점 차단)

5. **백업 및 복구 계획**

6. **방화벽 및 IDS/IPS**

### MFA(Multi-Factor Authentication)

- **정의**: 사용자가 로그인할 때 두 개 이상의 인증 요소를 요구하는 방식입니다.

- **요소**

  1.  **지식 기반**

  2.  **소지 기반**

  3.  **고유 기반**(생체 정보)

### IDS/IPS (Intrution Detection System / Intrution Prevention System)

1. **정의**:

   - **IDS**: 네트워크 또는 시스템에서 비정삭적인 활동이나 침입 시도를 감지하는 시스템입니다.

   - **IPS**: IDS의 기능에 추가로, 감지된 공격을 차단하는 기능을 갖춘 시스템입니다.

2. **기능**:

   - **IDS**: 로그 모니터링, 알림 전송 등으로 공격을 경고합니다.

   - **IPS**: 실시간으로 공격을 차단하고, 네트워크 트래픽을 분석하여 위협을 방지합니다.

### HTTP와 HTTPS의 차이

보안, HTTP는 데이터 암호화가 없지만, HTTPS는 SSL/TLS 프로토콜을 사용하여 데이터를 암호화한다.

### HTTP 상태 코드

HTTP 상태 코드는 클라이언트의 요청에 대한 서버의 응답 상태를 나타내는 3자리 숫자 코드입니다.

1. **_정보 응답 (1XX)_**

   - **100 Continue**(요청 계속 가능)

   - **101 Switching Protocols**(클라이언트 요청에 맞춰 프로토콜 변경)

2. **_성공 응답(2XX)_**

   - **200 OK**(요청 성공)

   - **201 Created**(요청 성공, 자원 생성)

   - **202 Accepted**(요청 접수, 아직 완료X)

   - **204 No Content**(요청 성공, 반환 내용없음)

3. **_리다이렉션(3XX)_**

   - **300 Mutiple Choices**(요청 자원이 여러 개, 클라이언트의 선택 필요)

   - **301 Moved Permanetly**(영구적인 URL 리다이렉션)

   - **302 Found**(임시적인 URL 리다이렉션)

   - **304 Not Modified**(요청된 자원이 수정X)

4. **_클라이언트 오류 (4XX)_**

   - **400 Bad Request**(잘못된 요청)

   - **401 Unauthorized**(인증 필요 혹은 실패)

   - **403 Forbidden**(요청 이해, 서버가 거부)

   - **404 Not Found**(자원 없음)

   - **405 Method Not Allowed**(요청한 HTTP 메서드 지원X)

   - **408 Request Timeout**(요청 시간 초과)

5. **서버 오류 (5XX)**

   - **500 Internal Server Error**(서버 내부 오류)

   - **501 Not Implemented**(서버가 기능을 지원 X)

   - **503 Service Unavailable**(서버가 과부하 혹은 유지보수 중)

   - **504 Gateway Timeout**(게이트웨이가 타임아웃)

### 3-Way-HandShake 및 4 Way-HandShake

1. **3-Way-HandShake (연결 설정)**(TCP 연결 설정)

   1. **SYN**: SYN(세그먼스 시작) 패킷 전송, 클라이언트의 초기 시퀸스 번호 포함.

   2. **SYN-ACK**: 서버에서 응답으로 SYN-ACK 패킷 전송, 서버의 초기 시퀸스 번호와 클라이언트의 시퀸스 번호를 확인하기 위한 ACK 포함.

   3. **ACK**: 연결 확인의 ACK 패킷 전송, 완료.

2. **4-Way HandShake (연결 종료)**

   1. **FIN**: 클라이언트에서 FIN(종료) 패킷 전송.

   2. **ACK**: 서버 FIN 패킷 수신, 서버에서 응답으로 ACK 패킷 전송, 클라이언트에서 서버로의 데이터 전송 종료.

   3. **FIN**: 서버에서 FIN 패킷 전송, 서버에서 클라이언트로의 데이터 전송 종료 의사.

   4. **ACK**: 클라이언트 FIN 패킷 수선, 클라이언트 종료 요청 확인으로 ACK 패킷 전송. 연결은 종료.

### 세션 기반 인증과 토큰 기반 인증

웹 애플리케이션에서 사용자의 인증을 처리하는 방법.

- **세션 기반 인증**

  1.  **서버 저장 방식**(세션)

  2.  **상태 유지**(여러 요청 사이에서도 상태 유지)

  3.  **보안**(서버 저장으로 유리함, 대신 세션 하이재킹 등의 공격엔 취약)

  4.  **확장성 나쁨**(여러 서버가 필요하면, 세션을 공유하는 추가 작업 필요)

- **토큰 기반 인증**

  1.  **클라이언트 저장 방식**(클라이언트면 로컬 스토리지나 쿠키나 상관X)

  2.  **상태 비유지**

  3.  **보안**(만료 시간과 서명, CSRF(Cross-Site Request Forgery)와 같은 공격에 취약)

  4.  **확장성 좋음**(클라이언트 저장)

### google.com을 입력했을 때

1. **URL 입력 및 브라우저 처리**(URL 해석 및 HTTP 요청 생성)

2. **DNS 조회**(DNS 리졸버에 요청, DNS 리졸버는 캐시, 루트 DNS 서버, TLD 서버, 권한 있는 서버 순으로 도메인의 IP 주소를 찾는다)

3. **TCP 연결 설정**(3-way handShake 포함)

4. **HTTP 요청 전송**

5. **서버 처리 및 응답**(서버에서 HTML, CSS, JS를 포함한 콘텐츠를 가진 페이지를 HTTP 응답으로 브라우저로 전송.)

6. **페이지 렌더링**(렌더링한 후 페이지 표시)

7. **추가 리소스 요청**(이미지나 스크립트 등 추가적인 리소스 필요시 요청)

수 밀리 초 안에 일어난다.

### 크로스 브라우징

크로스 브라우징은 웹 애플리케이션이나 웹 사이트가 다양한 클라이언트에서 일관되게 작동하고, 동일한 UX를 제공하는 것을 의미합니다.

1. **_주요 요소_**

   1. **호환성**(각 브라우저는 표준이 다를 수 있으므로, 고려 필요)

   2. **디자인**(브라우저별로 CSS의 렌더링이 다를 수 있다.)

   3. **기능성**(JS 기능이나 API 사용이 브라우저마다 다를 수 있다.)

2. **크로스 브라우징을 고려해야 하는 이유**

   1. **사용자 경험**

   2. **접근성**(다양한 디바이스로 이용 가능)

   3. **시장 점유율**(다양한 브라우저의 사용자층 섭렵 가능)

3. **크로스 브라우징 문제 해결 방법**

   1. **CSS 리셋 및 Normalize**

   2. **폴리필(Polyfill)**(기능 추가)

   3. **브라우저 테스트**

   4. **프레임워크 및 라이브러리 사용**(React, Angular, Vue.js와 같은 프레임워크 및 라이브러리는 호환성을 잘 처리)

### 웹 접근성

웹 접근성(Web Accessibility)은 장애인과 비장애인을 포함한 모든 사용자가 웹 콘텐츠에 접근하고 사용할 수 있도록 보장하는 개념입니다.

1. **주요 요소**

   1. **장애 유형**

   2. **사용자 유형**(모바일, 느린 인터넷, 다양한 브라우저)

2. **웹 접근성의 중요성**

   1. **포괄적인 사용자 경험**(사용자수 증가)

   2. **법적 요구사항**(미국의 ADA(American with Disabilities Act) 등)

   3. **사회적 책임**

3. **웹 접근성을 위한 원칙**

   1. **명확성(Perceivable)**(모든 콘텐츠는 인식 가능해야 합니다. 예를 들어, 이미지에는 대체 텍스트를 통해 시각 장애인이 내용을 알 수 있도록 합니다.)

   2. **운용 가능성(Operable)**(키보드로도 접근 가능해야 합니다.)

   3. **이해 가능성(Understandable)**(정보와 인터페이스는 이해하기 쉬워야 합니다.)

   4. **견고성 (Robust)**(다양한 사용자 에이전트(브라우저, 스크린 리더 등)에서 잘 작동해야 합니다.)

4. **웹 접근성을 높이기 위한 방법**

   1. **적절한 HTML 사용**(의미론적 HTML 사용)

   2. **대체 텍스트 제공**

   3. **키보드 네비게이션 지원**(키보드로 접근가능하도록 작성)

   4. **명확한 색상 대비**(시각적으로 약한 사용자도 쉽게 읽을 수 있도록 작성)

   5. **사용자 피드백 요청**(실제 사용자에게 접근성 테스트)

### JWT

JWT(제이슨 웹 토큰, JSON Web Token)는 인증 및 정보 교환을 위해 사용되는 개방형 표준(RFC7519)입니다.

1. **_주요 구성 요소_**

   1. **헤더(Header)**(토큰의 유형, 서명 알고리즘 정의)

   2. **페이로드(Payload)**(실제 데이터, 클레임(사용자 정보, 토큰의 만료 시간 등) 정보 포함)

   3. **서명(Signature)**(헤더와 페이로드 조합 후 비밀 키로 서명, 무결성 보장)

header.payload.signature
각 부분은 Base64Url로 인코딩.

2. **장점**

   1. **자체 포함형**(JWT엔 모든 정보가 있어, 세션 필요 X)

   2. **확장성 좋음**

   3. **다양한 플랫폼 지원**(프로그래밍 언어나 플랫폼에 구애 X)

3. **사용 사례**

   1. **인증**

   2. **정보 교환**

4. **보안 고려사항**

   - **비밀키 관리 주의**

   - **만료 시간 설정 권장**

### 대칭 비밀 키 암호화와 비대칭 키 암호화 방식

- **_대칭 비밀 키 암호화 (Symmetric Key Encryption)_**

  1.  **_정의_**: 암호화와 복호화에 동일한 키를 사용하는 방식.

  2.  **_장점_**

      - **속도 빠름**

      - **간단한 구현**

  3.  **단점**

      - **키 분배 문제**(암호화와 복호화에서 같은 키 사용으로 안전하게 키 공유 및 관리 어려움)

      - **확장**(사용자 수가 많아지면 키 관리가 복잡해짐, 수많은 비밀키를 각 개인이 소유해야 함)

  4.  **예시 알고리즘**(AES(고급 암호화 표준), DES(데이터 암호화), Blowfish 등)

- **비대칭 키 암호화 (Asymmetric Key Encryption)**

  1.  **정의**: 암호화와 복호화에 다른 키를 사용하는 방식.(공개키, 비밀키)

  2.  **장점**

      - **키 분배 용이**(공캐 키, 비밀 키로 암호화와 복호화의 키 분리)

      - **디지털 서명**(비밀키의 존재 덕분)

  3.  **단점**

      - **속도 느림**

      - **복잡성**

  4.  **예시 알고리즘**: RSA, DSA(디지털 서명 알고리즘), ECC(타원 곡선 암호화) 등.

### 퍼블릭 IP와 프라이빗 IP

- **_퍼블릭 IP (Public IP)_**

  1. **_정의_**

     - 퍼블릭 IP는 인터넷에 연결된 장치가 어디서나 접근 가능한 주소입니다.

     - 인터넷 서비스 제공업체(ISP)에 의해 할당됩니다.

  2. **_특징_**

     - **고유성**

     - **접근 가능성**(인터넷의 다른 장치와 모두 연결가능)

     - **변경 가능성**(ISP에 따라 주기적으로 변경가능)

  3. **사용 예**: 웹 서버, 이메일 서버 등

- **_프라이빗 IP (Private IP)_**

  1.  **_정의_**:특정 네트워크에서만 사용되는 주소.

  2.  **_특징_**

      - **비고유성**(다른 네트워크에서 사용가능)

      - **제한된 범위**: RFC 1918에 정의된 특정 IP 범위 내에서만 사용 가능합니다.

        - **클래스 A**: 10.0.0.0 ~ 10.255.255.255

        - **클래스 B**: 172.16.0.0 ~ 172.31.255.255

        - **클래스 C**: 192.168.0.0 ~ 192.168.255.255

      - **NAT 사용**(인터넷 접근 시, NAT를 통해 퍼블릭 IP로 전환)

  3.  **사용 예**: 가정이나 회사의 로컬 네트워크 내의 컴퓨터, 스마트폰, 프린터 등.

### ISP(Internet Service Provider)

인터넷 접속 서비스를 제공하는 회사나 기관을 의미합니다.

1. **_주요 기능과 서비스_**

   1. **인터넷 접속**(DSL, 케이블, 광섬유, 위성 등으로 제공)

   2. **도메인 등록**(도메인 이름을 등록하고 관리합니다.)

   3. **호스팅 서비스**(고객이 인터넷에서 콘텐츠를 서비스할 수 있도록 지원합니다.)

   4. **기술 지원**(인터넷 연결 문제, 장비 설정 등의 기술 지원을 제공합니다.)

   5. **보안 서비스**(방화벽, VPN(가상 사설망), 안티바이러스 솔루션 등)

2. **_ISP의 종류_**

   1. **전국 ISP**(대규모 네트워크를 운영, 전국적으로 서비스 제공.)

   2. **지역 ISP**(특정 지역에 집중, 지역 사회의 특성에 맞춘 서비스와 지원을 제공.)

   3. **전문 ISP**(특정 서비스에 집중하는 업체, 해당 서비스에서 전문적인 서비스를 제공.)

### IPv4, IPv6의 차이

IPv4(인터넷 프로토콜 버전 4), IPv6(인터넷 프로토콜 버전 6)는 둘 다 인터넷에서 장치 간 통신을 위해 사용하는 두 가지 IP 주소 체계입니다.

1. **_주소 형식_**

   - **IPv4**: 32 비트 주소 체계, 4개의 10진수로 구분된 숫자로 구성, 2^32개의 IP주소

   - **IPv6**: 128 비트 주소 체계, 8개의 16진수로 구분된 숫자로 구성, 2^128개의 IP주소

2. **_주소 공간_**

   - **IPv4**:주소가 적어, 고갈되어 갑니다.

   - **IPv6**:주소가 상대적으로 많아, IP 주소 고갈 문제를 해결가능합니다.

3. **_헤더 구조_**

   - **IPv4**: 헤더가 복잡하고 가변적인 필드 탓에, 처리 속도가 느릴 수 있습니다.

   - **IPv6**: 헤더가 간소화되었고, 필드 수가 줄어 라우팅과 패킷 처리 효율이 높아졌습니다.

4. **_NAT(Network Address Translation)_**

   - **IPv4**: IP 주소 고갈 문제 해결을 위한 NAT 사용, 여러 장치가 하나의 퍼블릭 IP 주소를 공유합니다.

   - **IPv6**: IP 주소가 많아, NAT의 필요성이 적다.

5. **_보안_**

   **IPv4**: 보안 기능이 선택 사항이며, 보안이 강화된 프로토콜의 필요성이 크다.

   **IPv6**: IPSec을 기본적으로 내장하고 있다.

6. **_멀티캐스트와 기타 기능_**

   **IPv4**: 멀티캐스트 기능이 지원하지만, 범위와 유용성에 제한이 있습니다.

   **IPv6**: 멀티캐스트, Anycast 등 다양한 통신 방식이 내장되어 있습니다.

### IPSec

IPSec(Internet Protocol Security)은 인터넷 프로토콜(IP) 통신의 보안을 제공하기 위해 설계된 프로토콜 집합입니다.

1. **_주요 특징 및 구성 요소_**

   1. **가능**

      - **기밀성**(데이터 암호화)

      - **무결성**

      - **인증**(데이터 출처 확인)

   2. **구성 요소**

      - **AH(Authentication Header)**(데이터의 인증과 무결성만 제공. 원본 인증, 변조 확인.)

      - **ESP(Encapsulating Security Payload)**(데이터의 인증과 무결성, 기밀성을 제공. 데이터 암호화, 인증 정보 추가.)

   3. **모드**

      - **전송 모드(Transport Mode)**(IP 패킷의 페이로드만 암호화, 주로 호스트 간의 통신에 사용.)

      - **터널 모드 (Tunnel Mode)**(전체 패킷을 암호화하여 새로운 IP 헤더를 추가, 주로 두 네트워크 간의 VPN 연결에 사용.)

   4. **키 관리**

      - IKE(Internet Key Exchange) 프로토콜을 사용합니다. IKE는 보안 연결을 설정하고, 암호화 키를 교환합니다.

2. **_사용 사례_**

   - **VPN**(원격 사용자가 안전하게 기업 네트워크에 접속할 수 있도록 하는 데 주로 사용.)

   - **데이터 보호**

### OAuth

OAuth(오픈 인증, Open Authorization)은 사용자 인증 및 권한 부여를 위한 프로토콜로, 사용자 정보를 안전하게 공유할 수 있도록 설계되었습니다.

1. **_주요 특징_**

   1. **권한 부여**

      OAuth는 사용자(자원 소유자)가 자신의 자원에 대한 접근을 특정 애플리케이션(클라이언트)에 허용하는 메커니즘을 제공합니다.

   2. **토큰 기반**

      OAuth는 사용자 인증 후에 권한 부여 토큰을 발급하며, 해당 토큰을 통해 애플리케이션이 자원에 접근할 수 있도록합니다.

   3. **스코프**

      사용자가 애플리케이션에 권한을 부여할 때, 특정 자원이나 작업에 대한 접근 범위를 지정할 수 있습니다.

2. **_다양한 플로우_**

   - **Authorization Code Grant**(서버 간의 안전한 통신을 위해 주로 사용.)

   - **Implicit Grant**(주로 웹 브라우저 기반의 애플리케이션에서 사용)

   - **Resource Owner Password Credentials Grant**(사용자가 직접 비밀번호를 입력하여 권한을 부여.)

   - **Client Credentials Grant**(서버 간의 통신에서 사용.)

3. **사용 사례**

   - **소셜 로그인**

   - **API 접근**

### 서드파티

서드파티라는 용어는 거래나 계약, 서비스에 관련된 세 주체를 의미합니다.

1. **주체 간의 관계**

   - **제1자 (First Party)**(사용자.)

   - **제2자 (Second Party)**(공급자나 서비스 제공자.)

   - **서드파티(Third Party)**(외부 주체, 독립적인 서비스나 기능을 제공하는 업체.)

2. **예시**

   - **소프트웨어**

   - **결제 시스템**

   - **애드온 및 플러그인**

3. **장점과 단점**

   - **장점**: 개발 시간 단축, 기능 확장에 유리.

   - **단점**: 보안이나 안정성 불안, 서드파티 서비스의 정책 변화나 서비스 중단 고려필요.

### WAS

WAS(Web Application Server, 웹 애플리케이션 서버)는 웹 어플리케이션을 실행하고 관리하는 서버입니다.

1. **주요 기능**

   1. **애플리케이션 실행**

   2. **비즈니스 로직 처리**

   3. **세션 관리**

   4. **통신 프로토콜 지원**

   5. **로드 밸런싱 및 확장성**

   6. **보안 기능**

2. **예시**

   - **JAVA 기반 WAS**

   - **.NET 기반 WAS**

   - **js 기반 WAS**: Node.js, Express.js, NestJS, koa.js 등

### WS

웹 서비스의 약자로, 웹 서비스는 서로 다른 애플리케이션 간에 데이터를 전송하고 상호작용할 수 있도록 해주는 소프트웨어 시스템입니다.

1. **_주요 특징_**

   1. **인터넷 기반**(다양한 플랫폼과 언어에서 호환이 가능)

   2. **표준 프로토콜**(SOAP(Simple Object Access Protocol)나 REST(Representational State Transfer)와 같은 표준 프로토콜을 사용.)

      - **SOAP**: XML 기반의 메시지 프로토콜, 보안성이 중요시되는 애플리케이션에서 사용합니다.

      - **REST**: HTTP 프로토콜을 기반으로 하며, JSON, XML 등을 사용하여 데이터를 전송합니다.

   3. **서비스 지향 아키텍처(SOA)**: 웹 서비스는 SOA의 중요한 구성 요소, 독립적으로 개발된 서비스들이 상호작용하여 더 큰 시스템을 구성합니다.

   4. **상호 운용성**: 웹 서비스는 서로 다른 시스템과 플랫폼 간의 상호 운용성을 지원한다.

2. **_사용 사례_**

   - **API 제공**

   - **비즈니스 통합**

   - **모바일 애플리케이션**

## _코딩_

## 콜백함수

### AJAX

AJAX는 Asynchronous JavaScript and XML의 약자로, 웹 페이지를 비동기적으로 업데이트할 수 있도록 해주는 기술입니다.

1. **AJAX의 주요 특징**

   1. **비동기성**(클라이언트가 서버에 요청을 보내는 동안 웹 페이지가 멈추지 않고 사용자와 상호작용.)

   2. **부분 업데이트**(웹페이지의 일부만 업데이트 가능.)

   3. **다양한 데이터 형식 지원**(다양한 데이터 형식을 지원하지만, 특히 JSON은 데이터 전송 형식으로 많이 사용하고 JS와 호환성이 높다.)

   4. **비동기 요청**(AJAX는 JS의 XMLHttpRequest 객체를 사용하여 서버에 비동기적으로 요청을 보냅니다)

2. **AJAX의 동작 방식**

   1. **사용자 인터페이스 이벤트**(이벤트 발생)

   2. **AJAX 요청 생성**(JS를 사용하여 XMLHttpRequest 객체를 생성, 서버에 비동기 요청)

   3. **서버 처리**(서버가 처리 및 응답)

   4. **응답 처리**(클라이언트 응답 받고, JS로 특정 부분 업데이트)

3. **AJAX의 장점**

   1. **빠른 사용자 경험**(부분 업데이트 장점)

   2. **서버와의 효율적인 데이터 통신**(필요한 데이터만 요청 가능)

   3. **인터렉티브한 웹 애플리케이션**(실시간 업데이트가 가능한 동적인 웹 애플리케이션 작성가능)

4. **AJAX의 단점**

   1. **SEO 문제**(CSR의 문제점과 동일)

   2. **브라우저 호환성**(구식 브라우저와의 호환성 문제)

   3. **복잡성 증가**

### 동기와 비동기

통신에서 동기(Synchronous)와 비동기(Asynchronous) 처리는 데이터 전송 및 응답을 처리하는 방식에 대한 개념입니다.

1. **동기(Synchronous)**

   - **정의**: 요청을 보낸 후, 응답을 받을 때까지 기다리는 방식.

   - **특징**: 코드의 흐름이 요청과 응답에 따라 직선적으로 진행됩니다. UI가 정지될 수 있습니다. 구현이 간단하고 이해하기 쉬운 경우가 많습니다.

   - **예시**: JS의 XMLHttpRequest 사용

2. **비동기(Asynchronous)**

   - **정의**: 요청을 보낸 후, 응답을 기다리지 않고 수행하는 방식입니다.(콜백, 프로미스)

   - **특징**: 코드의 흐름이 요청과 응답과 독립적입니다. 부분 업데이트로 UX의 향상이 가능, 비즈니스 로직을 구현에 유용하다.

### async/await 외의 비동기 처리 방법

- **Promise**

  JavaScript의 비동기 처리 방법. then, catch, finally 메서드 이용.

- **콜백 함수**

  비동기 작업이 완료된 후 호출되는 함수를 정의하여 결과를 처리합니다. 콜백 헬은 주의해야 합니다.

- **RxJS**

  Reactive Programming 라이브러리로, 스트림을 통해 비동기 데이터를 처리할 수 있습니다.

- **EventEmitter**

  Node.js의 이벤트 기반 프로그래밍 패턴을 사용하여 이벤트가 발생할 때 비동기 처리를 수행할 수 있습니다.

### RXJS

RXJS (Reactive Extenstions for JavaScript)는 비동기 데이터 흐름을 처리하기 위한 라이브러리로, 옵저버블 패턴을 사용하여 데이터를 스트림 형태로 다룹니다.

1. **주요 개념**

   1. **옵저버블 (Observable)**

      데이터 스트림을 나타내며, 데이터를 발행하는 주체입니다.

   2. **옵저버 (Observer)**

      옵저버블을 구독하고, 데이터가 발행될 때마다 알림을 받는 객체입니다.

   3. **구독 (Subscription)**

      옵저버블을 구독하는 행위로, 데이터가 발행되면 콜백이 실행됩니다.

   4. **연산자 (Operators)**

      옵저버블을 변환하거나 조작하는 함수들입니다. 예를 들어, map, filter, merge, switchMap 등의 연산자가 있습니다.

2. **기본 사용법**

   ```bash
   npm install rxjs
   ```

   ```js
   import { Observable } from "rxjs";

   // 옵저버블 생성
   const myObservable = new Observable((subscriber) => {
     subscriber.next("Hello");
     subscriber.next("World");
     subscriber.complete();
   });

   const myObserver = {
     next: (value) => console.log(value),
     error: (err) => console.error(err),
     complete: () => console.log("Done"),
   };

   // 옵저버블 구독
   myObservable.subscribe(myObserver);
   ```

3. **연산자 사용 예제**

   ```js
   import { of } from "rxjs";
   import { map, filter } from "rxjs/operators";

   const number = of(1, 2, 3, 4, 5);

   // 연산자를 사용한 예제
   const processedNumbers = numbers.pipe(
     filter((x) => x % 2 === 0), // 짝수만 통과
     map((x) => x * 10) // 각 숫자에 10 곱하기
   );

   processedNumbers.subscribe(console.log); // 20, 40
   ```

4. **장점**

   1. **콜백 지옥 회피와 간소화된 코드**

   2. **연산자 체이닝을 통한 간단한 구성 가능성**

   3. **다양한 데이터 소스를 통합, 응답성 유지**

### 데이터의 스트림 형태

데이터의 스트림 형태는 데이터를 연속적으로 생성하고 처리하는 방식을 나타냅니다.

1. **_스트림의 기본 개념_**

   1. **스트림**

      데이터의 연속적인 흐름을 나타냅니다. 스트림은 시간에 따라 변화하는 데이터 시퀸스를 의미합니다.

   2. **발행자 (Publisher)**

      데이터를 생성하고 스트림에 발행하는 주체입니다. 이는 옵저버블 형태로 구현됩니다.

   3. **구독자 (Subscriber)**

      스트림의 데이터를 소비하고 반응하는 주체입니다. 구독자는 발행자가 발행하는 데이터에 대해 반응합니다.

   4. **변환 및 조작**

      스트림의 데이터를 변환하거나 필터링하는 연산자들이 사용됩니다.

2. **_스트림의 종류_**

   1. **단방향 스트림**: 데이터가 한 방향으로만 흐릅니다.(클릭, 입력 등)

   2. **양방향 스트림**: 데이터가 양 방향으로 흐를 수 있습니다.(웹 소켓 통신)

3. **_스트림 처리의 장점_**

   1. **비동기 처리**

   2. **조합 가능성**(여러 데이터 소스를 하나의 스트림으로 결합 가능)

   3. **지연 평가**(필요할 때만 데이터를 처리할 수 있다.)

4. **예시**

   ```js
   import { fromEvent } from "rxjs";
   import { map } from "rxjs/operators";

   // 버튼 클릭 이벤트 스트림 생성
   const button = document.getElementById("myButton");
   const clicks = fromEvent(button, "click");

   // 클릭 이벤트를 처리하여 좌표를 로그에 남김
   const positions = clicks.pipe(
     map((event) => ({ x: event.clientX, y: event.clientY }))
   );

   positions.subscribe((pos) => console.log(`X: ${pos.x}, Y: ${pos.y}`));
   ```

   이벤트로 클릭할 때마다 데이터(좌표) 발행.

### Promise

Promis는 JavaScript에서 비동기 작업을 처리하기 위한 객체입니다. 주로 비동기 연산의 성공 또는 실패 결과를 다루기 위해 사용됩니다.

1. **대기(pending)**: 초기 상태로, 비동기 작업이 아직 완료되지 않은 상태입니다.

2. **이행(fulfilled)**: 비동기 작업이 성공적으로 완료되었을 때의 상태입니다. 결과 값을 반환합니다.

3. **거부(rejected)**: 비동기 작업이 실패했을 때의 상태입니다. 오류 이유를 반환합니다.

### 메서드 체이닝이란? 장단점은?

1. **메서드 체이닝(Method Chaning)이란?**

   메서드 체이닝은 객체지향 프로그래밍에서 하나의 객체에 대해 여러 메서드를 연속적으로 호출할 수 있도록 하는 방법입니다.

2. **장점**

   1. **가독성 향상**

   2. **코드 간소화**

   3. **편리한 API 설계**

3. **단점**

   1. **디버깅의 어려움**(메서드 체이닝으로 인해 각 결과를 추적하기 어려워진다. 특히 오류 발생의 위치.)

   2. **불변성의 손실**(객체가 불변성을 유지하기 힘듬)

   3. **하나의 큰 객체**(남용시에 하나의 객체가 너무 많은 책임을 가지게 된다.)

## 콜백 함수

콜백 함수는 다른 함수의 인자로 전달되어 특정 시점에 호출되는 함수를 의미합니다.

- **_주요 특징_**

  - **비동기 처리**: 콜백 함수는 주로 비동기 작업이 완료된 후 실행됩니다.

  - **유연성**: 다른 함수에 인자로 전달됨으로써, 함수의 동작을 외부에서 조작할 수 있습니다.

### 프라미스와 콜백함수의 차이점과 각각의 장단점은?

프라미스와 콜백함수는 자바스크립트에서 비동기 작업을 처리하는 두 가지 주요 방법입니다.

1. **_콜백 함수_**

   콜백 함수는 특정 작업이 완료된 후 호출되는 함수입니다.(인수로 사용되는 함수)

   1. **_장점_**

      1. **단순함**(간단한 작업은 구현이 쉽고 직관적)

      2. **전통적인 사용법**(JS에서 주로 쓰이는 방식)

   2. **_단점_**

      1. **콜백 지옥**

      2. **에러 처리 어려움**

2. **_프라미스_**

   프라미스는 비동기 작업의 완료 또는 실패를 나타내는 객체입니다.

   1. **_장점_**

      1. **가독성**(메서드 체이닝 활용으로 읽기 쉬움)

      2. **에러 처리**(catch 메서드 활용으로 한곳에서 모든 오류 처리 가능)

      3. **비동기 코드 흐름 관리**(async, await를 활용할 수 있음)

   2. **단점**

      1. **복잡성**(경우에 따라 더 복잡함)

      2. **상태 관리**(이행, 거부, 대기를 모두 관리해야 함)

   3. **비동기 처리 방식**

      - **콜백함수**: 비동기 작업이 완료되면 호출됩니다.

      - **프라미스**: 비동기 작업의 완료 또는 실패를 나타내는 객체입니다.

   4. **가독성**

      - **콜백 함수**: 중첩되면 콜백지옥.

      - **프라미스**: then, catch의 메서드 체이닝으로 상대적으로 가독성이 좋은 편입니다.

   5. **에러 처리**

      - **콜백 함수**: 각 콜백.

      - **프라미스**: catch 블록.

   6. **비동기 흐름 제어**

      - **콜백 함수**: 복잡함.

      - **프라미스**: async/await로 제어 가능.

   7. **단순성**

      - **콜백 함수**: 간단한 비동기 작업.

      - **프라미스**: 복잡한 비동기 작업.

### 콜백지옥

콜백지옥은 비동기 프로그래밍에서 콜백 함수가 중첩되어 작성될 때 발생하는 코드의 가독성 저하와 유지보수 어려움을 의미합니다.

1. **특징**

   1. **중첩된 구조**

   2. **가독성 저하**

   3. **에러 처리의 복잡성**

2. **해결 방법**

   1. **Promise**

   2. **async/await**

## 코딩이론

### 추상화

추상화(Abstraction)는 복잡한 시스템이나 개념을 단순화하여 중요한 정보나 특성만을 드러내고, 불필요한 세부사항을 숨기는 과정입니다.

1. **_소프트웨어 개발에서의 추상화_**

   1. **목적**: 코드의 복잡성을 줄이고, 재사용성을 높이고, 시스템의 이해도를 높이는 것입니다.

   2. **예시**

      1. **객체지향 프로그래밍**: 클래스와 객체를 사용하여 복잡한 현실 세계의 개념을 모델링합니다.

      2. **API**: 제공되는 기능의 세부사항을 알 필요가 없게 만듭니다.(예: OAUTH 로직이나 위치추적 로직 등)

2. **_추상화의 유형_**

   1. **데이터 추상화**: 필요한 기능만을 노출하는 방법.

   2. **절차적 추상화**: 복잡한 알고리즘이나 프로세스를 여러 개의 간단한 단계로 나누는 방법.

3. **_장점_**

   1. **복잡성 감소**

   2. **재사용성**

   3. **유지보수 용이성**(모듈화가 잘 이루어진다)

4. **_단점_**

   1. **성능 저하**(불필요한 오버헤드 증가)

   2. **추상화의 오해**(기능이나 성격을 착각하게 할 수 있음)

### 원시 타입과 참조타입에 대해서

1. **_원시 타입 (Primitive Type)_**

   - **정의**: 단일 값으로 표현되며, 불변(immutable)입니다.

   - **종류**: JS에서는 string, number, boolean, null, undefined, symbol, bigint가 원시 타입입니다.

   - **저장 방식**: 값 자체가 스택에 저장됩니다.

2. **_참조 타입(Reference Type)_**

   - **정의**: 객체 형태로 여러 값을 포함할 수 있으며, 가변(mutable)입니다.

   - **종류**: Object, Array, Function, Date, 사용자 정의 객체 등입니다.

   - **저장 방식**: 값이 힙에 저장되고, 변수에는 해당 값의 참조(주소)가 저장됩니다.
