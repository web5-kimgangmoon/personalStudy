# 목차

- **웹**

  - **웹 기초**

    1.  **문서객체모델**
    2.  **JSON**
    3.  **세션, 쿠키, 캐시**
    4.  **CORS(Cross-Origin Resource Sharing)**
    5.  **적응형과 반응형의 차이**
    6.  **SSR, CSR**
    7.  **SEO**
    8.  **SERP**
    9.  **크롤링(Crawling)**
    10. **인덱싱 (Indexing)**
    11. **DNS(domain name system)**
    12. **오버페칭 (Over-fetching)**
    13. **언더페칭 (Under-fetching)**

  - **웹 프로토콜 및 응용**

    1. **RESTful API**
    2. **OSI 7계층**
    3. **TCP/IP 4계층 및 5계층 모델**
    4. **TCP, UDP**
    5. **웹 프로토콜**
    6. **HTTP들의 버전**
    7. **SSL/TLS**
    8. **웹 보안**
    9. **MFA**
    10. **IDP/IPS (Intrusion Detection System / Intrusion Prevention System)**
    11. **HTTP와 HTTPS의 차이**
    12. **HTTP 상태 코드**
    13. **3 Way-HandShake 및 4 Way-HandShake**
    14. **세션 기반 인증과 토큰 기반 인증**
    15. **google.com을 입력했을 때**
    16. **크로스 브라우징**
    17. **웹 접근성**
    18. **JWT**
    19. **대칭 비밀 키 암호화와 비대칭 키 암호화 방식**
    20. **퍼블릭 IP와 프라이빗 IP**
    21. **ISP(Internet Service Provider)**
    22. **IPv4, IPv6의 차이**
    23. **IPSec**
    24. **OAuth(번외)**
    25. **서드파티**
    26. **WAS**
    27. **WS**

- **코딩**

  - **콜백함수**

    1. **AJAX**
    2. **동기와 비동기**
    3. **async/await 외의 비동기 처리 방법**
    4. **RxJS**
    5. **데이터의 스트림 형태**
    6. **Promise**
    7. **메서드 체이닝이란? 장단점은?**
    8. **콜백 함수**
    9. **프라미스와 콜백함수의 차이점과 각각의 장단점은?**
    10. **콜백 지옥**

  - **코딩이론**

    1.  **추상화**
    2.  **원시 타입과 참조타입에 대해서**
    3.  **가비지 컬렉터(Garbage Collector, GC)**
    4.  **순환참조**
    5.  **리팩토링**
    6.  **클린 코드와 리팩토링 차이**
    7.  **Call By Value와 Call By Reference**
    8.  **TDD**
    9.  **CICD**
    10. **트러블 슈팅 경험**

  - **프론트엔드**

    1.  **CSS 적용 순서**
    2.  **모달과 팝업의 차이**
    3.  **inline과 inline block의 차이**
    4.  **이벤트 위임**
    5.  **GraphQL**
    6.  **템플릿 엔진**
    7.  **디자이너가 psd 파일 또는 jpg 파일만 주었을 때 구현 가능?(해당 이미지를 청사진으로서 활용하는 경우의 고려사항)**

  - **백엔드**

    1. **백엔드 프레임워크의 종류**
    2. **프레임워크(JS 기반)**
    3. **의존성 주입 (Dependency Injecction)**
    4. **의존성 주입이 유용한 이유(자필)**
    5. **Waterline**
    6. **런타임**
    7. **프레임워크와 라이브러리 모듈**
    8. **Express**

  - **아키텍처 및 프로그래밍 패러다임**

    1.  **프로토타입**
    2.  **아키텍처**
    3.  **AOP (Aspect-Oriented Programming)**
    4.  **데코레이터 패턴이란**
    5.  **싱글톤 패턴**
    6.  **MVC 패턴**
    7.  **클라이언트 서버 구조**
    8.  **클라이언트 서버 모델의 특징**
    9.  **플러그인 기반 아키텍처**
    10. **마이크로 서비스 아키텍처(MSA)**
    11. **마이크로 서비스와 모놀리틱 서비스**
        1. **이벤트 기반 아키텍처**
    12. **OOP(객체 지향 프로그래밍)의 지향점**
    13. **병렬 프로그래밍**
    14. **함수형 프로그래밍**
        1. **Hydration(번외)**
        2. **순수 함수**
    15. **OOP와 함수형 프로그래밍의 차이점**
    16. **OOP 특징과 원칙**
    17. **동시성 모델**

  - **db**

    1. **db 관계형 비관계형 차이**
    2. **db의 종류**
    3. **ORM**
    4. **인덱스**
    5. **트랜잭션**

- **js**

  - **nodeJs**

    1. **Node.js**
       1. **Node.js는 단일 스레드?(개인적 해석, 인터넷 서치)**
       2. **스레드풀**
       3. **CPU 집약적인 작업**
    2. **Node.js 이벤트 큐 동작 원리**
    3. **이벤트 루프**
    4. **Node.js의 모듈 종류는?**
    5. **Node.js가 BackEnd에서 선호되는 이유**
    6. **Node.js의 장단점**
    7. **npm**
    8. **SemVer**
    9. **npm install**
    10. **dependence와 devDependence 차이**
    11. **Node.js가 싱글 스레드지만 병렬작업이 가능한 이유**
    12. **클러스터링**

  - **ES6의 추가요소들 및 문제해결 방안**

    1. **var, let, const**
    2. **일시적 사각지대(Temporal Dead Zone, TDZ)**
       1. **let과 const(자필 및 chatGPT)**
    3. **스코프**
    4. **변수의 생성과정**
       1. **라이프 타임**
    5. **모든 브라우저에서 ES6 스펙에 대한 지원이 완벽하지 않으며, 해결 방안은?**
    6. **Babel**
    7. **Webpack**

  - **react**

    1.  **React**
    2.  **상태관리**
    3.  **React의 동작원리**
    4.  **컴포넌트**
    5.  **클래스 컴포넌트와 함수형 컴포넌트의 차이는?**
    6.  **훅**
    7.  **라이프사이클의 메서드 종류는?**
    8.  **Angular, Vue.js, React.js의 차이는?**
    9.  **Angular의 디자인 원칙**
    10. **Virtual dom**

  - **바닐라 js관련**

    1. **Typescript 쓰는 이유**
    2. **ECMA**
       1. **하위 호환성**
    3. **null과 undefined의 차이**
    4. **클로저(Closure)**
    5. **실행 컨텍스트(Excution Context)**
    6. **브라우저 엔진은?**
    7. **JIT**
    8. **컴파일**
    9. **자바스크립트의 Number Type과 다른 언어의 차이는?**
       1. **배정도, 단정도의 뜻(개인질문)**
       2. **체이닝**
    10. **배열과 실제 자료구조 배열의 차이점은?**
        1. **DTO(개인질문)**
        2. **직렬화, 역직렬화(개인용)**
    11. **Call, Apply, Bind**
    12. **this**
    13. **useStrict**
    14. **useStrict 모드에서의 this는?**

- **컴퓨터과학**

  - **컴퓨터과학 기초**

    1. **프로세스와 스레드 차이**
    2. **성능 최적화 방법**
       1. **정규화 (Normal Form)**
       2. **CDN(Content Delivery Network)**
       3. **스케일 업(Scale Up)**
       4. **스케일 아웃(Scale Out)**
    3. **자료구조**
    4. **큐와 스택 차이**
    5. **BST**
       1. **자가 균형 이진 검색 트리**
    6. **시간 복잡도**
    7. **트랜잭션 데드락**
    8. **세마포어와 뮤텍스, 조건 변수**
       1. **데이터 경쟁(Data Race)**
    9. **좀비프로세스**
    10. **프로토콜(웹 X)(개인질문)**

  - **가상화**

    1. **Docker**
       1. **컨테이너**
       2. **컨테이너의 가상화**
    2. **Docker와 VM의 차이는?**

  - **버전관리**

    1. **버전 관리 시스템**
    2. **git이란?**
    3. **GitHub**
    4. **Jenkins**

## _웹_

## 웹 기초

### 문서객체모델

문서 객체 모델(DOM)은 HTML 및 XML 문서의 구조화된 표현을 제공하는 프로그래밍 인터페이스입니다. DOM은 문서의 모든 요소, 속성들을 객체로 표현합니다.

1. **_주요 개념_**

   1. **트리 구조**
   2. **노드 타입**
      1. Element Node(기본 태그, \<div> 등)
      2. Text Node
      3. Attribue Node
      4. Document Node
   3. **인터페이스**(언어에 독립적인 API 제공)

2. **_주요 기능_**

   1. **문서 탐색**(다른 노드나 관련 노드를 찾기 편하다)
   2. **내용 변경**(속성이나 텍스트)
   3. **노드 추가 및 삭제**
   4. **이벤트 처리**

3. **_결론_**

DOM은 웹 페이지를 동적으로 조작할 수 있게 해주는 인터페이스다.

### JSON

데이터 교환 형식이며, 텍스트 기반의 포맷이다.

1. **형식**(키-값 쌍의 형태로 구성된다.)
2. **가독성**
3. **언어 독립성**
4. **데이터 유형**(문자열, 숫자, 배열, 객체, 불리언, 널)
5. **사용 용도**(데이터 전송, 설정 파일, 데이터 저장 등)

### 세션, 쿠키, 캐시

1. **_세션(session)_**

   - **정의**: 사용자가 웹사이트에 접속하는 동안의 상태 정보

   - **저장 위치**: 서버에서 저장, 사용자 브라우저에선 세션 ID가 쿠키로 저장된다.

   - **사용 목적**: 로그인 상태 유지, 장바구니 정보 저장 등.

   - **특징**:세션은 일반적으로 사용자가 브라우저를 닫거나 세션 타임아웃이 발생하면 만료됩니다.

2. **_쿠키(Cookie)_**

   - **정의**: 사용자의 정보를 저장하는 작은 데이터 파일

   - **저장 위치**: 클라이언트의 브라우저

   - **사용 목적**: 사용자 인증, 개인화된 설정, 방문 기록 등.

   - **특징**: 쿠키는 만료 기간을 설정할 수 있어 영구적으로 저장될 수 있습니다.

3. **_캐시(Cache)_**

   - **정의**: 임시 저장된 자주 요청되는 데이터

   - **저장 위치**: 클라이언트(브라우저) 및 서버

   - **사용 목적**: 웹 페이지 로딩 속도 향상, 서버 부하 감소 등.

   - **특징**: 만료 기간이나 정책에 따라 갱신됩니다.

### CORS(Cross-Origin Resource Sharing)

웹 브라우저는 다른 출처의 리소스에 대한 요청을 제한하여 보안을 강화합니다.

CORS은 웹 애플리케이션에서 리소스가 다른 출처(origin)에서 요청될 때 보안을 관리하는 메커니즘입니다.

1. **_출처(origin)_**

   - **구성**: 프로토콜, 도메인, 포트번호

2. **_CORS 정책_**

   - **기능**: 서버는 응답 헤더에 특정 CORS 헤더를 포함하여 요청이 허용되는 출처를 명시합니다.

   - **주요 헤더**: Access-Control-Alllow-Origin

3. **_요청 유형_**

   - **단순 요청(Simple Request)**: GET, POST, (특정 조건 하에) 요청 등.

   - **사전 요청(Preflight Request)**: 브라우저가 실제 요청 전에 OPTIONS 메서드를 사용해 서버에 권한을 확인합니다.

4. **_보안_**

   - **보안**: CORS는 출처를 명시적으로 관리합니다.

### 적응형과 반응형의 차이

적응형(adaptive)
반응형(Responsive)

1. **_정의_**

   - **적응형**: 특정 화면 크기나 해상도에 맞춰 미리 여러 레이아웃을 제공하는 방식입니다.

   - **반응형**: 하나의 레이아웃을 사용하며, 화면 크기에 따라 요소의 크기와 위치가 동적으로 조정됩니다.

2. **_작동 방식_**

   - **적응형**: 특정 브레이크포인트(예: 480px 등)에서 서로 다른 레이아웃을 로드합니다.

   - **반응형**: 화면 크기에 맞춰 하나의 레이아웃이 유동적으로 변화합니다.

3. **_장단점_**

   - **적응형**:

     1. **_장점_**: 특정 화면에 맞춘 레이아웃 제공으로, 사용자 경험이 향상될 수 있습니다.

     2. **_단점_**

        1. 개발 및 유지보수가 복잡해집니다.

        2. 시간과 비용이 더 소요될 수 있습니다.

   - **반응형**:

     1. **_장점_**

        1. 유지보수가 용이합니다.

        2. 수정이 쉽다.

     2. **_단점_**

        1. 사용자 경험이 적응형에 비해 뒤떨어질 수 있다.

        2. 유동적인 레이아웃의 구현을 위해 CSS가 도리어 복잡해질 수 있다.

### SSR, CSR

- **_SSR_**

  1. **_정의_**

     - 서버에서 HTML을 생성하여 클라이언트에 전달하는 방식입니다.

  2. **_특징_**

     - **초기 로딩 속도 빠름**

     - **SEO 최적화**

     - **javaScript가 비활성되어도 정상적인 페이지 표시**

  3. **_단점_**

     - **서버 부하**

     - **상호작용 성능 느림**

- **_CSR_**

  1.  **_정의_**

      - 클라이언트(브라우저)에서 JavaScript로 데이터를 가져오고, DOM을 조작하여 HTML을 생성하는 방식입니다.

  2.  **_특징_**

      - **빠른 사용자 경험**

      - **서버 부하 감소**

  3.  **_단점_**

      - **초기 로딩 속도 느림**

      - **SEO 문제**

      - **JavaScript 비활성시 비정상적인 페이지 표시**

### SEO

SEO는 웹사이트나 웹페이지를 검색 엔진 결과 페이지에서 높은 순위에 노출시키기 위한 전략과 기법을 의미합니다.

1. **_주요 요소_**

   - **온페이지 SEO (On-page SEO)**

     - **키워드 최적화**(사용자들이 자주 검색하는 키워드)

     - **메타 태그**

     - **콘텐츠 품질**

     - **간결한 URL 구조**

     - **내부 링크**(해당 웹사이트가 가진 다른 페이지와 링크)

   - **오프페이지 SEO(Off-page SEO)**

     - **백링크**(다른 웹사이트에서 자신의 웹사이트로 연결되는 링크)

     - **소셜 미디어**

   - **기술적 SEO (Technical SEO)**

     - **사이트 속도**

     - **모바일 최적화**

     - **사이트 구조**(크롤링과 인덱스가 쉬운 구조)

     - **사용자 경험**

2. **_SEO의 중요성_**

   - **트래픽 증가**

   - **브랜드 신뢰성**

   - **비용 효율성**

### SERP

SERP는 검색 엔진에서 사용자가 검색한 키워드에 대한 결과 페이지를 의미합니다.

1. **_SERP의 주요 구성 요소_**

   1. **유기적 검색 결과(Organic Results)**(유동적인 검색결과)

   2. **광고**(광고비가 지불된 유료 광고)

   3. **스니펫(Feature Snippets)**(질문에 대한 직접적인 답변이나 요약, 상단에 강조 표시)

   4. **지역 정보(Local Results)**(특정 지역에 대한 검색일 경우, 지역 정보와 지도와 주소가 표시)

   5. **관련 질문(People Also Ads)**

   6. **이미지/비디오 결과**

2. **SERP의 중요성**

   1. **가시성**

   2. **사용자 경험**

   3. **비즈니스 기회**

### 크롤링 (Crawling)

1.  **_정의_**

    - 크롤링은 검색 엔진 봇(크롤러 또는 스파이더)이 웹 페이지를 탐색하여 새로운 콘텐츠를 발견하고, 기존의 페이지를 업데이트하는 과정입니다. 크롤러는 링크를 따라 이동합니다.

2.  **_과정_**

    1.  **시작점**(초기 URL 목록을 기반으로 시작)

    2.  **페이지 수집**(지정된 URL에 접속, 페이지의 콘텐츠를 가져온다)

    3.  **링크 추적**(페이지 내의 링크를 분석, 새로운 URL을 큐에 추가하고 지속적으로 크롤링 진행)

    4.  **재방문**(정기적인 지속적 업데이트)

3.  **_중요성_**

    - **신규 콘텐츠 발견**

    - **업데이트 유지**

### 인덱싱 (Indexing)

1.  **_정의_**

    - 인덱싱은 크롤링을 통해 수집된 웹 페이지의 콘텐츠를 분석하고, 이를 검색 엔진의 데이터베이스에 저장하고 정리하는 과정이다.

2.  **_과정_**

    1. **데이터 분석**(텍스트, 메타 태그, 이미지 등을 분석하고 중요한 정보 추출)

    2. **구조화**(키워드와 관련된 구조로 정리하여 인덱스 생성)

    3. **저장**(db에 저장)

3.  **중요성**

    1. **검색 효율성**(db의 인덱스)

    2. **정확한 검색 결과**

### DNS(domain name system)

인터넷에서 도메인 이름을 IP 주소로 변환하는 시스템입니다.

1. **_주요 기능_**

   1. **도메인 이름 해석**(이름을 IP로 변환)

   2. **주소 캐싱**(자주 요청되는 이름과 IP 주소 쌍을 캐싱)

   3. **부하 분산**(여러 IP 주소를 도메인 이름에 매핑)

2. **_DNS의 구조_**

   1. **DNS 리졸버**(도메인 이름을 IP 주소로 변환하는 역할)

   2. **루트 DNS 서버**(최상위 DNS 서버, 특정 도메인의 네임 서버에 대한 정보 제공)

   3. **TLD(최상위 도메인)(Top-Level-Domain) 서버**(특정 도메인(.com, .org 등)에 대한 정보 저장)

   4. **권한 있는 네임 서버**(특정 도메인에 대한 IP 주소와 관련된 정보를 저장)

### 오버페칭 (Over-fetching)

클라이언트가 실제로 필요로 하는 것보다 더 많은 데이터를 요청하는 상황.

### 언더페칭 (Under-fetching)

클라이언트가 필요한 데이터를 요청할 때, 부족한 데이터가 반환되는 상황.

## 웹 프로토콜 및 응용

### RESTful API

Restful API는 Representational State Transfer(REST) 원칙을 따르는 웹 서비스 인터페이스입니다.(클라이언트-서버 아키텍처)

1. **자원(Resource)**

   URI(하나의 리소스를 가리키는 문자열)를 사용하여 자원을 식별합니다.

2. **HTTP 메서드**

   1. **GET**(조회)

   2. **POST**(생성)

   3. **PUT**(전체 갱신)

   4. **PATCH**(부분 갱신)

   5. **DELETE**(삭제)

3. **상태 비저장성(Stateless)**

   REST API의 각 요청은 독립적이며, 서버는 클라이언트의 상태를 저장하지 않습니다.

4. **표현(Representation)**

   자원은 다양한 형식(예: JSON, XML)으로 표현될 수 있습니다.

5. **캐싱(Caching)**

   응답 캐시

6. **계층화(Layered System)**

   여러 계층으로 구성될 수 있으며, 클라이언트는 중간 서버의 존재를 알지 못합니다.

### OSI 7계층

OSI 7계층(Open Systems Interconnection model)은 네트워크 통신을 표준화하기 위해 제안된 개념적 모델입니다.

1. **물리 계층 (Physical Layer)**

   - **역할**: 전기적, 기계적, 절차적 특성을 정의하여 실제 데이터를 전송하는 계층입니다.

   - **예시**: 케이블, 리피터, 허브, 전기 신호 등

2. **데이터 링크 계층(Data Link Layer)**

   - **역할**: 물리적 네트워크에서 데이터의 오류 감지 및 수정, 그리고 MAC 주소를 사용한 노드 간의 데이터 전송을 담당합니다.

   - **예시**: 이더넷, Wi-Fi, PPP(점대점 프로토콜)

3. **네트워크 계층 (Network Layer)**

   - **역할**: 데이터 패킷의 경로 설정 및 전달을 담당하며, 논리적 주소(예: IP 주소)를 사용하여 네트워크 간 통신을 가능하게 합니다.

   - **예시**: IP(인터넷 프로토콜), ICMP(인터넷 제어 메시지 프로토콜)

4. **전송 계층 (Transport Layer)**

   - **역할**: 종단 간 (end-to-end) 통신을 관리하며, 데이터의 전송 오류를 감지하고 복구합니다. 흐름 제어 및 세분화된 데이터 전송도 지원합니다.

   - **예시**: API(응용 프로그램 프로그래밍 인터페이스), 소켓

5. **세션 계층 (Session Layer)**

   - **역할**: 통신 세션을 관리하고, 세션의 생성, 유지 및 종료를 담당합니다. 데이터 교환의 동기화도 지원합니다.

   - **예시**: API(응용 프로그램 프로그래밍 인터페이스), 소켓

6. **표현 계층 (Presentation Layer)**

   - **역할**: 데이터의 형식과 표현을 변환하여 서로 다른 시스템 간의 데이터 호환성을 보장합니다. 데이터 압축 및 암호화도 이 계층에서 수행됩니다.

   - **예시**: JPE6, GIF, ASCII

7. **응용 계층 (Application Layer)**

   - **역할**: 최종 사용자가 직접 사용하는 응용프로그램과 네트워크 간의 인터페이스를 제공합니다. 사용자와 네트워크의 상호작용을 처리합니다.

   - **예시**: HTTP, FTP, SMTP, DNS

### TCP/IP 4계층 및 5계층 모델

TCP/IP 모델은 인터넷과 같은 네트워크에서 데이터 통신을 위한 프로토콜을 정의하는 구조.

- **TCP/IP 4계층 모델**

  1.  **네트워크 인터페이스 계층(Network Interface Layer)**

      - **역할**: 물리적 네트워크에서 데이터 전송을 담당하며, 하드웨어와 관련된 데이터 링크 및 물리적 전송을 포함합니다.

      - **예시**: Ethernet, Wi-Fi, ARP(Address Resolution Protocol)

  2.  **인터넷 계층 (Internet Layer)**

      - **역할**: 데이터 패킷의 주소 지정 및 라우팅을 담당합니다.

      - **예시**: IP (Internet Protocol),
        ICMP (Internet Control Message Protocol)

  3.  **전송 계층 (Transport Layer)**

      - **역할**: 종단 간 데이터 전송을 관리하며, 신뢰성, 흐름 제어 및 오류 검출을 제공합니다.

      - **예시**: TCP (Transmission Control Protocol), UDP (User Datagram Protocol)

  4.  **응용 계층 (Application Layer)**

      - **역할**: 최종 사용자와의 상호작용을 처리하며, 애플리케이션 프로토콜을 포함합니다.

      - **예시**: HTTP, FTP, SMTP, DNS

  - **TCP/IP 5계층 모델**

    1. **물리 계층(Physical Layer)**

       - **역할**: 전기적 신호, 케이블 및 하드웨어와 관련된 요소를 다룹니다.

    2. **데이터 링크 계층(Data Link Layer)**

       - **역할**: 물리적 네트워크의 데이터 전송 및 오류 감지를 담당합니다.

    3. **인터넷 계층 (Internet Layer)**

       - **역할**: 데이터 패킷의 주소 지정 및 라우팅을 담당합니다.

    4. **전송 계층 (Transport Layer)**

       - **역할**: 종단 간 데이터 전송을 관리하며, 신뢰성, 흐름 제어 및 오류 검출을 제공합니다.

    5. **응용 계층 (Application Layer)**

       - **역할**: 최종 사용자와의 상호작용을 처리하며, 애플리케이션 프로토콜을 포함합니다.

### TCP, UDP

1. **TCP (Transmission Control Protocol)**

   1. **연결 지향**(데이터 전송 전에 연결 설정)

   2. **신뢰성**(데이터 손실 확인)

   3. **순서 보장**

   4. **흐름 제어**

   5. **사용 예**(웹 페이지 로딩, 파일 전송, 이메일 등)

2. **UDP (User Datagram Protocol)**

   1. **비연결 지향**

   2. **신뢰성 없음**

   3. **순서 보장 없음**

   4. **흐름 제어 없음**

   5. **사용 예**(실시간 게임, 비디오 스트리밍, 음성 통화(VoIP) 등)

3. **요약**

   - **TCP**: 신뢰성과 순서 보장이 필요한 데이터 전송에 적합합니다.

   - **UDP**: 빠른 전송 속도가 필요한 경우에 적합합니다.

### 웹 프로토콜

웹에서 클라이언트와 서버 간의 통신을 정의하는 규칙과 규약의 집합입니다.

1. **주요 웹 프로토콜**

   1. **HTTP (Hypertext Transfer Protocol)**

      가장 널리 사용되는 웹 프로토콜, 요청-응답 모델.

   2. **HTTPS (Hypertext Transfer Protocol Secure)**

      HTTP의 보안 버전, SSL/TLS 프로토콜 사용.

   3. **FTP (File Transfer Protocol)**

      클라이언트와 서버 간의 파일 전송 및 관리를 지원, 사용자 인증(로그인) 기능을 제공한다.

   4. **SFTP (SSH File Transfer Protocl)**

      SSL(Secure Shell) 프로토콜을 사용하여 안전한 파일 전송을 지원합니다.

   5. **IMAP (Internet Message Access Protocol)**

      이메일 클라이언트가 서버에 저장된 이메일에 접근하고 관리할 수 있도록 하는 프로토콜이다. 메일이 남기에 여러 디바이스에서 확인 가능.

   6. **POP3(Post Office Protocol version 3)**

      이메일 클라이언트가 서버에서 이메일을 다운로드하여 로컬로 저장하는 프로토콜입니다. 이메일 다운 후 서버에서 삭제된다.

2. **웹 프로토콜의 중요성**

   - **상호운용성**(다양한 클라이언트와 통신 가능)

   - **보안**

   - **성능**

### HTTP들의 버전

1. **_HTTP/1.1_**

   - **_출시 연도_**: 1999년

   - **_주요 특징_**:

     1. **지속적 연결**(여러 요청과 응답을 하나의 TCP 연결에서 처리 가능)

     2. **요청/응답 다양한 헤더**

     3. **Chunked 전송 인코딩**(데이터를 여러 조각(chunk)로 나누어 전송 가능)

     4. **HTTP 캐시**(미리 받아온 데이터 저장 가능)

   - **_단점_**

     1. **헤드 오버로드**(매 요청마다 TCP 연결 설정)

     2. **동시성**(여러 요청에 다수의 TCP 연결 생성 필요)

2. **_HTTP/2_**

   - **_출시 연도_**: 2015년

   - **_주요 특징_**:

     1. **이진 프로토콜**(이전은 문자열, 해당 버전에선 이진 형식)

     2. **멀티 플렉싱**

     3. **서버 푸시**(서버는 클라이언트의 요청 없이도 필요한 자원을 미리 전송(css,js 등))

     4. **헤더 압축**(HPACK)

     5. **지속적 연결**

   - **_단점_**:

     1. **복잡성**

     2. **TCP 사용**(여전히 TCP)

3. **_HTTP/3_**

   - **_출시 연도_**: 2020년

   - **주요 특징**:

     1. **QUIC 프로토콜**(UDP 기반 프로토콜)

     2. **무연결성**(각 요청은 독립적이므로 다른 요청에서 패킷이 손실되도 지장없이 동작)

     3. **0-RTT 연결**(이전에 연결된 클라이언트는 연결 설정 없이 데이터 즉시 전송 가능)

     4. **내장 암호화**(QUIC은 모든 데이터 암호화)

     5. **멀티플렉싱 및 헤더 압축**(이전 버전 기능)

   - **단점**:

     1. **UDP 기반**(패킷 손실 시 재전송 방식이 TCP와 다르게 동작할 가능성)

     2. **서버 지원 필요**(HTTP/3를 지원하는 웹 서버가 적다)

4. **요약**

   1. **HTTP/1.1**: 텍스트 기반, 요청/응답 모델, 다수의 연결 필요.

   2. **HTTP/2**: 이진 프로토콜, 멀티 플렉싱, 서버 푸시, 헤더 압축.

   3. **HTTP/3**: QUIC 기반, 무연결성, 0-RTT 지원, 내장 암호화.

### SSL/TLS

SSL("Secure Sockets Layer")과 TLS("Transport Layer Security")는 인터넷에서 데이터 전송 시 보안을 제공하는 프로토콜입니다. SSL은 초기 버전, TLS는 후기 버전입니다.

1. **목적**

   데이터 암호화, 인증 및 무결성 보장.

2. **SSL과 TLS의 관계 및 성능**

   1. **TLS는 SSL의 후속 프로토콜**(실제로 TLS 1.0은 SSL 3.0의 개선 버전으로 간주. 같이 묶어 불리는 경우가 많습니다)

   2. **성능 개선**:

      - 암호화 및 복호화 과정 최적화, 성능 향상. TLS 1.2와 TLS 1.3은 특히.

      - TLS 1.3에서는 핸드쉐이크 과정이 간소화되었습니다.

   3. **HTTP/3와의 통합**:

      HTTP/3는 QUIC 프로토콜을 사용하며, QUIC는 TLS 1.3을 내장하고 있다.

### 웹 보안

1. **HTTPS 사용**(SSL/TLS)

2. **인증 및 권한 부여**(강력한 비밀번호 정책과 다단계 인증)

3. **입력 검증**(사용자 입력 검증으로 SQL 인젝션, 크로스 사이트 스크립팅(XSS) 등의 공격 방지)

4. **정기적인 업데이트**(알려진 취약점 차단)

5. **백업 및 복구 계획**

6. **방화벽 및 IDS/IPS**

### MFA(Multi-Factor Authentication)

- **정의**: 사용자가 로그인할 때 두 개 이상의 인증 요소를 요구하는 방식입니다.

- **요소**

  1.  **지식 기반**

  2.  **소지 기반**

  3.  **고유 기반**(생체 정보)

### IDS/IPS (Intrution Detection System / Intrution Prevention System)

1. **정의**:

   - **IDS**: 네트워크 또는 시스템에서 비정삭적인 활동이나 침입 시도를 감지하는 시스템입니다.

   - **IPS**: IDS의 기능에 추가로, 감지된 공격을 차단하는 기능을 갖춘 시스템입니다.

2. **기능**:

   - **IDS**: 로그 모니터링, 알림 전송 등으로 공격을 경고합니다.

   - **IPS**: 실시간으로 공격을 차단하고, 네트워크 트래픽을 분석하여 위협을 방지합니다.

### HTTP와 HTTPS의 차이

보안, HTTP는 데이터 암호화가 없지만, HTTPS는 SSL/TLS 프로토콜을 사용하여 데이터를 암호화한다.

### HTTP 상태 코드

HTTP 상태 코드는 클라이언트의 요청에 대한 서버의 응답 상태를 나타내는 3자리 숫자 코드입니다.

1. **_정보 응답 (1XX)_**

   - **100 Continue**(요청 계속 가능)

   - **101 Switching Protocols**(클라이언트 요청에 맞춰 프로토콜 변경)

2. **_성공 응답(2XX)_**

   - **200 OK**(요청 성공)

   - **201 Created**(요청 성공, 자원 생성)

   - **202 Accepted**(요청 접수, 아직 완료X)

   - **204 No Content**(요청 성공, 반환 내용없음)

3. **_리다이렉션(3XX)_**

   - **300 Mutiple Choices**(요청 자원이 여러 개, 클라이언트의 선택 필요)

   - **301 Moved Permanetly**(영구적인 URL 리다이렉션)

   - **302 Found**(임시적인 URL 리다이렉션)

   - **304 Not Modified**(요청된 자원이 수정X)

4. **_클라이언트 오류 (4XX)_**

   - **400 Bad Request**(잘못된 요청)

   - **401 Unauthorized**(인증 필요 혹은 실패)

   - **403 Forbidden**(요청 이해, 서버가 거부)

   - **404 Not Found**(자원 없음)

   - **405 Method Not Allowed**(요청한 HTTP 메서드 지원X)

   - **408 Request Timeout**(요청 시간 초과)

5. **서버 오류 (5XX)**

   - **500 Internal Server Error**(서버 내부 오류)

   - **501 Not Implemented**(서버가 기능을 지원 X)

   - **503 Service Unavailable**(서버가 과부하 혹은 유지보수 중)

   - **504 Gateway Timeout**(게이트웨이가 타임아웃)

### 3-Way-HandShake 및 4 Way-HandShake

1. **3-Way-HandShake (연결 설정)**(TCP 연결 설정)

   1. **SYN**: SYN(세그먼스 시작) 패킷 전송, 클라이언트의 초기 시퀸스 번호 포함.

   2. **SYN-ACK**: 서버에서 응답으로 SYN-ACK 패킷 전송, 서버의 초기 시퀸스 번호와 클라이언트의 시퀸스 번호를 확인하기 위한 ACK 포함.

   3. **ACK**: 연결 확인의 ACK 패킷 전송, 완료.

2. **4-Way HandShake (연결 종료)**

   1. **FIN**: 클라이언트에서 FIN(종료) 패킷 전송.

   2. **ACK**: 서버 FIN 패킷 수신, 서버에서 응답으로 ACK 패킷 전송, 클라이언트에서 서버로의 데이터 전송 종료.

   3. **FIN**: 서버에서 FIN 패킷 전송, 서버에서 클라이언트로의 데이터 전송 종료 의사.

   4. **ACK**: 클라이언트 FIN 패킷 수선, 클라이언트 종료 요청 확인으로 ACK 패킷 전송. 연결은 종료.

### 세션 기반 인증과 토큰 기반 인증

웹 애플리케이션에서 사용자의 인증을 처리하는 방법.

- **세션 기반 인증**

  1.  **서버 저장 방식**(세션)

  2.  **상태 유지**(여러 요청 사이에서도 상태 유지)

  3.  **보안**(서버 저장으로 유리함, 대신 세션 하이재킹 등의 공격엔 취약)

  4.  **확장성 나쁨**(여러 서버가 필요하면, 세션을 공유하는 추가 작업 필요)

- **토큰 기반 인증**

  1.  **클라이언트 저장 방식**(클라이언트면 로컬 스토리지나 쿠키나 상관X)

  2.  **상태 비유지**

  3.  **보안**(만료 시간과 서명, CSRF(Cross-Site Request Forgery)와 같은 공격에 취약)

  4.  **확장성 좋음**(클라이언트 저장)

### google.com을 입력했을 때

1. **URL 입력 및 브라우저 처리**(URL 해석 및 HTTP 요청 생성)

2. **DNS 조회**(DNS 리졸버에 요청, DNS 리졸버는 캐시, 루트 DNS 서버, TLD 서버, 권한 있는 서버 순으로 도메인의 IP 주소를 찾는다)

3. **TCP 연결 설정**(3-way handShake 포함)

4. **HTTP 요청 전송**

5. **서버 처리 및 응답**(서버에서 HTML, CSS, JS를 포함한 콘텐츠를 가진 페이지를 HTTP 응답으로 브라우저로 전송.)

6. **페이지 렌더링**(렌더링한 후 페이지 표시)

7. **추가 리소스 요청**(이미지나 스크립트 등 추가적인 리소스 필요시 요청)

수 밀리 초 안에 일어난다.

### 크로스 브라우징

크로스 브라우징은 웹 애플리케이션이나 웹 사이트가 다양한 클라이언트에서 일관되게 작동하고, 동일한 UX를 제공하는 것을 의미합니다.

1. **_주요 요소_**

   1. **호환성**(각 브라우저는 표준이 다를 수 있으므로, 고려 필요)

   2. **디자인**(브라우저별로 CSS의 렌더링이 다를 수 있다.)

   3. **기능성**(JS 기능이나 API 사용이 브라우저마다 다를 수 있다.)

2. **크로스 브라우징을 고려해야 하는 이유**

   1. **사용자 경험**

   2. **접근성**(다양한 디바이스로 이용 가능)

   3. **시장 점유율**(다양한 브라우저의 사용자층 섭렵 가능)

3. **크로스 브라우징 문제 해결 방법**

   1. **CSS 리셋 및 Normalize**

   2. **폴리필(Polyfill)**(기능 추가)

   3. **브라우저 테스트**

   4. **프레임워크 및 라이브러리 사용**(React, Angular, Vue.js와 같은 프레임워크 및 라이브러리는 호환성을 잘 처리)

### 웹 접근성

웹 접근성(Web Accessibility)은 장애인과 비장애인을 포함한 모든 사용자가 웹 콘텐츠에 접근하고 사용할 수 있도록 보장하는 개념입니다.

1. **주요 요소**

   1. **장애 유형**

   2. **사용자 유형**(모바일, 느린 인터넷, 다양한 브라우저)

2. **웹 접근성의 중요성**

   1. **포괄적인 사용자 경험**(사용자수 증가)

   2. **법적 요구사항**(미국의 ADA(American with Disabilities Act) 등)

   3. **사회적 책임**

3. **웹 접근성을 위한 원칙**

   1. **명확성(Perceivable)**(모든 콘텐츠는 인식 가능해야 합니다. 예를 들어, 이미지에는 대체 텍스트를 통해 시각 장애인이 내용을 알 수 있도록 합니다.)

   2. **운용 가능성(Operable)**(키보드로도 접근 가능해야 합니다.)

   3. **이해 가능성(Understandable)**(정보와 인터페이스는 이해하기 쉬워야 합니다.)

   4. **견고성 (Robust)**(다양한 사용자 에이전트(브라우저, 스크린 리더 등)에서 잘 작동해야 합니다.)

4. **웹 접근성을 높이기 위한 방법**

   1. **적절한 HTML 사용**(의미론적 HTML 사용)

   2. **대체 텍스트 제공**

   3. **키보드 네비게이션 지원**(키보드로 접근가능하도록 작성)

   4. **명확한 색상 대비**(시각적으로 약한 사용자도 쉽게 읽을 수 있도록 작성)

   5. **사용자 피드백 요청**(실제 사용자에게 접근성 테스트)

### JWT

JWT(제이슨 웹 토큰, JSON Web Token)는 인증 및 정보 교환을 위해 사용되는 개방형 표준(RFC7519)입니다.

1. **_주요 구성 요소_**

   1. **헤더(Header)**(토큰의 유형, 서명 알고리즘 정의)

   2. **페이로드(Payload)**(실제 데이터, 클레임(사용자 정보, 토큰의 만료 시간 등) 정보 포함)

   3. **서명(Signature)**(헤더와 페이로드 조합 후 비밀 키로 서명, 무결성 보장)

header.payload.signature
각 부분은 Base64Url로 인코딩.

2. **장점**

   1. **자체 포함형**(JWT엔 모든 정보가 있어, 세션 필요 X)

   2. **확장성 좋음**

   3. **다양한 플랫폼 지원**(프로그래밍 언어나 플랫폼에 구애 X)

3. **사용 사례**

   1. **인증**

   2. **정보 교환**

4. **보안 고려사항**

   - **비밀키 관리 주의**

   - **만료 시간 설정 권장**

### 대칭 비밀 키 암호화와 비대칭 키 암호화 방식

- **_대칭 비밀 키 암호화 (Symmetric Key Encryption)_**

  1.  **_정의_**: 암호화와 복호화에 동일한 키를 사용하는 방식.

  2.  **_장점_**

      - **속도 빠름**

      - **간단한 구현**

  3.  **단점**

      - **키 분배 문제**(암호화와 복호화에서 같은 키 사용으로 안전하게 키 공유 및 관리 어려움)

      - **확장**(사용자 수가 많아지면 키 관리가 복잡해짐, 수많은 비밀키를 각 개인이 소유해야 함)

  4.  **예시 알고리즘**(AES(고급 암호화 표준), DES(데이터 암호화), Blowfish 등)

- **비대칭 키 암호화 (Asymmetric Key Encryption)**

  1.  **정의**: 암호화와 복호화에 다른 키를 사용하는 방식.(공개키, 비밀키)

  2.  **장점**

      - **키 분배 용이**(공캐 키, 비밀 키로 암호화와 복호화의 키 분리)

      - **디지털 서명**(비밀키의 존재 덕분)

  3.  **단점**

      - **속도 느림**

      - **복잡성**

  4.  **예시 알고리즘**: RSA, DSA(디지털 서명 알고리즘), ECC(타원 곡선 암호화) 등.

### 퍼블릭 IP와 프라이빗 IP

- **_퍼블릭 IP (Public IP)_**

  1. **_정의_**

     - 퍼블릭 IP는 인터넷에 연결된 장치가 어디서나 접근 가능한 주소입니다.

     - 인터넷 서비스 제공업체(ISP)에 의해 할당됩니다.

  2. **_특징_**

     - **고유성**

     - **접근 가능성**(인터넷의 다른 장치와 모두 연결가능)

     - **변경 가능성**(ISP에 따라 주기적으로 변경가능)

  3. **사용 예**: 웹 서버, 이메일 서버 등

- **_프라이빗 IP (Private IP)_**

  1.  **_정의_**:특정 네트워크에서만 사용되는 주소.

  2.  **_특징_**

      - **비고유성**(다른 네트워크에서 사용가능)

      - **제한된 범위**: RFC 1918에 정의된 특정 IP 범위 내에서만 사용 가능합니다.

        - **클래스 A**: 10.0.0.0 ~ 10.255.255.255

        - **클래스 B**: 172.16.0.0 ~ 172.31.255.255

        - **클래스 C**: 192.168.0.0 ~ 192.168.255.255

      - **NAT 사용**(인터넷 접근 시, NAT를 통해 퍼블릭 IP로 전환)

  3.  **사용 예**: 가정이나 회사의 로컬 네트워크 내의 컴퓨터, 스마트폰, 프린터 등.

### ISP(Internet Service Provider)

인터넷 접속 서비스를 제공하는 회사나 기관을 의미합니다.

1. **_주요 기능과 서비스_**

   1. **인터넷 접속**(DSL, 케이블, 광섬유, 위성 등으로 제공)

   2. **도메인 등록**(도메인 이름을 등록하고 관리합니다.)

   3. **호스팅 서비스**(고객이 인터넷에서 콘텐츠를 서비스할 수 있도록 지원합니다.)

   4. **기술 지원**(인터넷 연결 문제, 장비 설정 등의 기술 지원을 제공합니다.)

   5. **보안 서비스**(방화벽, VPN(가상 사설망), 안티바이러스 솔루션 등)

2. **_ISP의 종류_**

   1. **전국 ISP**(대규모 네트워크를 운영, 전국적으로 서비스 제공.)

   2. **지역 ISP**(특정 지역에 집중, 지역 사회의 특성에 맞춘 서비스와 지원을 제공.)

   3. **전문 ISP**(특정 서비스에 집중하는 업체, 해당 서비스에서 전문적인 서비스를 제공.)

### IPv4, IPv6의 차이

IPv4(인터넷 프로토콜 버전 4), IPv6(인터넷 프로토콜 버전 6)는 둘 다 인터넷에서 장치 간 통신을 위해 사용하는 두 가지 IP 주소 체계입니다.

1. **_주소 형식_**

   - **IPv4**: 32 비트 주소 체계, 4개의 10진수로 구분된 숫자로 구성, 2^32개의 IP주소

   - **IPv6**: 128 비트 주소 체계, 8개의 16진수로 구분된 숫자로 구성, 2^128개의 IP주소

2. **_주소 공간_**

   - **IPv4**:주소가 적어, 고갈되어 갑니다.

   - **IPv6**:주소가 상대적으로 많아, IP 주소 고갈 문제를 해결가능합니다.

3. **_헤더 구조_**

   - **IPv4**: 헤더가 복잡하고 가변적인 필드 탓에, 처리 속도가 느릴 수 있습니다.

   - **IPv6**: 헤더가 간소화되었고, 필드 수가 줄어 라우팅과 패킷 처리 효율이 높아졌습니다.

4. **_NAT(Network Address Translation)_**

   - **IPv4**: IP 주소 고갈 문제 해결을 위한 NAT 사용, 여러 장치가 하나의 퍼블릭 IP 주소를 공유합니다.

   - **IPv6**: IP 주소가 많아, NAT의 필요성이 적다.

5. **_보안_**

   **IPv4**: 보안 기능이 선택 사항이며, 보안이 강화된 프로토콜의 필요성이 크다.

   **IPv6**: IPSec을 기본적으로 내장하고 있다.

6. **_멀티캐스트와 기타 기능_**

   **IPv4**: 멀티캐스트 기능이 지원하지만, 범위와 유용성에 제한이 있습니다.

   **IPv6**: 멀티캐스트, Anycast 등 다양한 통신 방식이 내장되어 있습니다.

### IPSec

IPSec(Internet Protocol Security)은 인터넷 프로토콜(IP) 통신의 보안을 제공하기 위해 설계된 프로토콜 집합입니다.

1. **_주요 특징 및 구성 요소_**

   1. **가능**

      - **기밀성**(데이터 암호화)

      - **무결성**

      - **인증**(데이터 출처 확인)

   2. **구성 요소**

      - **AH(Authentication Header)**(데이터의 인증과 무결성만 제공. 원본 인증, 변조 확인.)

      - **ESP(Encapsulating Security Payload)**(데이터의 인증과 무결성, 기밀성을 제공. 데이터 암호화, 인증 정보 추가.)

   3. **모드**

      - **전송 모드(Transport Mode)**(IP 패킷의 페이로드만 암호화, 주로 호스트 간의 통신에 사용.)

      - **터널 모드 (Tunnel Mode)**(전체 패킷을 암호화하여 새로운 IP 헤더를 추가, 주로 두 네트워크 간의 VPN 연결에 사용.)

   4. **키 관리**

      - IKE(Internet Key Exchange) 프로토콜을 사용합니다. IKE는 보안 연결을 설정하고, 암호화 키를 교환합니다.

2. **_사용 사례_**

   - **VPN**(원격 사용자가 안전하게 기업 네트워크에 접속할 수 있도록 하는 데 주로 사용.)

   - **데이터 보호**

### OAuth

OAuth(오픈 인증, Open Authorization)은 사용자 인증 및 권한 부여를 위한 프로토콜로, 사용자 정보를 안전하게 공유할 수 있도록 설계되었습니다.

1. **_주요 특징_**

   1. **권한 부여**

      OAuth는 사용자(자원 소유자)가 자신의 자원에 대한 접근을 특정 애플리케이션(클라이언트)에 허용하는 메커니즘을 제공합니다.

   2. **토큰 기반**

      OAuth는 사용자 인증 후에 권한 부여 토큰을 발급하며, 해당 토큰을 통해 애플리케이션이 자원에 접근할 수 있도록합니다.

   3. **스코프**

      사용자가 애플리케이션에 권한을 부여할 때, 특정 자원이나 작업에 대한 접근 범위를 지정할 수 있습니다.

2. **_다양한 플로우_**

   - **Authorization Code Grant**(서버 간의 안전한 통신을 위해 주로 사용.)

   - **Implicit Grant**(주로 웹 브라우저 기반의 애플리케이션에서 사용)

   - **Resource Owner Password Credentials Grant**(사용자가 직접 비밀번호를 입력하여 권한을 부여.)

   - **Client Credentials Grant**(서버 간의 통신에서 사용.)

3. **사용 사례**

   - **소셜 로그인**

   - **API 접근**

### 서드파티

서드파티라는 용어는 거래나 계약, 서비스에 관련된 세 주체를 의미합니다.

1. **주체 간의 관계**

   - **제1자 (First Party)**(사용자.)

   - **제2자 (Second Party)**(공급자나 서비스 제공자.)

   - **서드파티(Third Party)**(외부 주체, 독립적인 서비스나 기능을 제공하는 업체.)

2. **예시**

   - **소프트웨어**

   - **결제 시스템**

   - **애드온 및 플러그인**

3. **장점과 단점**

   - **장점**: 개발 시간 단축, 기능 확장에 유리.

   - **단점**: 보안이나 안정성 불안, 서드파티 서비스의 정책 변화나 서비스 중단 고려필요.

### WAS

WAS(Web Application Server, 웹 애플리케이션 서버)는 웹 어플리케이션을 실행하고 관리하는 서버입니다.

1. **주요 기능**

   1. **애플리케이션 실행**

   2. **비즈니스 로직 처리**

   3. **세션 관리**

   4. **통신 프로토콜 지원**

   5. **로드 밸런싱 및 확장성**

   6. **보안 기능**

2. **예시**

   - **JAVA 기반 WAS**

   - **.NET 기반 WAS**

   - **js 기반 WAS**: Node.js, Express.js, NestJS, koa.js 등

### WS

웹 서비스의 약자로, 웹 서비스는 서로 다른 애플리케이션 간에 데이터를 전송하고 상호작용할 수 있도록 해주는 소프트웨어 시스템입니다.

1. **_주요 특징_**

   1. **인터넷 기반**(다양한 플랫폼과 언어에서 호환이 가능)

   2. **표준 프로토콜**(SOAP(Simple Object Access Protocol)나 REST(Representational State Transfer)와 같은 표준 프로토콜을 사용.)

      - **SOAP**: XML 기반의 메시지 프로토콜, 보안성이 중요시되는 애플리케이션에서 사용합니다.

      - **REST**: HTTP 프로토콜을 기반으로 하며, JSON, XML 등을 사용하여 데이터를 전송합니다.

   3. **서비스 지향 아키텍처(SOA)**: 웹 서비스는 SOA의 중요한 구성 요소, 독립적으로 개발된 서비스들이 상호작용하여 더 큰 시스템을 구성합니다.

   4. **상호 운용성**: 웹 서비스는 서로 다른 시스템과 플랫폼 간의 상호 운용성을 지원한다.

2. **_사용 사례_**

   - **API 제공**

   - **비즈니스 통합**

   - **모바일 애플리케이션**

## _코딩_

## 콜백함수

### AJAX

AJAX는 Asynchronous JavaScript and XML의 약자로, 웹 페이지를 비동기적으로 업데이트할 수 있도록 해주는 기술입니다.

1. **AJAX의 주요 특징**

   1. **비동기성**(클라이언트가 서버에 요청을 보내는 동안 웹 페이지가 멈추지 않고 사용자와 상호작용.)

   2. **부분 업데이트**(웹페이지의 일부만 업데이트 가능.)

   3. **다양한 데이터 형식 지원**(다양한 데이터 형식을 지원하지만, 특히 JSON은 데이터 전송 형식으로 많이 사용하고 JS와 호환성이 높다.)

   4. **비동기 요청**(AJAX는 JS의 XMLHttpRequest 객체를 사용하여 서버에 비동기적으로 요청을 보냅니다)

2. **AJAX의 동작 방식**

   1. **사용자 인터페이스 이벤트**(이벤트 발생)

   2. **AJAX 요청 생성**(JS를 사용하여 XMLHttpRequest 객체를 생성, 서버에 비동기 요청)

   3. **서버 처리**(서버가 처리 및 응답)

   4. **응답 처리**(클라이언트 응답 받고, JS로 특정 부분 업데이트)

3. **AJAX의 장점**

   1. **빠른 사용자 경험**(부분 업데이트 장점)

   2. **서버와의 효율적인 데이터 통신**(필요한 데이터만 요청 가능)

   3. **인터렉티브한 웹 애플리케이션**(실시간 업데이트가 가능한 동적인 웹 애플리케이션 작성가능)

4. **AJAX의 단점**

   1. **SEO 문제**(CSR의 문제점과 동일)

   2. **브라우저 호환성**(구식 브라우저와의 호환성 문제)

   3. **복잡성 증가**

### 동기와 비동기

통신에서 동기(Synchronous)와 비동기(Asynchronous) 처리는 데이터 전송 및 응답을 처리하는 방식에 대한 개념입니다.

1. **동기(Synchronous)**

   - **정의**: 요청을 보낸 후, 응답을 받을 때까지 기다리는 방식.

   - **특징**: 코드의 흐름이 요청과 응답에 따라 직선적으로 진행됩니다. UI가 정지될 수 있습니다. 구현이 간단하고 이해하기 쉬운 경우가 많습니다.

   - **예시**: JS의 XMLHttpRequest 사용

2. **비동기(Asynchronous)**

   - **정의**: 요청을 보낸 후, 응답을 기다리지 않고 수행하는 방식입니다.(콜백, 프로미스)

   - **특징**: 코드의 흐름이 요청과 응답과 독립적입니다. 부분 업데이트로 UX의 향상이 가능, 비즈니스 로직을 구현에 유용하다.

### async/await 외의 비동기 처리 방법

- **Promise**

  JavaScript의 비동기 처리 방법. then, catch, finally 메서드 이용.

- **콜백 함수**

  비동기 작업이 완료된 후 호출되는 함수를 정의하여 결과를 처리합니다. 콜백 헬은 주의해야 합니다.

- **RxJS**

  Reactive Programming 라이브러리로, 스트림을 통해 비동기 데이터를 처리할 수 있습니다.

- **EventEmitter**

  Node.js의 이벤트 기반 프로그래밍 패턴을 사용하여 이벤트가 발생할 때 비동기 처리를 수행할 수 있습니다.

### RXJS

RXJS (Reactive Extenstions for JavaScript)는 비동기 데이터 흐름을 처리하기 위한 라이브러리로, 옵저버블 패턴을 사용하여 데이터를 스트림 형태로 다룹니다.

1. **주요 개념**

   1. **옵저버블 (Observable)**

      데이터 스트림을 나타내며, 데이터를 발행하는 주체입니다.

   2. **옵저버 (Observer)**

      옵저버블을 구독하고, 데이터가 발행될 때마다 알림을 받는 객체입니다.

   3. **구독 (Subscription)**

      옵저버블을 구독하는 행위로, 데이터가 발행되면 콜백이 실행됩니다.

   4. **연산자 (Operators)**

      옵저버블을 변환하거나 조작하는 함수들입니다. 예를 들어, map, filter, merge, switchMap 등의 연산자가 있습니다.

2. **기본 사용법**

   ```bash
   npm install rxjs
   ```

   ```js
   import { Observable } from "rxjs";

   // 옵저버블 생성
   const myObservable = new Observable((subscriber) => {
     subscriber.next("Hello");
     subscriber.next("World");
     subscriber.complete();
   });

   const myObserver = {
     next: (value) => console.log(value),
     error: (err) => console.error(err),
     complete: () => console.log("Done"),
   };

   // 옵저버블 구독
   myObservable.subscribe(myObserver);
   ```

3. **연산자 사용 예제**

   ```js
   import { of } from "rxjs";
   import { map, filter } from "rxjs/operators";

   const number = of(1, 2, 3, 4, 5);

   // 연산자를 사용한 예제
   const processedNumbers = numbers.pipe(
     filter((x) => x % 2 === 0), // 짝수만 통과
     map((x) => x * 10) // 각 숫자에 10 곱하기
   );

   processedNumbers.subscribe(console.log); // 20, 40
   ```

4. **장점**

   1. **콜백 지옥 회피와 간소화된 코드**

   2. **연산자 체이닝을 통한 간단한 구성 가능성**

   3. **다양한 데이터 소스를 통합, 응답성 유지**

### 데이터의 스트림 형태

데이터의 스트림 형태는 데이터를 연속적으로 생성하고 처리하는 방식을 나타냅니다.

1. **_스트림의 기본 개념_**

   1. **스트림**

      데이터의 연속적인 흐름을 나타냅니다. 스트림은 시간에 따라 변화하는 데이터 시퀸스를 의미합니다.

   2. **발행자 (Publisher)**

      데이터를 생성하고 스트림에 발행하는 주체입니다. 이는 옵저버블 형태로 구현됩니다.

   3. **구독자 (Subscriber)**

      스트림의 데이터를 소비하고 반응하는 주체입니다. 구독자는 발행자가 발행하는 데이터에 대해 반응합니다.

   4. **변환 및 조작**

      스트림의 데이터를 변환하거나 필터링하는 연산자들이 사용됩니다.

2. **_스트림의 종류_**

   1. **단방향 스트림**: 데이터가 한 방향으로만 흐릅니다.(클릭, 입력 등)

   2. **양방향 스트림**: 데이터가 양 방향으로 흐를 수 있습니다.(웹 소켓 통신)

3. **_스트림 처리의 장점_**

   1. **비동기 처리**

   2. **조합 가능성**(여러 데이터 소스를 하나의 스트림으로 결합 가능)

   3. **지연 평가**(필요할 때만 데이터를 처리할 수 있다.)

4. **예시**

   ```js
   import { fromEvent } from "rxjs";
   import { map } from "rxjs/operators";

   // 버튼 클릭 이벤트 스트림 생성
   const button = document.getElementById("myButton");
   const clicks = fromEvent(button, "click");

   // 클릭 이벤트를 처리하여 좌표를 로그에 남김
   const positions = clicks.pipe(
     map((event) => ({ x: event.clientX, y: event.clientY }))
   );

   positions.subscribe((pos) => console.log(`X: ${pos.x}, Y: ${pos.y}`));
   ```

   이벤트로 클릭할 때마다 데이터(좌표) 발행.

### Promise

Promis는 JavaScript에서 비동기 작업을 처리하기 위한 객체입니다. 주로 비동기 연산의 성공 또는 실패 결과를 다루기 위해 사용됩니다.

1. **대기(pending)**: 초기 상태로, 비동기 작업이 아직 완료되지 않은 상태입니다.

2. **이행(fulfilled)**: 비동기 작업이 성공적으로 완료되었을 때의 상태입니다. 결과 값을 반환합니다.

3. **거부(rejected)**: 비동기 작업이 실패했을 때의 상태입니다. 오류 이유를 반환합니다.

### 메서드 체이닝이란? 장단점은?

1. **메서드 체이닝(Method Chaning)이란?**

   메서드 체이닝은 객체지향 프로그래밍에서 하나의 객체에 대해 여러 메서드를 연속적으로 호출할 수 있도록 하는 방법입니다.

2. **장점**

   1. **가독성 향상**

   2. **코드 간소화**

   3. **편리한 API 설계**

3. **단점**

   1. **디버깅의 어려움**(메서드 체이닝으로 인해 각 결과를 추적하기 어려워진다. 특히 오류 발생의 위치.)

   2. **불변성의 손실**(객체가 불변성을 유지하기 힘듬)

   3. **하나의 큰 객체**(남용시에 하나의 객체가 너무 많은 책임을 가지게 된다.)

## 콜백 함수

콜백 함수는 다른 함수의 인자로 전달되어 특정 시점에 호출되는 함수를 의미합니다.

- **_주요 특징_**

  - **비동기 처리**: 콜백 함수는 주로 비동기 작업이 완료된 후 실행됩니다.

  - **유연성**: 다른 함수에 인자로 전달됨으로써, 함수의 동작을 외부에서 조작할 수 있습니다.

### 프라미스와 콜백함수의 차이점과 각각의 장단점은?

프라미스와 콜백함수는 자바스크립트에서 비동기 작업을 처리하는 두 가지 주요 방법입니다.

1. **_콜백 함수_**

   콜백 함수는 특정 작업이 완료된 후 호출되는 함수입니다.(인수로 사용되는 함수)

   1. **_장점_**

      1. **단순함**(간단한 작업은 구현이 쉽고 직관적)

      2. **전통적인 사용법**(JS에서 주로 쓰이는 방식)

   2. **_단점_**

      1. **콜백 지옥**

      2. **에러 처리 어려움**

2. **_프라미스_**

   프라미스는 비동기 작업의 완료 또는 실패를 나타내는 객체입니다.

   1. **_장점_**

      1. **가독성**(메서드 체이닝 활용으로 읽기 쉬움)

      2. **에러 처리**(catch 메서드 활용으로 한곳에서 모든 오류 처리 가능)

      3. **비동기 코드 흐름 관리**(async, await를 활용할 수 있음)

   2. **단점**

      1. **복잡성**(경우에 따라 더 복잡함)

      2. **상태 관리**(이행, 거부, 대기를 모두 관리해야 함)

   3. **비동기 처리 방식**

      - **콜백함수**: 비동기 작업이 완료되면 호출됩니다.

      - **프라미스**: 비동기 작업의 완료 또는 실패를 나타내는 객체입니다.

   4. **가독성**

      - **콜백 함수**: 중첩되면 콜백지옥.

      - **프라미스**: then, catch의 메서드 체이닝으로 상대적으로 가독성이 좋은 편입니다.

   5. **에러 처리**

      - **콜백 함수**: 각 콜백.

      - **프라미스**: catch 블록.

   6. **비동기 흐름 제어**

      - **콜백 함수**: 복잡함.

      - **프라미스**: async/await로 제어 가능.

   7. **단순성**

      - **콜백 함수**: 간단한 비동기 작업.

      - **프라미스**: 복잡한 비동기 작업.

### 콜백지옥

콜백지옥은 비동기 프로그래밍에서 콜백 함수가 중첩되어 작성될 때 발생하는 코드의 가독성 저하와 유지보수 어려움을 의미합니다.

1. **특징**

   1. **중첩된 구조**

   2. **가독성 저하**

   3. **에러 처리의 복잡성**

2. **해결 방법**

   1. **Promise**

   2. **async/await**

## 코딩이론

### 추상화

추상화(Abstraction)는 복잡한 시스템이나 개념을 단순화하여 중요한 정보나 특성만을 드러내고, 불필요한 세부사항을 숨기는 과정입니다.

1. **_소프트웨어 개발에서의 추상화_**

   1. **목적**: 코드의 복잡성을 줄이고, 재사용성을 높이고, 시스템의 이해도를 높이는 것입니다.

   2. **예시**

      1. **객체지향 프로그래밍**: 클래스와 객체를 사용하여 복잡한 현실 세계의 개념을 모델링합니다.

      2. **API**: 제공되는 기능의 세부사항을 알 필요가 없게 만듭니다.(예: OAUTH 로직이나 위치추적 로직 등)

2. **_추상화의 유형_**

   1. **데이터 추상화**: 필요한 기능만을 노출하는 방법.

   2. **절차적 추상화**: 복잡한 알고리즘이나 프로세스를 여러 개의 간단한 단계로 나누는 방법.

3. **_장점_**

   1. **복잡성 감소**

   2. **재사용성**

   3. **유지보수 용이성**(모듈화가 잘 이루어진다)

4. **_단점_**

   1. **성능 저하**(불필요한 오버헤드 증가)

   2. **추상화의 오해**(기능이나 성격을 착각하게 할 수 있음)

### 원시 타입과 참조타입에 대해서

1. **_원시 타입 (Primitive Type)_**

   - **정의**: 단일 값으로 표현되며, 불변(immutable)입니다.

   - **종류**: JS에서는 string, number, boolean, null, undefined, symbol, bigint가 원시 타입입니다.

   - **저장 방식**: 값 자체가 스택에 저장됩니다.

2. **_참조 타입(Reference Type)_**

   - **정의**: 객체 형태로 여러 값을 포함할 수 있으며, 가변(mutable)입니다.

   - **종류**: Object, Array, Function, Date, 사용자 정의 객체 등입니다.

   - **저장 방식**: 값이 힙에 저장되고, 변수에는 해당 값의 참조(주소)가 저장됩니다.

### 가비지 컬렉터(Garbage Collector, GC)

더 이상 필요하지 않은 객체를 찾아 메모리에서 해제함으로써 메모리 누수를 방지하고, 효율적으로 메모리를 관리하는 시스템입니다.

1. **가비지 컬렉션의 원리**

   1. **메모리 할당**(객체의 메모리 할당)

   2. **참조 카운팅**(각 객체는 자신을 참조하는 다른 객체의 수를 추적)

   3. **루트 검색**(가비지 컬렉터는 **루트**라고 불리는 참조 집합(전역 변수, 스택 변수 등)을 기준으로 여전히 참조되고 있는 객체들을 추적)

   4. **가비지 식별**(루트에서 도달할 수 없는 객체는 가비지로 간주)

   5. **메모리 해제**(메모리에서 해제)

2. **가비지 컬렉션의 방식**

   1. **Mark-and-Sweep**: 객체를 마킹하여 사용중과 사용하지 않은 객체를 구분한 후, 사용하지 않은 객체를 메모리에서 해제합니다.

   2. **Generational Garbage Collection**: 객체의 생애 주기에 따라 세대별로 구분하여 관리합니다.

      - **원리**: **young generation**(새로 생성된 객체), **old generation**(일정 시간이 지난 객체)로 분리하고, 대부분의 객체는 짧은 생애를 가지므로 **young generation**에서 자주 가비지 컬렉션이 수행됩니다.

   3. **Reference Counting**: 각 객체의 참조 카운트를 유지, 카운트가 0이 되는 객체를 즉시 해제합니다.(순환 참조는 해결 못함)

3. **장점**

   - **메모리 관리의 자동화**

   - **메모리 누수 방지**

4. **단점**

   - **성능 저하**(가비지 컬렉션이 수행되는 동안 프로그램이 일시 중지될 수 있음)

   - **예측 불가능성**(자동 메모리 관리 시스템이므로 예측불가)

### 순환참조

순환참조(Circular Reference)는 두 개이상의 객체가 서로를 참조하여 발생하는 상황을 말합니다.

1. **_문제점_**

   1. **메모리 누수**

   2. **가비지 컬렉션의 비효율성**(참조 카운팅 방식은 인식하지 못함)

2. **_해결방법_**

   1. **마크 앤 스위프**: 루트에서 접근 가능한 객체르 마킹한 후, 마킹되지 않은 객체릃 해제합니다.

   2. **Weak Reference**: 참조된 객체가 다른 강한 참조가 없을 경우, 가비지 컬렉션의 대상이 됩니다.

   3. **명시적 해제**: 순환 참조를 미리 방지하거나, 객체의 참조를 명시적으로 해제합니다.

### 리팩토링

리팩토링(Refactoring)은 기존의 코드 구조를 개선하면서도 외부의 동작이나 기능은 변경하지 않는 과정을 의미합니다.

1. **_리팩토링의 목적_**

   1. **가독성 향상**

   2. **유지보수성 증대**(코드를 명확하고 체계적으로 구성)

   3. **중복 제거**

   4. **성능 최적화**

   5. **테스트 용이성**

2. **_리팩토링의 기법_**

   1. **코드 정리**

   2. **함수 및 메서드 분리**(분할)

   3. **변수 및 함수 이름 개선**

   4. **클래스 추출**(분할)

   5. **중복 코드 통합**

3. **_리팩토링의 중요성_**

   1. **품질 향상**

   2. **팀워크 개선**

   3. **비용 절감**(초기 개발 단계에서 진행)

4. **_리팩토링의 주의점_**

   1. **기능 변경 없음**

   2. **점진적 진행**

   3. **버전 관리**

### 클린 코드와 리팩토링 차이

- **_클린 코드_**

  1. **_정의_**: 읽기 쉽고 이해하기 쉬우며, 유지보수가 용이한 코드를 의미합니다.

  2. **_특징_**

     1. **가독성**

     2. **명확한 네이밍**

     3. **일관성**

     4. **단일 책임 원칙(SRP)**(각 함수나 클래스는 하나의 책임만을 가져야 한다)

     5. **테스트 용이성**

  3. **_초점_**:클린 코드는 코드 작성 시부터 품질을 높이는 것을 목표로 합니다.

- **_리팩토링_**

  1.  **_정의_**: 기존의 코드를 개선하면서도 기능을 변경하지 않고, 코드의 구조를 재조정하는 작업입니다.

  2.  **_특징_**

      1. **기존 코드 개선**

      2. **기능 불변성**

      3. **점진적 접근**

  3.  **_초점_**: 이미 작성된 코드의 품질을 향상시키기 위한 방법입니다.

### Call By Value와 Call By Reference

Call By Value와 Call By Reference는 함수에 인수를 전달하는 두 가지 주요 방식입니다.

- **_Call By Value_**

  1.  **정의**: 함수 호출 시, 인수의 값이 복사되어 함수에 전달됩니다.

  2.  **특징**

      - **복사**

      - **안정성**(원본 데이터는 변경되지 않음)

      - **메모리 사용 급증 가능성**(인수가 큰 데이터 구조일 경우, 복사로 인한 메모리 사용량 증가)

- **_Call BY Reference_**

  1.  **정의**: 함수 호출 시, 인수의 메모리 주소(참조)가 전달됩니다.

  2.  **특징**

      - **주소 전달**

      - **부작용**(원본 데이터가 변경될 수 있음)

      - **메모리 사용 급증 없음**(인수가 큰 데이터 구조라도, 메모리 사용량이 주소 복사이기에 급증하지 않는다.)

### TDD

테스트 케이스를 먼저 작성한 후 그에 맟춰 코드를 구현하는 방법론입니다.

1. **_TDD의 주요 단계_**

   1. **Red (테스트 실패)**: 구현할 기능에 테스트 케이스를 작성, 기능은 구현되지 않은 상태(실패해야 함).

   2. **Green (테스트 통과)**: 테스트 케이스를 통과시키기 위해 최소한의 코드를 작성합니다. 모든 테스트가 통과하는지 확인합니다.

   3. **Refactor (리팩토링)**: 코드가 잘 작동하면, 코드의 품질을 개선합니다.

2. **_TDD의 장점_**

   1. **버그 감소**: 테스트를 먼저 작성하기 때문에 코드의 결함을 사전에 발견할 수 있습니다.

   2. **리팩토링 용이**: 작성된 테스트로 리팩토링 후도 쉽게 검증 가능하다.

   3. **설계 개선**: 코드의 구조와 설계에 시간을 더 쏟게 된다.

   4. **명확한 요구 사항**

3. **TDD의 단점**

   - **시간 소요**: 개발 초기에는 시간과 노력이 더 들 수 있습니다.(테스트 케이스 작성)

   - **학습 곡선**: TDD의 개념을 익히고 적응하는 데 시간이 필요합니다.

   - **과도한 테스트**: 불필요한 테스트가 작성될 수도 있습니다.

### CI/CD

1. **CI (Continuous Integration)(지속적 통합)**: 개발자들이 코드를 자주 (보통 하루에 여러 번) 통합하는 방법입니다.

   - 각 코드 변경 사항은 자동으로 빌드되고 테스트되어, 통합 후 발생할 수 있는 문제를 빠르게 발견할 수 있습니다.

2. **CD (Continuous Delivery / Continuous Deployment)**

   CI의 확장으로, 코드 변경 사항이 자동으로 프로덕션 환경에 배포되는 프로세스입니다.

   - **Continuous Delivery**: 모든 코드 변경이 테스트를 통과하면 언제든지 배포할 준비가 되어 있는 상태입니다.(배포는 수동)

   - **Continuous Deployment**: 코드 변경이 자동으로 프로덕션 환경에 배포됩니다.

3. **장점**

   - **빠른 피드백**: 코드 변경마다 자동으로 테스트가 이루어져, 문제를 조기에 발견할 수 있습니다.

   - **일관된 품질**: 자동화된 테스트나 빌드를 통해 품질이 일관되게 유지됩니다.

   - **신속한 배포**

   4. **효율적인 협업**

### 트러블 슈팅 경험

트러블 슈팅 경험은 문제를 진단하고 해결하는 과정에서의 경험을 읨합니다.

1. **문제 정의**: 문제를 명확히 정의한다.

2. **정보 수집**: 로그 파일, 모니터링 도구, 사용자 피드백 등을 통해 문제의 원인을 파악할 수 있습니다.

3. **가설 설정**

4. **원인 분석**:가설을 검증하기 위한 추가 조사를 진행합니다.

5. **해결책 구현**

6. **결과 검증**: 문제 해결한 후, 결과를 검증합니다.

7. **문서화**: 문제의 원인, 해결 방법, 이후 예방 조치 등을 문서화합니다.

## 프론트엔드

### CSS 적용 순서

CSS 적용 순서는 스타일 시트가 HTML 문서에 적용되는 순서를 정의합니다.

1. **우선 순위 (Specificity)**

   CSS 선택자의 특이성에 따라 스타일이 적용됩니다.

   1. **인라인 스타일**: 1000점

   2. **ID 선택자**: 100점

   3. **클래스, 속성, 가상 클래스 선택자**: 10점

   4. **태그(요소) 선택자**: 1점

2. **출처 순서 (Source Order)**

   특정한 스타일이 여러 번 정의된 경우, 마지막에 선언된 스타일이 적용됩니다.

3. **스타일 적용 순서**

   밑의 순서대로.

   1. **브라우저 기본 스타일**: 각 브라우저는 기본적으로 제공하는 스타일이 있습니다.

   2. **사용자 스타일 시트**: 사용자가 브라우저에서 정의한 스타일이 있을 수 있습니다.

   3. **외부 스타일 시트**: \<link> 태그를 추가한 외부 CSS 파일의 스타일이 적용됩니다.(나중 스타일이 앞의 스타일을 덮어씀)

   4. **내부 스타일 시트**: \<style> 태그 안에 정의된 CSS가 적용됩니다.

   5. **인라인 스타일**: HTML 요소의 style 속성으로 정의된 CSS가 가장 높은 우선순위를 가집니다.

4. **!important 규칙**

   CSS 규칙에 !important를 추가하면 해당 스타일이 가장 높은 우선 순위를 가집니다.(일반적인 규칙의 적용 순서 무시 가능)

### 모달과 팝업의 차이

모달(Modal)과 팝업(Popup)은 웹에서 사용되는 인터페이스 요소로 사용자에게 추가적인 정보를 제공하거나 특정 작업을 유도하는 데 사용됩니다.

1. **_모달(Modal)_**

   1. **정의**: 모달은 사용자가 특정 작업을 완료할 때까지 다른 작업을 차단하는 대화상자입니다.(오버레이(겹침), 상호작용 요구)

   2. **특징**

      1. **블로킹**(다른 요소와 상호작용 불가)

      2. **명확한 목적**

      3. **일관된 디자인**(대부분은 비슷함)

   3. **사용 예**: 로그인 폼, 경고 메시지, 사용자 설정 변경 등.

2. **_팝업(Popup)_**

   1. **정의**: 팝업은 일반적으로 새로운 브라우저 창이나 탭으로 열리는 추가 콘텐츠입니다.

   2. **특징**

      1. **비블로킹**

      2. **자유로운 이동**(기존 페이지에 독립적)

      3. **사용 예**: 광고, 쿠키 등의 요청, 외부 링크로 연결되는 콘텐츠.

3. **_요약_**

   1. **모달**:

      1. 현재 작업을 차단하고, 사용자에게 특정 작업을 요구하는 대화 상자.

      2. 블로킹, 명확한 목적, 주로 중요한 정보나 입력을 요청할 때 사용.

   2. **팝업**:

      1. 새로운 브라우저 창이나 탭으로 열리며, 배경 페이지와 독립적으로 존재.

      2. 비블로킹, 광고나 외부 콘텐츠를 표시할 때 주로 사용.

### inline과 inline block의 차이

inline과 inline-block은 CSS에서 요소의 레이아웃을 설정하는 두 가지 값입니다.

- **주요 차이점 요약**

      1. **배치 방식**:

         - **Inline**: 같은 줄에서 흐름.

         - **Inline-block**: 같은 줄에서 흐름.

      2. **크기 조정**:

         - **Inline**: width와 height를 지정할 수 없음.

         - **Inline-block**: width와 height를 지정할 수 있음.

      3. **마진과 패딩**

         - **Inline**: 좌우 마진/패딩만 적용

         - **Inline-block**: 상하좌우 모두 적용

      4. **예시 요소**

         - **Inline**: \<span>, \<a>, \<strong> 등

         - **Inline-block**: \<div>, \<img>, 사용자 정의 요소 등

### 이벤트 위임

event Delegation, 이벤트 처리기법이며,
이 방법은 이벤트를 부모 요소에 설정하고, 자식 요소에서 발생한 이벤트를 부모 요소에서 처리하도록 하는 방식입니다.

1. **_작동 원리_**

   1. **이벤트 캡처링과 버블링**

      1. 이벤트가 발생하면 DOM 트리에서 아래에서 위로(bubbling) 또는 위에서 아래로 (capturing) 전달됩니다.

      2. 이벤트 위임은 주로 버블링 단계에서 발생하는데, 자식 요소에서 발생한 이벤트가 부모 요소로 전파될 때 부모에서 이를 감지하여 처리합니다.

   2. **부모 요소에 이벤트 리스너 추가**: 부모 요소에 이벤트 리스너를 추가하고, 이벤트가 발생했을 때 이벤트 객체를 통해 어떤 자식 요소에서 발생했는지를 확인합니다.

2. **_장점_**

   1. **성능 향상**(하나의 리스너로 처리, 메모리 사용량 줄어듬)

   2. **동적 요소 처리**(새로운 자식 요소에도 자동으로 이벤트가 추가된다)

   3. **코드 간소화**(한 곳에서 이벤트 처리하므로 코드 간소화)

3. **_단점_**

   1. **이벤트 전파 관리**(다른 요소에서 이벤트가 발생할 수 있으므로, 조건문 등으로 관리 필요)

   2. **이벤트 핸들러의 맥락**(this 바인딩이 부모요소를 기준으로 되어있다.)

### GraphQL

GraphQL은 API를 설계하고 쿼리하기 위한 쿼리 언어이자, 서버와 클라이언트 간의 데이터를 효율적으로 전송할 수 있도록 돕는 런타임 환경입니다.

1. **주요 특징**

   1. **선택적 데이터 요청**(클라이언트는 필요한 데이터 구조를 명시적으로 요청 가능)

   2. **단일 엔드포인트**

   3. **타입 시스템**(API의 데이터 구조를 명확하게 정의 가능)

   4. **실시간 데이터**(서브스크립션 기능 지원)

   5. **강력한 개발자 도구**(GraphQL에는 API 문서화를 위한 도구가 제공됨)

2. **Subscription**

   - **정의**:클라이언트가 특정 이벤트에 대해 실시간으로 데이터 업데이트를 받을 수 있도록 합니다.

   - **작동**:클라이언트가 서버에 구독을 요청하면, 서버는 해당 이벤트가 발생할 때마다 클라이언트에 데이터를 푸시(push)합니다.(옵저버 패턴과 유사)

   - **용도**: 채팅, 피드업데이트 등.

### 템플릿 엔진

동적인 웹 페이지를 생성하기 위해 HTML 파일 내에 JS 코드를 삽입하여 데이터를 출력하는 도구입니다.

1. **특징**

   1. **변수 삽입**

   2. **조건문 및 반복문 지원**

### 디자이너가 psd 파일 또는 jpg 파일만 주었을 때 구현 가능?(해당 이미지를 청사진으로서 활용하는 경우의 고려사항)

1. **구현 가능성**

   1. **PSD 파일**:

      1. PSD 파일은 레이어, 텍스트, 벡터 이미지 등을 포함할 수 있어 디자인 요소를 세밀하게 조정할 수 있습니다.

      2. **장점**: 각 요소를 개별적으로 추출하고 수정할 수 있으므로, UI 요소나 아이콘 등을 쉽게 사용할 수 있습니다.

      3. **단점**: 전용 소프트웨어 필요, 변환 작업 필요.

   2. **JPG 파일**:

      1. JPG 파일은 정적 이미지로, 주로 배경 이미지나 아이콘으로 사용.

      2. **장점**: 간단하게 사용할 수 있습니다.

      3. **단점**: JPG는 비트맵 이미지이기 때문에 확대하면 품질이 떨어지고, 세부조정이 불가능합니다.

2. **구현 절차**

   1. **디자인 분석**

   2. **HTML 구조 작성**

   3. **CSS 스타일링**

   4. **이미지 활용**

   5. **반응형 디자인**

   6. **테스트 및 디버깅**

## 백엔드

### 백엔드 프레임워크의 종류

백엔드 프레임워크는 서버 측 애플리케이션을 개발하는 데 도움을 주는 소프트웨어 프레임워크입니다.

1. **Express.js**

   - **정의**: Node.js 기반 프레임워크, 가볍고 유연하다.

   - **특징**: 미들웨어 사용, RESTful API 적합, 간단하고 직관적인 라우팅.

2. **Koa**

   - **정의**: Express보다 미들웨어 관리와 구조화가 쉽다.

   - **특징**: async/await 지원, 비동기 코드 작성 용이, 경량 구조.

3. **Nest.js**

   - **정의**: 유연하고 확장성이 좋은 프레임워크로 플러그인 시스템 사용.

   - **특징**: 모듈화된 아키텍처와 의존성 주입 가능, 대규모 애플리케이션 개발에 좋음.

4. **Hapi.js**

   - **정의**: 유연하고 확장성이 좋은 서버 프레임워크, 플러그인 시스템 사용.

   - **특징**: 안정성과 보안 기능, RESTful API 및 웹 애플리케이션 개발에 적합.

5. **Sails.js**

   - **정의**: express 기반 MVC 프레임워크.

   - **특징**: 실시간 웹 애플리케이션과 RESTful API 구축에 적합, 데이터베이스 ORM인 Waterline 사용.

6. **Fastify**

   - **정의**: 매우 빠르고 가벼운 서버 프레임워크, 고성능 애플리케이션 개발 적합.

   - **특징**: 플러그인 아키텍쳐 사용, JSON 기반의 요청과 응답 처리에 최적화.

### 의존성 주입 (Dependency Injection)

- **정의**: 객체 간의 의존성을 관리하는 디자인 패턴으로 객체가 의존성을 외부에서 주입받는 방식입니다.

- **특징**:

  - **유연성**(코드의 재사용성 향상, 결합도 약하게)

  - **테스트 용이성**

  - **자동 설정 관리**(객체 생성과 의존성 관리를 프레임워크가 처리)

### 의존성 주입이 유용한 이유(자필)

라이브러리나 프레임워크의 모듈을 활용하면서도, 기존의 코드의 변경이 적다는 점에서 의존성 주입 패턴은 매우 유용하다.

### Waterline

- **_정의_**: Sail.js의 기본 ORM(Object-Relational Mapping)으로 다양한 데이터베이스와 상호작용할 수 있는 추상화된 레이어를 제공합니다.

- **특징**:

  - **다양한 데이터베이스 지원**: SQL 기반의 관계형 데이터 베이스와 NoSQL 데이터베이스 모두 지원합니다.

  - **간단한 쿼리 언어**

  - **모델 기반**: 데이터 모델을 정의, 데이터베이스와의 상호작용 단순화.

### 런타임

- **정의**: 프로그램이 실행되는 환경, 운영 체제, 메모리, 라이브러리 및 런타임 시스템을 포함합니다.

- **예시**: Java Virtual Machine (JVM)과 같은 특정 플랫폼에서 실행되는 애플리케이션이 있습니다.

### 프레임워크와 라이브러리 모듈

1. **프레임워크(Framework)**

   - **정의**: 특정한 아키텍처와 규칙을 제공하여 애플리케이션을 구조화하는 기본 뼈대.

   - **특징**: 개발자가 프레임워크에 맞춰 코드를 작성해야 하며, 제어의 흐름이 프레임워크에 있습니다.

2. **라이브러리 (Library)**

   - **정의**: 특정 기능이나 작업을 수행하기 위해 미리 작성된 코드 집합.

   - **특징**: 개발자가 호출하는 방식으로, 제어의 흐름이 개발자에게 있습니다.

3. **모듈(Module)**

   - **정의**: 특정 기능을 캡슐화하여 재사용 가능한 코드 단위.

   - **특징**: 서로 다른 모듈 간의 의존성을 관리 가능, 다른 모듈에서 쉽게 가져다 쓸 수 있습니다. ES6 모듈, CommonJS 모듈이 있습니다.

### Express

Express는 Node.js 환경에서 웹 애플리케이션 및 API를 구축하기 위한 간편하고 유용한 프레임워크입니다.

1. **주요 특징**

   1. **경량 및 유연성**(필요한 기능만 선택적으로 추가 가능)

   2. **미들웨어**(요청과 응답 객체 처리하는 함수)

   3. **라우팅**

   4. **템플릿 엔진 통합**(다양한 템플릿 엔진과 통합할 수 있음)

   5. **RESTful API 개발 적합**

   6. **활발한 커뮤니티와 큰 생태계**

## 아키텍처 및 프로그래밍 패러다임

### 프로토타입

**_유형_**

1. **소프트웨어 개발**(소프트웨어의 초기 버전이나 모형)

2. **프로토타입 패턴**(객체지향 프로그래밍에서, 기존 객체를 복사하여 새로운 객체를 생성하는 디자인 패턴입니다.)

3. **웹 개발**(웹 애플리케이션의 구조와 기능을 시각적으로 표현한 모델)

### 아키텍처

아키텍처(Architecture)는 특정 시스템이나 소프트웨어의 구조와 조직을 설명하는 개념.

1. **_시스템 구조_**

   1. **구성 요소**(시스템을 이루는 요소(모듈, 컴포넌트 등)들과 그 기능.)

   2. **관계**(구성 요소들 간의 상호작용 및 의존 관계)

2. **_설계 원칙_**

   1. **표준**: 시스템의 설계를 위한 가이드라인이나 규칙.

   2. **패턴**: 자주 사용되는 설계의 형태나 방법론.

3. **_기술 스택_**(프로그래밍 언어, 프레임워크, 데이터베이스, 서버 등)

4. **_성능 및 확장성_**

   1. **성능 고려사항**: 시스템이 얼마나 빠르고 효율적으로 작동하는지에 대한 기준.

   2. **확장성**

5. **_사용자 요구사항_**

   1. **기능적 요구사항**(사용자가 원하는 기능.)

   2. **비기능적 요구사항**(성능, 보안, 사용성 등 시스템의 품질 속성)

### AOP (Aspect-Oriented Programming)

1. **_AOP의 주요 개념_**

   1. **Aspect(관점)**: 공통적인 기능을 캡슐화한 모듈입니다.

   2. **Join Point (조인 포인트)**: 프로그램 실행 중에 Aspect가 적용될 수 있는 지점입니다.(메서드 호출, 객체 생성 등)

   3. **Advice (어드바이스)**: Aspect가 특정 조인 포인트에서 실행하는 코드입니다.

      - **Before**: 조인 포인트 이전에 실행됩니다.

      - **After**: 조인 포인트 이후에 실행됩니다.

      - **Around**: 조인 포인트 실행하기 전후에 실행됩니다.

   4. **Pointcut (포인트 컷)**: 어떤 Aspect가 어디에서 실행될지를 결정합니다.

2. **_AOP의 장점_**

   - **코드의 모듈화**

   - **재사용성**

   - **유연성**

3. **AOP의 사용 예**: 로깅, 보안, 트랜잭션 처리 등과 같은 공통 기능을 관리.

### 데코레이터 패턴이란

기존 객체를 수정하지 않고도 기능을 확장할 수 있게 해주며, 객체를 래핑(wrapping)하여 추가적인 기능을 부여합니다.

**주요 특징**

- **유연성**(기존 코드를 변경하지 않고 테코레이터 객체를 생성하여 기능 추가.)

- **확장성**(여러 데코레이터를 조합하여 객체의 기능을 다양하게 확장할 수 있음.)

- **Single Responsibility Principle**(각 데코레이터는 특정 기능을 담당하므로, 코드의 책임을 분리할 수 있음.)

### 싱글톤 패턴

싱글톤 패턴(Singleton Pattern)은 클래스의 인스턴스가 오직 하나만 생성되도록 보장하는 디자인 패턴입니다.

- **주요 특징**

  - **단일 인스턴스**(클래스의 인스턴스가 하나만 존재함)

  - **전역 접근**

  - **지연 초기화**(필요할 때까지 인스턴스를 생성하지 않고, 대체로 최초 요청 시 생성함)

### MVC 패턴

1. **_MVC 패턴의 구조_**

   1. **Model (모델)**: 애플리케이션의 데이터와 비즈니스 로직, 데이터 처리 및 상태 관리를 담당합니다. 데이터를 변경할 때, 이벤트를 발생시켜 컨트롤러에 알립니다.

   2. **View (뷰)**: 사용자에게 보여지는 인터페이스를 담당합니다. 사용자가 입력한 정보를 받아서 컨트롤러에 전달합니다. 뷰는 모델의 변화에 반응하여 갱신합니다.

   3. **Controller (컨트롤러)**: 사용자 입력을 처리하고, 모델과 뷰에 전달하는 역할을 합니다. 이를 통해 모델과 뷰는 직접적으로 상호작용 하지 않습니다.

2. **MVC 패턴의 장점**

   - **분리된 관심사\[책임\](concerns)**(각 구성 요소가 독립적.)

   - **재사용성**(하나의 모델을 여러 뷰에서 사용가능.)

   - **유연성**(각 요소가 독립적이므로, 유연하게 대응 가능)

### 클라이언트 서버 구조

- **_정의_**: 네트워크에서 클라이언트와 서버 간의 상호작용.

- **_주요 요소_**

  1.  **클라이언트**(요청을 보내거나 데이터를 받는 프로그램이나 장치)

  2.  **서버**(요청을 처리하고, 필요한 데이터를 제공하는 시스템.(웹서버))

- **작동 방식**: 클라이언트가 서버에 요청을 보내면, 서버는 해당 요청을 처리하고 응답을 클라이언트로 반환합니다.

### 클라이언트 서버 모델의 특징

1. **분리된 역할**

2. **네트워크 통신**

3. **확장성**(서버는 여러 클라이언트를 동시에 처리 가능, 필요에 따라 서버를 추가할 수도 있음)

4. **보안**(서버에서 데이터를 처리하기 때문에)

5. **데이터 저장**(중앙(db나 서버)에서 데이터 저장, 일관성과 무결성 유지)

### 플러그인 기반 아키텍처

플러그인 기반 아키텍처(Plugin-Based Architecture)는 소프트웨어 시스템의 기능을 모듈화하고 확장 가능하게 설계하는 접근방식입니다.

### 마이크로 서비스 아키텍처(MSA)

MSA(microservices Architecture)는 소프트웨어 개발 패러다임으로, 애플리케이션을 여러 개의 작은 독립적인 서비스로 구성하는 방식입니다.

1. **_MSA의 주요 특징_**

   1. **독립성**(서로에게 영향을 미치지 않음)

   2. **기능 중심**(기능이나 도메인에 초점을 맞춤)

   3. **다양한 기술 스택**(각 마이크로서비스는 필요한 기술 스택을 자유롭게 선택가능)

   4. **API 기반 통신**(응답의 추상화 덕분에 결합도가 느슨하다)

   5. **자동화 및 오케스트레이션**(배포와 관리를 자동화하기 위한 도구와 기술)

2. **_MSA의 장점_**

   1. **유연성**(서버의 독립적인 배포와 확장 덕.)

   2. **팀 분산**

   3. **스케일링**(부하가 쏠린 서비스만 확장하면 됨)

   4. **신뢰성**(하나의 서비스 장애 발생시 전체 시스템이 다운되지 않음)

3. **MSA의 단점**

   1. **복잡성 증가**(여러 개의 서비스 관리와 모니터링)

   2. **운영 비용**(여러 개의 서비스 관리와 모니터링)

   3. **데이터 관리**(여러 개의 서비스에서의 db 관리)
