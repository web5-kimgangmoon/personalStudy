# 개인공부용 git 문서입니다. (chatgpt 답변)

## RESTful API

RESTful API는 Representational State Transfer(REST) 원칙을 따르는 웹 서비스 인터페이스입니다. REST는 클라이언트와 서버 간의 상호작용을 정의하는 아키텍처 스타일로, 다음과 같은 주요 개념이 있습니다:

1. 자원(Resource)
   REST API는 URI(Uniform Resource Identifier)를 사용하여 자원을 식별합니다. 각 자원은 고유한 URI로 접근할 수 있습니다.
2. HTTP 메서드
   REST API는 다음과 같은 HTTP 메서드를 사용하여 자원에 대한 작업을 수행합니다:
   GET: 자원 조회
   POST: 새로운 자원 생성
   PUT: 자원 전체 업데이트
   PATCH: 자원 부분 업데이트
   DELETE: 자원 삭제
3. 상태 비저장성(Stateless)
   REST API의 각 요청은 독립적이며, 서버는 클라이언트의 상태를 저장하지 않습니다. 모든 필요한 정보는 클라이언트가 요청에 포함시켜야 합니다.
4. 표현(Representation)
   자원은 다양한 형식(예: JSON, XML)으로 표현될 수 있습니다. 클라이언트는 원하는 형식을 서버에 요청할 수 있습니다.
5. 캐싱(Caching)
   REST는 응답을 캐시할 수 있는 기능을 제공하여 성능을 향상시킬 수 있습니다.
6. 계층화(Layered System)
   REST 아키텍처는 여러 계층으로 구성될 수 있으며, 클라이언트는 중간 서버의 존재를 알지 못합니다.
   예시
   간단한 RESTful API의 예시는 다음과 같습니다:

GET /api/users: 모든 사용자 조회
GET /api/users/1: 특정 사용자 조회
POST /api/users: 새로운 사용자 생성
PUT /api/users/1: 특정 사용자 정보 업데이트
DELETE /api/users/1: 특정 사용자 삭제
이와 같은 RESTful API는 클라이언트와 서버 간의 상호작용을 간결하고 일관성 있게 만들어줍니다.

# 동기와 비동기

통신에서 동기(Synchronous)와 비동기(Asynchronous) 처리는 데이터 전송 및 응답을 처리하는 방식에 대한 개념입니다. 각각의 차이점을 살펴보면 다음과 같습니다:

1. 동기(Synchronous)
   정의: 요청을 보낸 후, 응답을 받을 때까지 기다리는 방식입니다. 즉, 다음 작업을 수행하기 전에 반드시 응답을 받아야 합니다.
   특징:
   코드의 흐름이 요청과 응답에 따라 직선적으로 진행됩니다.
   사용자가 기다리는 동안 UI가 정지할 수 있습니다(특히 브라우저의 경우).
   구현이 간단하고 이해하기 쉬운 경우가 많습니다.
   예시: JavaScript의 XMLHttpRequest를 사용할 때 async를 false로 설정하면 동기 방식으로 요청이 처리됩니다.
2. 비동기(Asynchronous)
   정의: 요청을 보낸 후, 응답을 기다리지 않고 다음 작업을 수행하는 방식입니다. 응답은 나중에 받을 수 있으며, 일반적으로 콜백이나 프로미스를 사용하여 처리합니다.
   특징:
   코드의 흐름이 요청과 응답과 독립적입니다.
   사용자가 기다리는 동안 UI가 정상적으로 작동하며, 더 나은 사용자 경험을 제공합니다.
   복잡한 비즈니스 로직을 구현할 때 유용합니다.

## async/await

Promise: JavaScript의 기본 비동기 처리 방법입니다. then()과 catch() 메서드를 사용하여 비동기 작업의 결과를 처리합니다.

콜백 함수: 전통적인 방식으로, 비동기 작업이 완료된 후 호출되는 함수를 정의하여 결과를 처리합니다. 하지만 콜백 헬(callback hell) 문제로 코드 가독성이 떨어질 수 있습니다.

RxJS: Reactive Programming 라이브러리로, 스트림을 통해 비동기 데이터를 처리할 수 있습니다. 복잡한 비동기 로직을 간결하게 표현할 수 있습니다.

Generator 함수: function\* 문법을 사용하여 제너레이터를 생성하고, yield 키워드를 통해 비동기 처리를 할 수 있습니다. co 라이브러리와 함께 사용하면 비동기 코드 작성이 더 수월해질 수 있습니다.

EventEmitter: Node.js의 이벤트 기반 프로그래밍 패턴을 사용하여 이벤트가 발생할 때 비동기 처리를 수행할 수 있습니다.

## Promise

Promise는 JavaScript에서 비동기 작업을 처리하기 위한 객체입니다. 주로 비동기 연산의 성공 또는 실패 결과를 다루기 위해 사용됩니다. Promise는 세 가지 상태를 가집니다.

1. 대기(pending):
   초기 상태로, 비동기 작업이 아직 완료되지 않은 상태입니다.
2. 이행(fulfilled):
   비동기 작업이 성공적으로 완료되었을 떄의 상태입니다. 이 경우, 결과 값을 반환합니다.
3. 거부(rejected):
   비동기 작업이 실패했을 때의 상태입니다. 이 경우, 오류 이유를 반환합니다.

## CICD

네, CI/CD는 소프트웨어 개발 프로세스를 자동화하는 중요한 개념입니다. 각각의 의미는 다음과 같습니다:

CI (Continuous Integration)
지속적 통합: 개발자들이 코드를 자주 (보통 하루에 여러 번) 통합하는 방법입니다. 각 코드 변경 사항은 자동으로 빌드되고 테스트되어, 통합 후 발생할 수 있는 문제를 빠르게 발견할 수 있습니다. 이를 통해 코드 품질을 높이고, 팀의 협업을 원활하게 합니다.
CD (Continuous Delivery / Continuous Deployment)
지속적 배포: CI의 확장으로, 코드 변경 사항이 자동으로 프로덕션 환경에 배포되는 프로세스입니다.
지속적 배포 (Continuous Delivery): 모든 코드 변경이 테스트를 통과하면 언제든지 배포할 준비가 되어 있는 상태입니다. 배포는 수동으로 진행됩니다.
지속적 배포 (Continuous Deployment): 코드 변경이 자동으로 프로덕션 환경에 배포됩니다. 모든 테스트가 통과하면 추가적인 승인 없이 배포가 이루어집니다.
장점
빠른 피드백: 개발자가 코드를 변경할 때마다 자동으로 테스트가 이루어져, 문제를 조기에 발견할 수 있습니다.
일관된 품질: 자동화된 테스트와 빌드를 통해 품질이 일관되게 유지됩니다.
신속한 배포: 새로운 기능이나 수정 사항을 신속하게 사용자에게 제공할 수 있습니다.
효율적인 협업: 팀원 간의 코드 충돌을 줄이고, 통합 과정에서 발생할 수 있는 문제를 조기에 해결합니다.

## 좀비프로세스

좀비 프로세스(zombie process)는 운영 체제에서 종료된 프로세스이지만, 여전히 프로세스 테이블에 남아 있는 상태를 말합니다. 이는 부모 프로세스가 자식 프로세스의 종료 상태를 수집하지 않았기 때문에 발생합니다.

좀비 프로세스의 특징
종료 상태 유지: 좀비 프로세스는 이미 실행을 마친 상태지만, 종료 코드와 같은 정보를 보유하고 있습니다.
부모 프로세스 필요: 자식 프로세스가 종료되면, 부모 프로세스가 wait() 시스템 호출을 통해 종료 상태를 수집해야 합니다. 이를 수행하지 않으면 자식 프로세스는 좀비 상태로 남게 됩니다.
자원 소모: 좀비 프로세스는 메모리와 같은 자원을 차지하지 않지만, 프로세스 테이블 항목을 차지하므로, 시스템에 좀비 프로세스가 너무 많아지면 새로운 프로세스를 생성하는 데 문제가 발생할 수 있습니다.
좀비 프로세스 해결 방법
부모 프로세스 수정: 부모 프로세스에서 자식 프로세스의 종료 상태를 적절히 수집하도록 코드를 수정합니다. 일반적으로 wait() 또는 waitpid() 함수를 사용합니다.
부모 프로세스가 종료: 부모 프로세스가 종료되면, 좀비 프로세스는 init 프로세스(또는 시스템의 첫 번째 프로세스)로 대체되어, 해당 프로세스가 종료 상태를 수집합니다.
좀비 프로세스는 일반적으로 시스템의 안정성에 영향을 미치지 않지만, 너무 많이 쌓이면 리소스 문제를 일으킬 수 있으므로 관리가 필요합니다.

## TCP, UDP

TCP(Transmission Control Protocol)와 UDP(User Datagram Protocol)는 인터넷 프로토콜 스위트의 두 가지 주요 전송 프로토콜로, 데이터 전송 방식이 다릅니다.

TCP (Transmission Control Protocol)
연결 지향: 데이터 전송 전에 송신자와 수신자 간의 연결을 설정합니다.
신뢰성: 데이터가 손실되지 않도록 확인하는 기능이 있습니다. 전송된 데이터 패킷에 대한 응답을 받고, 손실된 패킷을 재전송합니다.
순서 보장: 데이터 패킷이 전송된 순서대로 수신되도록 보장합니다.
흐름 제어: 수신자가 데이터를 처리할 수 있는 속도로 송신자가 전송하도록 조절합니다.
사용 예: 웹 페이지 로딩(HTTP/HTTPS), 파일 전송(FTP), 이메일(SMTP) 등 신뢰성이 중요한 경우에 사용됩니다.
UDP (User Datagram Protocol)
비연결 지향: 데이터 전송 전에 연결을 설정하지 않습니다. 패킷을 독립적으로 전송합니다.
신뢰성 없음: 데이터 전송의 성공 여부를 확인하지 않으며, 손실된 패킷을 재전송하지 않습니다.
순서 보장 없음: 데이터 패킷이 수신된 순서와 관계없이 도착할 수 있습니다.
흐름 제어 없음: 송신 속도를 조절하지 않으며, 수신자가 처리할 수 있는 속도를 고려하지 않습니다.
사용 예: 실시간 게임, 비디오 스트리밍, 음성 통화(VoIP) 등 신뢰성보다 속도가 중요한 경우에 사용됩니다.
요약
TCP: 신뢰성과 순서 보장이 필요한 데이터 전송에 적합합니다.
UDP: 빠른 전송 속도가 필요한 경우에 적합합니다.
추가적으로 궁금한 점이 있으면 언제든지 물어보세요!

## npm

package.json은 Node.js 프로젝트의 메타데이터를 포함하는 파일로, 프로젝트의 설정, 의존성, 스크립트 등을 관리합니다. 주요 내용은 다음과 같습니다:

주요 구성 요소
name: 프로젝트의 이름. npm에서 패키지를 식별하는 데 사용됩니다.
version: 프로젝트의 버전. 주로 semver(Semantic Versioning) 형식으로 작성됩니다.
description: 프로젝트에 대한 간단한 설명.
main: 애플리케이션의 진입점 파일. 일반적으로 index.js와 같은 파일을 지정합니다.
scripts: 프로젝트에서 자주 사용하는 명령어를 정의할 수 있는 섹션입니다. 예를 들어, npm start를 사용해 서버를 시작하는 스크립트를 설정할 수 있습니다.
dependencies: 애플리케이션이 실행되기 위해 필요한 패키지를 나열합니다.
devDependencies: 개발 과정에서만 필요한 패키지를 나열합니다. 예를 들어 테스트 도구나 빌드 도구 등이 포함됩니다.
keywords: 프로젝트와 관련된 키워드 목록. npm 레지스트리에서 검색할 때 유용합니다.
author: 프로젝트 작성자의 이름.
license: 프로젝트의 라이센스 정보. 예를 들어 MIT, Apache-2.0 등.

## npm install

1. package.json 확인
   명령어를 실행하면, 현재 디렉토리에서 package.json 파일을 찾아서 의존성 목록을 확인합니다. 이 파일에는 설치해야 할 패키지와 그 버전 정보가 포함되어 있습니다.
2. 의존성 다운로드
   dependencies 및 devDependencies에 나열된 패키지를 npm 또는 Yarn 레지스트리에서 다운로드합니다. 각 패키지의 버전은 package.json에 지정된 대로 설치됩니다.
   패키지가 다른 패키지에 의존하는 경우, 해당 의존성도 자동으로 다운로드됩니다.
3. package-lock.json 또는 yarn.lock 생성/업데이트
   npm: npm install을 실행하면 package-lock.json 파일이 생성되거나 업데이트됩니다. 이 파일은 설치된 패키지의 정확한 버전 및 의존성 트리를 기록하여, 이후 동일한 패키지 설치 시 일관성을 보장합니다.
   Yarn: yarn install을 실행하면 yarn.lock 파일이 생성되거나 업데이트됩니다. 이 파일 역시 의존성 버전과 트리를 기록하여, 일관된 설치를 보장합니다.
4. 노드 모듈 설치
   의존성 패키지는 node_modules 디렉토리에 설치됩니다. 이 디렉토리는 프로젝트의 루트 디렉토리에 생성되며, 다운로드된 모든 패키지가 이곳에 위치하게 됩니다.
5. 스크립트 실행 (선택 사항)
   package.json의 scripts 섹션에 정의된 postinstall 스크립트가 있는 경우, 설치가 완료된 후 자동으로 해당 스크립트가 실행됩니다. 이는 패키지 설치 후 추가적인 설정이나 구성을 위해 사용될 수 있습니다.
6. 캐시 사용
   npm과 Yarn 모두 의존성을 다운로드할 때, 로컬 캐시를 활용하여 이미 다운로드된 패키지를 재사용합니다. 이는 설치 시간을 단축시킵니다.

## db 관계형 비관계형 차이

관계형 데이터베이스(RDBMS)와 비관계형 데이터베이스(NoSQL)는 데이터 저장 및 관리 방식에서 큰 차이를 보이는 두 가지 유형의 데이터베이스입니다.

관계형 데이터베이스 (RDBMS)
구조화된 데이터: 데이터가 테이블 형식(행과 열)으로 구성되며, 각 테이블은 명확한 스키마(데이터 구조)를 갖습니다.
SQL 사용: 데이터 쿼리와 조작을 위해 SQL(Structured Query Language)을 사용합니다.
관계: 테이블 간에 관계를 설정할 수 있으며, 이를 통해 데이터의 무결성을 유지합니다. 예를 들어, 외래 키(foreign key)를 사용하여 테이블 간의 관계를 정의합니다.
ACID 특성: 원자성(Atomicity), 일관성(Consistency), 고립성(Isolation), 내구성(Durability)을 지원하여 데이터의 안정성과 무결성을 보장합니다.
예시: MySQL, PostgreSQL, Oracle, Microsoft SQL Server 등이 있습니다.
비관계형 데이터베이스 (NoSQL)
비구조화된 데이터: 데이터가 테이블 형식이 아닌 다양한 형식(문서, 키-값, 그래프 등)으로 저장될 수 있습니다. 스키마가 유연하여 데이터 구조가 변화해도 쉽게 대응할 수 있습니다.
쿼리 언어: SQL 대신 각 데이터베이스에 맞는 API 또는 쿼리 언어를 사용합니다.
수평 확장성: 데이터베이스를 여러 서버에 분산하여 저장할 수 있어 대량의 데이터를 쉽게 처리할 수 있습니다.
CAP 이론: 일관성(Consistency), 가용성(Availability), 파티션 허용성(Partition Tolerance) 중 두 가지를 동시에 만족하기 어려운 상황을 설명합니다. 대부분의 NoSQL 데이터베이스는 가용성과 파티션 허용성을 우선시합니다.
예시: MongoDB(문서 기반), Redis(키-값 저장소), Cassandra(열 기반), Neo4j(그래프 데이터베이스) 등이 있습니다.
요약
관계형 데이터베이스: 구조화된 데이터, 엄격한 스키마, SQL 사용, ACID 특성을 가진 데이터베이스로, 금융, 기업 데이터 등 신뢰성과 무결성이 중요한 경우에 적합합니다.
비관계형 데이터베이스: 비구조화된 데이터, 유연한 스키마, 수평 확장성을 갖춘 데이터베이스로, 소셜 미디어, 실시간 분석, 빅데이터 등 다양한 데이터 유형을 처리하는 데 적합합니다.

## HTTP와 HTTPS의 차이

HTTP와 HTTPS의 차이점은 보안입니다. HTTP는 데이터를 암호화하지 않고 전송하지만, HTTPS는 SSL/TLS 프로토콜을 사용하여 데이터를 암호화해 보안을 강화합니다.

### SSL/TLS

SSL("Secure Sockets Layer)과 TLS("Transport Layer Security)는 인터넷에서 데이터 전송 시 보안을 제공하는 프로토콜입니다. SSL은 초기 버전이고 TLS는 그 후속 버전으로 더 안전합니다. 이 프로토콜은 데이터 암호화, 인증 및 무결성을 보장하여 안전한 통신을 가능하게 합니다.

## 브라우저 엔진은?

브라우저 엔진은 웹 브라우저에서 웹 페이지를 렌더링하고 실행하는 핵심 컴포넌트입니다. 주로 두 가지 기능을 수행합니다.

1. 렌더링 엔진: HTML, CSS, JavaScript를 해석하고 화면에 표시합니다. 예를 들어, Chrome은 Blink, Firefox는 Gecko를 사용합니다.

2. JavaScript 엔진: JavaScript 코드를 실행합니다. Chrome은 V8 엔진을, Firefox는 SpiderMonkey를 사용합니다.

### Blink

브라우저: 주로 Google Chrome 및 Chromium 기반 브라우저에서 사용.

기능: HTML, CSS를 렌더링하고 JavaScript를 실행하는데 최적화되어 있습니다. 빠른 성능과 최신 웹 표준 지원을 강조합니다.

특징: 오픈 소스이며, 다양한 최적화 기술을 통해 페이지 로딩 속도를 개선합니다. 다양한 기능이 실험적으로 추가되기도 합니다.

### Gecko

브라우저: Mozilla Firefox에서 사용

기능: Blink와 비슷하게 HTML, CSS 및 JavaScript를 처리합니다. 웹 표준을 따르며, 안전성과 보안에 중점을 두고 설계되었습니다.

특징: Mozilla의 오픈 소스 프로젝트로, 접근성 및 개인 정보 보호 기능에 강점을 보입니다. 다양한 플러그인 및 확장 프로그램을 지원합니다.

### V8

브라우저: Google Chrome에서 사용되며, Node.js에서도 사용됩니다.
기능: JavaScript 코드 실행을 위한 엔진으로, 고속 성능을 자랑합니다. Just-In-Time(JIT) 컴파일을 통해 코드를 실행합니다.
특징: 크로스 플랫폼에서 작동하며, 최신 ECMAScript(자바스크립트 표준) 기능을 지속적으로 지원합니다.

### SpiderMonkey

브라우저: Mozilla Firefox에서 사용
기능: JavaScript 실행을 위한 엔진으로, JIT 컴파일을 지원합니다.
특징: 다양한 최신 JavaScript 기능을 지원하며, WebAssembly와 같은 새로운 웹 기술에도 대응합니다.

### JIT(엔진X)

주로 프로그래밍 언어의 실행 속도를 개선하기 위해 사용되는 컴파일 기법입니다. JIT 컴파일러는 프로그램 실행 중에 코드의 일부를 런타임에 컴파일하여 성능을 높입니다.

JIT의 작동 방식:

1. 소스 코드: 원래의 소스 코드가 인터프리터를 통해 실행됩니다.
2. 컴파일: 자주 실행되는 코드(핫스팟)을 감지하면 JIT 컴파일러가 해당 코드를 네이티브 머신 코드로 컴파일합니다.
3. 캐시: 컴파일된 코드는 캐시에 저장되어 이후 실행 시 빠르게 사용할 수 있습니다.

장점:
성능 향상: 반복적으로 실행되는 코드를 최적화하여 속도를 높입니다.
동적 최적화: 런타임에 코드 실행 패턴을 분석하여 최적화할 수 있습니다.

단점:
메모리 사용: JIT 컴파일러는 추가적인 메모리를 사용할 수 있습니다.
초기 지연: 프로그램 시작 시 코드 컴파일이 필요하기 떄문에 초기 실행 속도가 느릴 수 있습니다.

JIT는 Java의 HotSpot, JavaScript의 V8 엔진 등에서 널리 사용됩니다.

## 컴파일

Compile은 고급 프로그래밍 언어로 작성된 소스코드를 기계어 또는 중간 코드로 변환하는 과정입니다. 이 과정은 컴파일러라는 프로그램에 의해 수행되며, 컴파일된 코드는 실행 가능한 파일이나 바이너리 형태로 저장됩니다. 컴파일은 주로 성능 향상을 위해 이루어지며, 코드의 문법 오류를 사전에 검출할 수 있는 장점도 있습니다.

## Docker

Docker는 컨테이너 기술로, 애플리케이션을 가상화하여 독립적인 환경에서 실행할 수 있게 해줍니다. 이를 통해 개발, 배포, 확장이 용이해지고, 환경 차이로 인한 문제를 줄일 수 있습니다

### 컨테이너

컨테이너는 애플리케이션과 그 실행에 필요한 모든 의존성을 패키징하여 격리된 환경에서 실행할 수 있게 해주는 lightweight한 가상화 기술입니다.

주요 특징:

1. 격리성: 각 컨테이너는 독립적인 환경에서 실행되므로, 다른 컨테이너와의 충돌이 없습니다.
2. 경량: VM(가상 머신)에 비해 리소스를 적게 사용하며, 빠른 시작과 종료가 가능합니다.
3. 이식성: 동일한 컨테이너 이미지를 다양한 환경에서 일관되게 실행할 수 있습니다.
4. 버전 관리: 컨테이너 이미지는 버전 관리가 가능하며, 특정 상태로 쉽게 롤백할 수 있습니다.

컨테이너는 주로 Docker와 같은 도구를 통해 관리합니다.

### 컨테이너의 가상화

컨테이너 가상화는 가상화의 한 형태로, 애플리케이션과 그에 필요한 라이브러리, 종속성 등을 패키징하여 격리된 환경에서 실행할 수 있도록 하는 기술이다.

## Typescript 쓰는 이유

Typescript (TS)는 JavaScript의 상위 집합으로 주로 다음과 같은 이유로 사용됩니다.

1. 정적 타입: 타입을 명시함으로써 코드 작성 시 오류를 미리 발견할 수 있습니다.
2. 개발 도구 지원: IntelliSense, 자동 완성 등 다양한 개발 도구의 지원을 통해 생산성을 높입니다.
3. 대규모 프로젝트: 코드 유지보수와 협업이 용이해지며, 코드 구조를 더 명확하게 할 수 있습니다.
4. 최신 JavaScript 기능: 최신 ECMAScript 기능을 사용할 수 있으며, 하위 호환성을 유지합니다.

### ECMA

ECMA는 "European Computer Manufactures Association"의 약자로 컴퓨터 및 정보 기술 관련 표준을 개발하는 비영리 조직입니다.

표준화: 다양한 프로그래밍 언어와 기술의 표준을 정의합니다. 가장 잘 알려진 표준 중 하나는 ECMAScript로, JavaScript의 기반이 됩니다.
기술 규격: 언어의 문법, 동작 방식 및 API에 대한 규격을 제공합니다.

ECMA는 프로그래밍 언어의 일관성을 보장하고, 상호 운용성을 높이는데 기여합니다.

## 클라이언트 서버 구조

클라이언트 서버 모델은 네트워크에서 클라이언트와 서버 간의 상호작용을 정의하는 구조입니다.

주요 요소:

1. 클라이언트: 사용자 요청을 보내고, 서버로부터 데이터를 받는 프로그램이나 장치입니다. 예를 들어, 웹 브라우저가 클라이언트 역할을 합니다.
2. 서버: 클라이언트의 요청을 처리하고, 필요한 데이터를 제공하는 시스템입니다. 웹 서버가 이 역할을 합니다.

작동 방식:
클라이언트가 서버에 요청을 보내면, 서버는 해당 요청을 처리하고 응답을 클라이언트로 반환합니다. 이 구조는 분산 시스템을 효율적으로 구성하는데 유용합니다.

### 클라이언트 서버 모델의 특징

1. 분리된 역할:
   클라이언트는 사용자 인터페이스와 사용자 경험을 관리하며, 서버는 데이터 저장 및 처리, 비즈니스 로직을 담당합니다.
2. 네트워크 통신:
   클라이언트와 서버는 네트워크를 통해 서로 통신합니다. HTTP, HTTPS, WebSocket 등의 프로토콜을 사용하여 데이터를 주고받습니다.
3. 확장성:
   서버는 여러 클라이언트를 동시에 처리할 수 있도록 설계되어 있어, 시스템의 확장성이 뛰어납니다. 필요에 따라 서버를 추가하여 부하를 분산할 수 있습니다.
4. 보안:
   클라이언트-서버 구조에서는 보안 조치를 쉽게 적용할 수 있습니다. 예를 들어, 서버에서 인증 및 권한 부여를 처리할 수 있습니다.
5. 데이터 저장:
   서버는 클라이언트의 데이터를 중앙에서 관리하여, 데이터 일관성과 무결성을 유지합니다.

## REST

REST(Representational State Transfer)는 웹 서비스 설계 원칙으로, 다음과 같은 특징이 있습니다.

1. 무상태성: 각 요청은 독립적이며, 서버는 클라이언트의 상태르르 저장하지 않습니다. 클라이언트는 모든 필요한 정보를 요청에 포함해야 합니다.

2. 자원 지향: 모든 자원은 URI(Uniform Resourece Identifier)로 식별되며, 클라이언트는 이 URI를 통해 자원에 접근합니다.
3. 표현: 자원은 다양한 형식(예:JSON, XML)으로 표현될 수 있으며, 클라이언트는 원하는 형식을 요청할 수 있습니다.
4. HTTP 메서드: CRUD(Create, Read, Update, Delete) 작업은 HTTP 메서드(GET, POST, PUT, DELETE 등)를 사용하여 수행됩니다.
5. 계층화 시스템: 클라이언트는 서버와 직접 통신하는 것이 아니라, 중간 서버(프록시, 게이트웨이 등)를 통해 통신할 수 있습니다.

## 세션, 쿠키, 캐시

1. 세션(Session)
   정의: 서버 측에서 사용자의 상태를 관리하기 위한 방법입니다. 사용자가 웹사이트에 접속하는 동안의 상태 정보를 저장합니다.
   저장 위치: 서버에 저장되며, 사용자의 브라우저에는 세션 ID가 쿠키 형태로 저장됩니다.
   사용 목적: 로그인 상태 유지, 장바구니 정보 저장 등, 세션은 일반적으로 사용자가 브라우저를 닫거나 세션 타임아웃이 발생하면 만료됩니다.

2. 쿠키(Cookie)

정의: 클라이언트 측에서 사용자의 정보를 저장하는 작은 데이터 파일입니다.
저장 위치: 사용자의 브라우저에 저장됩니다.
사용 목적: 사용자 인증, 개인화된 설정, 방문 기록 등. 쿠키는 만료 기간을 설정할 수 있어 영구적으로 저장될 수 있습니다.

3. 캐시(Cache)
   정의: 자주 요청되는 데이터를 임시로 저장하여 다음 요청 시 빠르게 제공하는 메커니즘입니다.
   저장 위치: 클라이언트(브라우저) 또는 서버에 저장될 수 있습니다.
   사용 목적: 웹 페이지 로딩 속도 향상, 서버 부하 감소 등, 캐시는 만료 기간이나 정책에 따라 갱신됩니다.

## 웹 보안

웹 보안을 위한 대책은 여러 가지가 있으며, 주요 방법은 다음과 같습니다.

1. HTTPS 사용: 데이터 전송 시 SSL/TLS를 통해 암호화하여 보안을 강화합니다.
2. 인증 및 권한 부여: 강력한 비밀번호 정책과 다단계 인증(MFA)을 통해 사용자 인증을 강화합니다.
3. 입력 검증: 사용자 입력을 검증하여 SQL 인젝션, 크로스 사이트 스크립팅(XSS) 등의 공격을 방지합니다.
4. 정기적인 업데이트: 소프트웨어와 라이브러리를 최신 상태로 유지하여 알려진 취약점을 차단합니다.
5. 백업 및 복구 계획: 정기적인 데이터 백업과 복구 계획을 수립하여 데이터 손실에 대비합니다.
6. 방화벽 및 IDS/IPS: 네트워크를 보호하기 위해 방화벽과 침입 탐지/방지 시스템을 설정합니다.

### MFA

MFA(Multi-Factor Authentication)
정의: 사용자가 로그인할 때 두 개 이상의 인증 요소를 요구하는 방식입니다.
요소: 일반적으로 세 가지 유형이 있습니다.

1.  지식 기반: 사용자가 알고 있는 정보(비밀번호)
2.  소지 기반: 사용자가 가지고 있는 물리적 장치(휴대폰의 인증 앱).
3.  고유 기반: 사용자의 생체 정보(지문, 얼굴 인식).
    목적: 계정 탈취를 방지하고 보안을 강화합니다.

### IDS/IPS (Intrusion Detection System / Intrusion Prevention System)

정의:
IDS: 네트워크 또는 시스템에서 비정상적인 활동이나 침입 시도를 감지하는 시스템입니다.
IPS: IDS의 기능에 추가로, 감지된 공격을 차단하는 기능을 갖춘 시스템입니다.

기능:
IDS: 로그 모니터링, 알림 전송 등으로 공격을 경고합니다.
IPS: 실시간으로 공격을 차단하고, 네트워크 트래픽을 분석하여 위협을 방지합니다.

목적 : 시스템 및 네트워크를 보호하고, 공격에 대한 실시간 대응을 제공합니다.

## 성능 최적화 방법

1. 코드 최적화: 불필요한 코드 제거, 알고리즘 개선 및 효율적인 데이터 구조 사용.
2. 이미지 최적화: 이미지 크기 축소 및 적절한 포맷을 사용하여 로딩 속도 개선.
3. 캐싱: 정적 자원(HTML, CSS, JavaScript 등)을 캐시하여 반복 요청 시 속도 향상.
4. 비동기 로딩: JavaScript와 CSS 파일을 비동기로 로드하여 페이지 렌더링 속도 개선
5. CDN 사용: 콘텐츠 전송 네트워크(CDN)를 통해 사용자에게 가까운 서버에서 콘텐츠 제공
6. 데이터베이스 최적화: 쿼리 최적화, 인덱스 사용 및 데이터 정규화로 데이터베이스 성능 향상
7. 서버 성능 모니터링: 서버 리소스를 모니터링하고, 필요에 따라 스케일 업 또는 스케일 아웃

### CDN(Content Delivery Network)

정의: 전 세계에 분산된 서버 네트워크로, 사용자에게 콘텐츠를 더 빠르고 효율적으로 제공하는 시스템입니다.

작동 원리: 사용자의 지리적 위치에 가장 가까운 서버에서 웹 페이지, 이미지, 비디오 등의 정적 콘텐츠를 제공하여 로딩 시간을 단축합니다.

장점:
속도 향상: 데이터 전송 거리가 줄어들어 빠른 로딩 속도 제공
트래픽 분산: 서버에 가해지는 부하를 줄여 안전성 증가
보안: DDoS 공격 방어 및 SSL 지원 기능 제공

### 스케일 업(Scale Up)

정의: 기존 서버의 성능을 높이는 방식으로, 더 강력한 하드웨어(CPU, 메모리 등)로 업그레이드 하는 것을 의미합니다.
장점:
간단한 관리: 단일 서버에서 모든 작업을 처리하므로 관리가 용이합니다.
즉각적인 성능 향상: 하드웨어 업그레이드로 성능이 즉시 개선됩니다.
단점:
비용 문제: 고성능 하드웨어는 비쌀 수 있습니다.
한계: 특정 한계에 도달하면 더 이상 확장이 불가능합니다.

### 스케일 아웃(Scale Out)

정의: 여러 대의 서버를 추가하여 시스템을 확장하는 방식입니다.
장점:
유연성: 필요에 따라 서버를 추가하여 용량을 쉽게 확장할 수 있습니다.
비용 효율성: 일반적으로 저렴한 하드웨어를 사용하여 확장이 가능합니다.

단점:
복잡성: 여러 서버를 관리해야 하므로 시스템 관리가 복잡해질 수 있습니다.
데이터 일관성: 데이터 분산으로 인해 일관성을 유지하기 어려울 수 있습니다.

1. 관계형 데이터베이스 (RDBMS)
   정의: 데이터가 테이블 형식으로 저장되고, 테이블 간의 관계를 통해 데이터를 관리합니다.

예시: MySQL, PostgreSQL, Oracle, Microsoft SQL Server
특징: SQL(Structured Query Language)을 사용하여 데이터 쿼리 및 조작을 수행합니다. 데이터 무결성과 트랙잭션 처리를 지원합니다.

2. 비관계형 데이터베이스(NoSQL)
   정의: 관계형 모델이 아닌 방식으로 데이터를 저장하는 데이터베이스입니다. 다양한 데이터 모델을 지원합니다.
   예시: MongoDB, Cassandra, Redis, Couchbase
   특징: 스키마가 없거나 유연하게 데이터 구조가 다양합니다. 대규모 데이터와 높은 성능을 처리하는 데 유리합니다.
3. 객체지향 데이터베이스 (OODBMS)
   정의: 객체 지향 프로그래밍 언어와 통합하여 데이터를 객체로 저장하는 데이터베이스입니다.
   예시: db4o, ObjectDB
   특징: 객체와 클래스 개념을 사용하여 복잡한 데이터 모델을 표현할 수 있습니다.

4. 그래프 데이터베이스
   정의: 노드, 엣지, 속성으로 구성된 그래프 구조로 데이터를 저장하는 데이터베이스입니다.
   예시: Neo4j, Amazon Neptune
   특징: 복잡한 관계 데이터를 효과적으로 관리하며, 소셜 네트워크, 추천 시스템 등에 적합합니다.
5. 문서 지향 데이터베이스
   정의: JSON, XML 등의 문서 형식으로 데이터를 저장하는 데이터베이스입니다.
   예시: MongoDB, CouchDB
   특징: 유연한 데이터 구조를 제공하며, 복잡한 쿼리를 지원합니다.

## 백엔드 프레임워크의 종류

백엔드 프레임워크는 서버 측 애플리케이션을 개발하는 데 도움을 주는 소프트웨어 프레임워크입니다. 여러 종류가 있으며, 주요 백엔드 프레임워크는 다음과 같습니다.

1. Node.js (Express)
   정의: JavaScript 런타임 환경인 Node.js 위에 구축된 웹 애플리케이션 프레임워크입니다.
   특징: 비동기 이벤트 기반 아키텍처를 사용하여 높은 성능을 제공합니다. RESTful API 개발에 적합하며, 미들웨어를 통해 요청과 응답을 처리합니다.

2. Django
   정의: Python으로 작성된 고급 웹 프레임워크입니다.
   특징: 강력한 ORM(Object-Relational Mapping), 보안 기능, 관리 패널과 같은 여러 내장 기능을 제공합니다. 빠른 개발과 유지보수를 지원합니다.

3. Ruby on Rails
   정의: Ruby 프로그래밍 언어로 작성된 프레임워크입니다.
   특징: "Convention over Configuration" 및 "Don't Repaeat Yourself" 원칙을 따르며, 생산성을 높이는 다양한 도구와 라이브러리를 제공합니다.

4. ASP.NET
   정의: Microsoft에서 개발한 웹 프레임워크로 .NET 플랫폼을 기반으로 합니다.
   특징: C#을 사용하여 웹 애플리케이션을 개발할 수 있으며, 강력한 보안 기능과 성능을 제공합니다. MVC(Model-View-Controller) 아키텍처를 지원합니다.

5. Spring
   정의: Java 기반의 애플리케이션 프레임워크로, 특히 엔터프라이즈급 애플리케이션 개발에 적합합니다.
   특징: 의존성 주입, AOP(Aspect-Oriented Programming) 등 다양한 기능을 제공하며, RESTful API 및 마이크로서비스 아키텍처에 널리 사용됩니다.

6. Flask

정의: Python으로 작성된 경량 웹 프레임워크입니다.
특징: 간단하고 유연한 구조로, 필요한 기능만 추가하여 사용할 수 있습니다. RESTful API 및 소규모 애플리케이션에 적합합니다.

### 프레임워크(JS 기반)

1. Express.js
   정의: Node.js의 가장 널리 사용되는 웹 애플리케이션 프레임워크로,최소한의 기능으로 시작할 수 있는 유연한 구조를 제공합니다.
   특징: 미들웨어를 사용하여 요청과 응답을 처리하며, RESTful API 개발에 적합합니다. 간단하고 직관적인 라우팅을 지원합니다.

2. Koa
   정의: Express의 창시자들이 만든 새로운 웹 프레임워크로, 미들웨어를 더 깔끔하게 사용할 수 있도록 설계되었습니다.

특징: async/await를 지원하여 비동기 코드를 쉽게 작성할 수 있으며, 경량 구조로 성능이 뛰어납니다.

3. NestJS
   정의: TypeScript 기반의 서버 사이드 애플리케이션 프레임워크로, Angular의 디자인 원칙을 따릅니다.
   특징: 모듈화된 아키텍쳐와 의존성 주입을 지원하며, 대규모 애플리케이션 개발에 적합합니다.

4. Hapi.js
   정의: 구성 가능성이 높은 서버 프레임워크로 강력한 플러그인 시스템을 제공합니다.
   특징: 안정성과 보안 기능이 뛰어나며, RESTful API 및 웹 애플리케이션 개발에 적합합니다.

5. Salls.js

정의: Node.js를 위한 MVC 프레임워크로, Ruby on Rails의 영향을 받았습니다.
특징: 실시간 웹 애플리케이션과 RESTful API를 쉽게 구축할 수 있으며, 데이터베이스 ORM인 Waterline을 사용합니다.

6. Fastify

정의: 매우 빠르고 저렴한(성능과 자원의 소모가 적다) 서버 프레임워크로, 고성능 애플리케이션을 개발하는 데 초점을 맞추고 있습니다.
특징: 플러그인 기반 아키텍처를 사용하여 확장성이 뛰어나며, JSON 기반의 요청과 응답 처리에 최적화되어 있습니다.

### 의존성 주입 (Dependency Injection)(DI)

정의: 객체 간의 의존성을 관리하는 디자인 패턴으로 객체가 자신의 의존성을 직접 생성하는 것이 아니라 외부에서 주입받는 방식입니다.

특징:
유연성: 코드의 재사용성을 높이고, 모듈 간의 결합도를 낮춥니다.
테스트 용이성: 의존성을 쉽게 교체할 수 있어 단위 테스트가 용이합니다.
설정 관리: 객체 생성과 의존성 관리를 프레임워크가 자동으로 처리하여 코드가 더 깔끔해집니다.

#### 의존성 주입이 유용한 이유(자필)

라이브러리나 프레임워크가 필요한 코드 쪽에서 코드 구조의 변경없이 라이브러리나 프레임워크에서 미리 짜놓은 코드를 받아 쓸 수 있다. 즉, 기존의 코드의 변경이 적다는 점에서 의존성 주입 패턴은 매우 유용하다.

### Angular의 디자인 원칙

Angular는 웹 애플리케이션 개발을 위한 프레임워크로, 몇 가지 주요 디자인 원칙을 따릅니다.

모듈화: 애플리케이션을 모듈로 나누어 관리할 수 있어 코드의 가독성과 유지보수가 용이합니다.
컴포넌트 기반: UI를 독립적인 컴포넌트로 나누어 구성하여 재사용성과 관리성을 높입니다.
양방향 데이터 바인딩: 모델과 뷰 간의 데이터를 자동으로 동기화하여 개발자의 부담을 줄입니다.
의존성 주입: 서비스나 의존성을 필요로 하는 컴포넌트에 쉽게 주입하여 결합도를 낮추고 테스트 가능성을 높입니다.

### Waterline

정의: Sails.js의 기본 ORM(Object-Relational Mapping)으로 다양한 데이터베이스와 상호작용할 수 있는 추상화된 레이어를 제공합니다.
특징:
다양한 데이터베이스 지원: SQL 기반의 관계형 데이터 베이스와 NoSQL 데이터베이스 모두 지원합니다.
간단한 쿼리 언어: 데이터베이스에 대한 복잡한 쿼리를 쉽게 작성할 수 있도록 돕습니다.
모델 기반: 데이터 모델을 정의하고, 데이터베이스와의 상호작용 단순화합니다.

### 런타임

1. 런타임 환경
   정의: 프로그램이 실행되는 환경으로, 운영 체제, 메모리, 라이브러리 및 런타임 시스템을 포함합니다.
   예시: Java Virtual Machine (JVM)과 같은 특정 플랫폼에서 실행되는 애플리케이션이 있습니다.

## 프레임워크와 라이브러리 모듈

프레임워크, 라이브러리, 모듈은 소프트웨어 개발에서 중요한 개념으로 각각의 역할과 특징은 다음과 같습니다.

1. 프레임워크(Framework)
   정의: 특정한 아키텍처와 규칙을 제공하여 애플리케이션을 구조화하는 기본 뼈대를 제공합니다.
   특징: 개발자가 프레임워크에 맞춰 코드를 작성해야 하며, 제어의 흐름이 프레임워크에 의해 관리됩니다.

2. 라이브러리 (Library)
   정의: 특정 기능이나 작업을 수행하기 위해 미리 작성된 코드 집합으로, 개발자가 필요할 때 호출하여 사용할 수 있습니다.
   특징: 개발자가 호출하는 방식으로, 제어의 흐름은 개발자에게 있습니다. 예: Lodash, jQuery

3. 모듈(Module)
   정의: 특정 기능을 캡슐화하여 재사용 가능하도록 만든 코드 단위입니다.
   특징: 서로 다른 모듈 간의 의존성을 관리할 수 있으며, 다른 모듈에서 쉽게 가져다 쓸 수 있습니다. ES6 모듈, CommonJS 모듈이 있습니다.

## 버전 관리 시스템

1. 변경 이력 관리
   기능: 파일의 모든 변경 사항을 추적하여 이전 번전으로 쉽게 되돌릴 수 있습니다.
   장점: 코드의 변화를 기록하므로, 실수로 인한 변경을 복구할 수 있습니다.

2. 협업 지원
   기능: 여러 개발자가 동시에 작업할 수 있도록 지원합니다.
   장점: 분산 작업 환경에서도 충돌을 최소화하고, 각자의 변경 사항을 통합할 수 있습니다.

3. 브랜칭과 머징
   기능: 개발자가 독립적인 작업을 할 수 있도록 브랜치를 만들고, 작업이 완료되면 다시 통합할 수 있습니다.
   장점: 새로운 기능이나 수정 작업을 실험할 수 있어 안정성을 유지하면서 개발할 수 있습니다.

4. 분산 버전 관리 시스템
   정의: 각 개발자가 자신의 로컬 환경에서 전체 코드베이스의 복사본을 가질 수 있는 시스템입니다.
   예시: Git, Mercurial.
   장점: 중앙 서버의 의존성을 줄이고, 오프라인에서도 작업할 수 있습니다.

5. 중앙 집중식 버전 관리 시스템
   정의: 모든 변경 사항이 중앙 서버에 저장되는 방식입니다.
   예시: Subversion(SVN), CVS
   장점: 관리가 간편하지만, 서버의 의존성이 큽니다.

## CORS(Cross-Origin Resource Sharing)

CORS(교차 출처 리소스 공유, Cross-Origin Resource Sharing)은 웹 애플리케이션에서 리소스가 다른 출처(origin)에서 요청될 때 보안을 관리하는 메커니즘입니다. 다음은 CORS의 주요 특징입니다.

1. 출처(Origin) 개념
   정의: 출처는 프로토콜, 도메인, 포트 번호로 구성됩니다.
   제한: 웹 브라우저는 기본적으로 다른 출처의 리소스에 대한 요청을 제한하여 보안을 강화합니다.

2. CORS 정책
   기능: 서버는 응답 헤더에 특정 CORS 헤더를 포함하여 요청이 허용되는 출처를 명시합니다.
   헤더: 주요 헤더로는 Access-Control-Allow-Origin이 있으며, 이를 통해 어떤 출처가 요청할 수 있는지를 정의합니다.

3. 요청 유형
   단순 요청(Simple Request): GET, POST(특정 조건 하에) 요청 등.
   사전 요청(Preflight Request): CORS 요청이 복잡한 경우, 브라우저가 실제 요청 전에 OPTIONS 메서드를 사용해 서버에 권한을 확인합니다.

4. 보안 및 사용 사례

보안: CORS는 공격으로부터 보호하기 위해 출처를 명시적으로 관리합니다.
사용 사례: API 서버와 클라이언트가 서로 다른 도메인일때, 클라이언트가 API에 접근할 수 있도록 허용할 수 있습니다.

## 이벤트 루프

이벤트 루프(Event Loop)는 JavaScript의 비동기 처리를 관리하는 매커니즘으로, 단일 스레드에서 비동기 작업을 효율적으로 수행하는 데 도움을 줍니다. 주요 특징은 다음과 같습니다.

1. 비동기 작업 처리
   정의: JavaScript는 기본적으로 단일 스레드로 동작하지만, 비동기 작업(예: API 호출, 타이머 등)을 처리할 수 있도록 이벤트 루프가 사용됩니다.

2. 콜 스택(Call Stack)
   작동 방식: 함수 호출이 이루어질 때마다 스택에 추가되고, 실행이 완료되면 스택에서 제거됩니다. 현재 실행 중인 함수가 완료될 때까지 다음 작업은 대기합니다.

3. 태스크 큐 (Task Queue)
   정의:비동기 작업이 완료되면 해당 작업이 큐에 추가됩니다. 이벤트 루프는 콜 스택이 비어있을 때 이 큐에서 작업을 꺼내어 실행합니다.

4. 이벤트 루프 작동 과정
   1. 콜 스택에 현재 실행 중인 작업이 끝나면, 이벤트 루프는 태스크 큐를 확인합니다.
   2. 큐에 대기 중인 작업이 있다면, 이를 콜 스택에 추가하여 실행합니다.
   3. 이 과정이 반복되며, 비동기 작업이 완료되면 이를 통해 다음 작업이 실행됩니다.

## 원시 타입과 참조타입에 대해서

원시 타입(Primitive Type)과 참조 타입(Reference Type)은 데이터의 저장 방식과 특징에서 차이가 있습니다.

1. 원시 타입 (Primitive Type)
   정의: 단일 값으로 표현되며, 불변(immutable)입니다.
   종류: JavaScript에서는 string, number, boolean, null, undefined, symbol, bigint가 원시 타입입니다.
   저장 방식: 값 자체가 스택에 저장됩니다. 원시 타입의 값을 다른 변수에 할당하면, 값이 복사됩니다.

2. 참조 타입 (Reference Type)
   정의: 객체 형태로 여러 값을 포함할 수 있으며, 가변(mutable)입니다.
   종류: Object, Array, Function, Date, 사용자 정의 객체 등입니다.
   저장 방식: 값이 힙에 저장되고, 변수에는 해당 값의 참조(주소)가 저장됩니다. 이로 인해 같은 참조를 가진 두 변수가 동일한 객체를 공유하게 됩니다.

## var, let, const

var, let, const는 JavaScript에서 변수를 선언하는데 사용되는 키워드로 각각의 특징은 다음과 같습니다.

1. var

스코프: 함수 스코프(function scope)를 가집니다. 함수 내에서 선언된 변수는 해당 함수 내에서만 유효하며, 함수 외부에서는 접근할 수 없습니다.

호이스팅: 변수 선언이 해당 스코프의 최상단으로 끌어올려지는 호이스팅(hoisting) 현상이 있습니다. 따라서 변수를 선언하기 전에 사용할 수 있지만, 값은 undefined로 초기화됩니다.

재선언 가능: 같은 이름으로 여러번 선언할 수 있습니다.

2. let
   스코프: 블록 스코프(block scope)를 가집니다. {}로 둘러싸인 블록 내에서만 유효합니다.
   호이스팅: 호이스팅이 발생하지만, 초기화되기 전에는 접근할 수 없어 ReferenceError가 발생합니다.
   재선언 불가: 같은 스코프 내에서 같은 이름으로 재선언할 수 없습니다.

3. const
   스코프: let과 동일하게 블록 스코프를 가집니다.
   호이스팅: let과 마찬가지로 초기화되기 전에는 접근할 수 없습니다.
   재선언 불가: 같은 스코프 내에서 같은 이름으로 재선언할 수 없습니다.
   불변성: 변수 자체의 재할당이 불가능합니다. 그러나 객체나 배열의 경우, 내부 속성을 변경하는 것은 가능합니다.

### 일시적 사각지대(Temporal Dead Zone, TDZ)

일시적 사각지대는 JavaScript에서 let이나 const로 선언된 변수가 초기화되기 전까지 접근할 수 없는 상태를 의미합니다. TDZ의 주요 특징은 다음과 같습니다.

1. 정의
   일시적 사각지대: 변수가 선언되기 전에 해당 변수에 접근하려고 하면 발생하는 상태입니다. 이 상태에서는 변수에 접근할 수 없어 ReferenceError가 발생합니다.
2. 스코프
   TDZ는 블록 스코프에서 발생합니다. let이나 const로 선언된 변수는 선언된 블록 내에서만 유효하며, 블록 외부에서는 접근할 수 없습니다.
3. 호이스팅과의 관계
   변수는 호이스팅에 의해 스코프의 최상단을 끌어올려지지만 실제 초기화는 선언된 위치에서 이루어집니다. 이로 인해 TDZ가 발생합니다.

### let과 const(자필 및 chatGPT)

let과 const는 윈도우 객체에 추가되지 않는다. 그 이유는 설계적 선택에 기반했기 때문이다.
블록 스코프 개념이 직접적으로 영향을 미치진 않지만, 네임 스페이스의 오염 방지나, let과 const 변수를 더 안전하게 보관하기 위해 추가된 규칙이다.

## 스코프

스코프(scope)는 변수와 함수가 유효하고 접근 가능한 범위를 의미합니다. 스코프는 변수의 생명주기와 접근 가능성을 정의합니다.

주요 유형의 스코프

1. 전역 스코프: 코드의 최상위 레벨에서 선언된 변수로, 프로그램의 모든 부분에서 접근할 수 있습니다.

2. 블록 스코프: {}로 둘러싸인 코드 블록 내에서만 유효하며, let과 const로 선언된 변수는 이 범위에서만 접근할 수 있습니다.
3. 함수 스코프: 함수 내에서 선언된 변수로, 해당 함수 내에서만 유효합니다. var로 선언된 변수는 함수 스코프를 가집니다.

## ORM

ORM(Object-Relational Mapping)은 객체 지향 프로그래밍 언어와 관계형 데이터베이스 간의 데이터 변환을 자동으로 처리해주는 기술입니다. ORM을 사용하면 데이터베이스의 테이블을 객체로 매핑하고, SQL 쿼리를 직접 작성하지 않고도 데이터베이스와 상호작용할 수 있습니다.

주요 특징

1. 추상화: 데이터베이스 접근을 추상화하여 개발자가 SQL을 직접 작성할 필요 없이 객체 지향 방식으로 데이터베이스를 다룰 수 있게 합니다.

2. 생산성 향상: 데이터베이스와의 상호작용을 쉽게 하여 개발 속도를 높이고, 코드의 가독성을 향상시킵니다.

3. 유지보수 용이: 객체 모델과 데이터베이스 모델을 일관되게 유지할 수 있어 유지보수가 용이합니다.

## 인덱스

인덱스(index)는 데이터베이스에서 데이터 검색을 빠르게 하기 위해 사용되는 데이터 구조입니다. 인덱스는 특정 필드에 대한 값들을 미리 정렬하고 저장하여, 해당 필드로 데이터를 조회할 때 검색속도를 크게 향상시킵니다.

주요 특징

1. 검색 성능 향상: 인덱스를 사용하면 데이터베이스 쿼리의 성능을 높일 수 있으며, 특히 큰 테이블에서 특정 조건으로 데이터를 검색할 때 유용합니다.

2. 다양한 유형: B-tree, 해시 인덱스 등 다양한 형태로 구현되며, 각 유형은 특정 상황에서 장점을 가집니다.

3. 저장 공간 소모: 인덱스를 생성하면 추가적인 저장 공간이 필요하며, 데이터 수정(삽입, 삭제, 업데이트) 시 인덱스도 업데이트해야 하므로 성능에 영향을 미칠 수 이씃ㅂ니다.

## 트랜잭션

트랜잭션은 데이터베이스에서 하나의 논리적 작업 단위를 의미합니다. 트랜잭션은 여러개의 데이터베이스 작업을 포함할 수 있으며, 이 작업들이 모두 성공적으로 완료되거나 모두 실패해야 하는 원자성을 갖습니다.

주요 특징

1. 원자성: 트랜잭션 내의 모든 작업이 성공적으로 완료되거나, 어떤 이유로든 실패할 경우 모든 작업이 취소되어야 합니다. 즉, 부분적인 결과가 남아서는 안 됩니다.

2. 일관성:(Consistency): 트랜잭션이 성공적으로 완료되면 데이터베이스의 상태가 일관성을 유지해야 하빈다. 트랜잭션 전후의 데이터 상태는 정의된 규칙을 따라야 합니다.

3. 격리성(Isolation): 동시에 실행되는 트랜잭션은 서로에게 영향을 미치지 않아야 합니다. 각 트랜잭션은 다른 트랜잭션과 독립적으로 처리됩니다.

4. 지속성(Durability): 트랜잭션이 성공적으로 완료된 경우, 그 결과는 영구적으로 저장되어야 하며 시스템 장애가 발생하더라도 사라지지 않아야 합니다.

## 프로세스와 스레드 차이

프로세스

1. 정의: 프로세스는 실행 중인 프로그램의 인스턴스입니다. 각 프로세스는 독립된 메모리 공간을 가지며, 코드, 데이터, 그리고 시스템 자원을 포함합니다.
2. 자원 할당: 프로세스는 운영체제로부터 필요한 자원을 할당받고, 서로 독립적으로 실행됩니다.
3. 문맥 전환 비용: 프로세스 간의 전환은 메모리 공간이 다르기 때문에 상대적으로 비용입 큽니다.

스레드

1. 정의: 스레드는 프로세스 내에서 실행되는 작은 단위로 동일한 프로세스 내에서 자원을 공유할 수 있습니다. 여러 스레드는 하나의 프로세스 내에서 동시에 실행될 수 있습니다.

2. 자원 공유: 스레드는 프로세스의 메모리 공간을 공유하므로, 데이터 전송이 빠르고 효율적입니다.

3. 문맥 전환 비용: 스레드 간의 전환은 메모리 공간이 동일하므로 상대적으로 비용이 적습니다.

## Node.js가 싱글 스레드지만 병렬작업이 가능한 이유

1. 이벤트 루프:
   Node.js는 이벤트 루프를 통해 비동기적으로 작업을 관리합니다. 이를 통해 스레드가 차단되지 않고 다른 작업을 수행할 수 있습니다.

2. 비동기 I/O
   Node.js는 비동기 I/O를 사용하여 파일 시스템, 네트워크 요청 등 시간 소모가 큰 작업을 처리할 때, 작업이 완료되기를 기다리지 않고 다음 작업을 계속 수행합니다. 작업이 완료되면 콜백 함수가 호출되어 결과를 처리합니다.

3. libuv:
   Node.js의 내부 라이브러리인 libuv는 I/O 작업을 위한 스레드 풀을 사용합니다. CPU 집약적인 작업은 별도의 스레드에서 실행되며, 메인 스레드는 이벤트 루프를 계속해서 실행할 수 있습니다.

4. 클러스터링:

Node.js는 클러스터 모듈을 통해 여러 프로세스를 생성할 수 있습니다. 이를 통해 여러 CPU 코어를 활용하여 병렬 처리를 구현할 수 있습니다.

### 스레드 풀

정의: 스레드 풀은 여러 개의 스레드를 미리 생성해두고 필요할 때마다 재사용하는 기법입니다. Node.js의 libuv 라이브러리에서 I/O 작업을 처리할 때 사용됩니다.

작동방식: 비동기 I/O 작업이 완료되면, 해당 작업의 결과를 처리하기 위해 스레드 풀에서 대기중인 스레드가 호출됩니다. 이를 통해 스레드를 생성하는 오버헤드를 줄이고, I/O 작업의 효율성을 높입니다.

기본 크기: Node.js에서 스레드 풀의 기본 크기는 4이며, 필요에 따라 환경 변수를 통해 조정할 수 있다.

### 클러스터링

정의: 클러스터링은 Node.js 애플리케이션을 여러 프로세스로 나누어 실행하는 기법입니다. 이를 통해 다중 CPU 코어를 활용하여 성능을 극대화할 수 있습니다.

작동 방식: 클러스터 모듈을 사용하여 마스터 프로세스가 여러 워커 프로세스를 생성하고, 각 워커가 요청을 처리합니다. 요청은 마스터 프로세스를 통해 분산되어 처리됩니다.

장점: 클러스터링을 통해 애플리케이션의 확장성과 성능을 높일 수 있으며, 하나의 워커 프로세스가 실패하더라도 다른 프로세스가 계속해서 요청을 처리할 수 있어 안정성을 높입니다.

## 자료구조

1. 배열
   설명: 동일한 타입의 데이터를 연속적으로 저장하는 구조로, 인덱스를 통해 접근할 수 있습니다. (자필: js의 배열은 데이터 타입을 마음대로 정할 수 있다. 사실 객체를 배열이라 우기고 있는 꼴이며, 그때문에 유사 배열이라 멸시받기도 한다)
   특징: 고정된 크기를 가지며, 랜덤 액세스가 가능하지만, 삽입과 삭제가 비효율적입니다.(자필: js의 배열과 다르게 C나 C++, 자바에서는 배열의 크기를 선언할 때 지정해줘야 한다. 그렇지 않으려면 동적 할당을 해줘야한다.)

2. 연결 리스트(Linked List)
   설명: 각 요소가 다음 요소에 대한 포인터를 포함하는 구조입니다. 노드로 구성됩니다.
   특징: 동적으로 크기가 조정 가능하며, 삽입과 삭제가 용이하지만, 랜덤 액세스가 불가능합니다.

3. 스택(Stack)
   설명: LIFO(Last in, First Out) 원칙에 따라 데이터를 저장하는 구조입니다. 마지막에 추가된 데이터가 먼저 제거됩니다.
   특징: 함수 호출 시의 실행 컨텍스트를 저장하는 데 자주 사용됩니다.

4. 큐(Queue)
   설명: FIFO(First In, First Out) 원칙에 따라 데이터를 저장하는 구조입니다. 가장 먼저 추가된 데이터가 먼저 제거됩니다.
   특징: 프로세스 스케줄링이나 데이터 전송에 유용하게 사용됩니다.

5. 해시 테이블 (Hash Table)
   설명: 키-값 쌍을 저장하는 구조로 해시 함수를 사용하여 데이터에 빠르게 접근합니다.
   특징: 평균적으로 O(1)의 시간 복잡도로 데이터에 접근할 수 있으나, 충돌 해결이 필요합니다.

6. 트리(Tree)
   설명: 계층적 구조를 가진 자료구조로, 각 노드가 자식 노드를 가질 수 있습니다. 이진 트리, AVL 트리, 이진 탐색 트리 등이 있습니다.
   특징: 트리를 사용하면 데이터 검색 및 정렬이 효율적입니다.

7. 그래프(Graph)

설명: 노드(정점)와 이들을 연결하는 간선으로 구성된 자료구조입니다. 방향성 및 비방향성 그래프가 있습니다.
특징: 복잡한 관계를 모델링하는 데 유용하며, 최단 경로 알고리즘 등 다양한 알고리즘에 사용됩니다.

## 큐와 스택 차이

큐와 스택은 모두 데이터 구조로 데이터를 저장하고 관리하는 방식이 다릅니다. 주요 차이점은 데이터의 삽입 및 삭제 방식에 있습니다.

스택 (Stack)
정의: LIFO(Last In, First Out) 원칙을 따릅니다. 마지막에 추가된 데이터가 가장 먼저 제거됩니다.

작동 방식:
푸시(push): 데이터를 스택에 추가하는 작업.
팝(pop): 데이터를 스택에서 제거하는 작업

특징:
주로 함수 호출 관리, Undo 기능 구현 등에서 사용됩니다.
최근의 데이터에 빠르게 접근할 수 있습니다.

큐 (Queue)
정의: FIFO(First In, First Out) 원칙을 따릅니다. 가장 먼저 추가된 데이터가 가장 먼저 제거됩니다.

작동 방식:
인큐(enqueue): 데이터를 큐에 추가하는 작업
디큐(dequeue): 데이터를 큐에서 제거하는 작업

특징:
주로 프로세스 스케줄링, 데이터 전송 및 버퍼 관리 등에서 사용됩니다.
선입선출 구조로 순서가 중요한 상황에서 유용합니다.

## OOP(객체 지향 프로그래밍)의 지향점

1. 캡슐화(Encapsulation)
   설명: 객체는 데이터(상태)와 메서드(동작)를 하나의 단위로 묶어 외부로부터 보호합니다. 이를 통해 객체 내부의 데이터 구조를 숨기고, 외부에서 객체의 메서드를 통해서만 데이터에 접근할 수 있습니다.
   장점: 데이터 무결성을 유지하고, 객체의 내부 구현 변경 시 외부에 미치는 여향을 최소화합니다.

2. 상속(Inheritance)
   설명: 새로운 클래스가 기존 클래스의 속성과 메서드를 물려받아 사용할 수 있게 하는 기능입니다. 이를 통해 코드의 재사용성을 높일 수 있습니다.
   장점: 공통된 기능을 가진 클래스 간의 관계를 명확히 하고, 유지보수를 용이하게 합니다.

3. 다형성(Polymorphism)
   설명: 동일한 인터페이스를 사용하여 여러 형태의 객체를 처리할 수 있게 해주는 기능입니다. 메서드 오버로딩과 메서드 오버라이딩을 통해 구현됩니다.
   장점: 코드의 유연성을 높이고, 다양한 객체를 동일한 방식으로 처리할 수 있습니다.
4. 추상황 (Abstraction)
   설명: 복잡한 시스템에서 중요하지 않은 세부 사항을 숨기고, 필요한 정보만을 노출하는 과정입니다.
   장점: 시스템을 단순하게 이해할 수 있게 하고, 복잡성을 줄입니다.

## 클로저(Closure)

클로저(Closure)는 JavaScript에서 함수와 그 함수가 선언될 때의 렉시컬 환경(lexical environment)을 함꼐 기억하는 기능입니다. 클로저는 주로 함수가 다른 함수 내에서 정의될 때 발생합니다.

주요 개념
함수의 접근 범위: 클로저는 내부 함수가 외부 함수의 변수에 접근할 수 있도록 해줍니다. 외부함수가 반환된 후에도 내부 함수는 외부 함수의 스코프를 "닫아"두기 때문에 해당 변수에 접근할 수 있습니다.

상태 유지: 클로저를 사용하면 함수가 호출된 상태를 유지할 수 있습니다. 이로 인해 비공식적인 데이터 은닉과 데이터 캡슐화를 구현할 수 있습니다.

## 실행 컨텍스트(Execution Context)

실행 컨텍스트(Execution Context)는 JavaScript 코드가 실행될 때 생성되는 환경을 의미합니다. 이 환경은 코드가 실행되는 동안 어떤 변수, 함수, 객체가 사용 가능한지를 정의합니다. 실행 컨텍스트는 함수가 호출될 때마다 생성되며, 여러 가지 중요한 정보를 포함하고 있습니다.

주요 구성 요소

1. 변수 환경(Variable Environment):
   현재 실행 컨텍스트 내에서 정의된 변수와 그 값을 저장합니다.

2. 렉시컬 환경(Lexical Environment):
   실행 컨텍스트가 생성될 때의 스코프(즉, 해당 함수가 선언된 위치의 스코프)를 나타냅니다. 이는 외부 함수의 변수에 대한 접근을 관리합니다.

3. this 바인딩(this Binding)
   현재 실행 컨테스트에서 this가 참조하는 객체를 정의합니다. 이는 호출 방법에 따라 다르게 설정됩니다.

실행 컨텍스트의 단계

1. 전역 컨텍스트: 코드가 실행될 때 가장 먼저 생성되는 컨텍스트로, 전역 변수와 함수가 정의됩니다. 이 때 this는 전역 객체를 참조합니다.

2. 함수 호출 컨텍스트: 함수가 호출될 때마다 새로운 실행 컨텍스트가 생성됩니다. 각 함수는 자신만의 변수 환경과 렉시컬 환경을 가집니다.

## DNS(domain name system)

인터넷에서 도메인 이름을 IP 주소로 변환하는 시스템입니다. 사름은 도메인 이름으로 웹사이트를 기억하는 것이 쉽지만, 컴퓨터는 IP 주소를 사용하여 서로 통신합니다. DNS는 이러한 도메인 이름과 IP 주소간의 매핑을 관리하여 사용자와 웹 리소스 간의 연결을 원활하게 해줍니다.

주요 기능

1. 도메인 이름 해석: 사용자가 입력한 도메인 이름을 해당하는 IP 주소로 변환합니다.
2. 주소 캐싱: DNS 서버는 자주 요청되는 도메인 이름과 IP 주소 쌍을 캐싱하여 이후 요청 시 빠르게 응답할 수 있습니다.
3. 부하 분산: 여러 IP 주소를 도메인 이름에 매핑하여 트래픽을 분산시키고 서버의 부하를 줄입니다.

DNS의 구조

1. DNS 리졸버: 사용자의 요청을 처리하고, 도메인 이름을 IP 주소로 변환하는 역할을 합니다.
2. 루트 DNS 서버: 최상위 DNS 서버로, 특정 도메인의 네임 서버에 대한 정보를 제공합니다.
3. TLD(최상위 도메인)(Top-Level-Domain) 서버: 특정 도메인(.com, .org 등)에 대한 정보를 저장합니다.
4. 권한 있는 네임 서버: 특정 도메인에 대한 IP 주소와 관련된 정보를 저장합니다.

## google.com을 입력했을 때

1. URL 입력 및 브라우저 처리
   사용자가 google.com을 입력하면 브라우저는 이 URL을 해석하고 HTTP 요청을 준비합니다.

2. DNS 조회
   브라우저는 먼저 google.com의 IP 주소를 찾기 위해 DNS 리졸버에 요청을 보냅니다.
   DNS 리졸버는 캐시에 저장된 IP 주소를 확인하고, 없으면 루트 DNS 서버, TLD 서버, 권한 있는 네임 서버를 순차적으로 조회하여 최종 IP 주소(예: 172.217.0.0)를 얻습니다.

3. TCP 연결 설정
   브라우저는 해당 IP 주소로 TCP 연결을 설정합니다. 이는 3-way handshake 과정을 통해 이루어집니다.

4. HTTP 요청 전송
   TCP 연결이 성공적으로 이루어지면, 브라우저는 HTTP GET 요청을 해당 서버에 전송합니다. 예를 들어, / 경로에 대한 요청이 전송됩니다.

5. 서버 처리 및 응답
   Google 서버는 요청을 수신하고, 해당 웹 페이지를 생성하여 HTTP 응답을 브라우저로 전송합니다. 이 응답은 HTML, CSS, JavaScript 등의 콘텐츠를 포함합니다.

6. 페이지 렌더링
   브라우저는 서버로부터 받은 데이터를 처리하여 웹 페이지를 화면에 표시합니다. HTML을 파싱하고, CSS 스타일을 적용하며, JavaScript를 실행하여 최종적으로 사용자가 볼 수 있는 페이지를 완성합니다.

7. 추가 리소스 요청

웹 페이지가 렌더링되면서 추가적인 리소스(이미지, 스크립트 등)가 필요한 경우, 브라우저는 해당 리소스에 대해 추가적인 HTTP 요청을 보냅니다.

수 밀리 초에 일어나는 일들

## REST API에서 사용하는 주요 메서드들

1. GET
   설명: 서버에서 리소스를 조회할 때 사용합니다. 데이터의 변경이 없어야 하며, 요청 시 URL에 매개변수를 추가하여 특정 데이터를 요청할 수 있습니다.

예시: GET /users (모든 사용자 목록 조회)

2. POST
   설명: 서버에 새로운 리소스를 생성할 때 사용합니다. 요청 본문에 생성할 데이터가 포함됩니다.
   예시: POST /users (새로운 사용자 생성)

3. PUT
   설명: 기존 리소스를 업데이트할 때 사용합니다. 전체 리소스를 새 데이터로 교체합니다.
   예시: PUT /users/1 (ID가 1인 사용자 정보를 전체 업데이트)

4. PATCH
   설명: 기존 리소스의 일부를 업데이트할 때 사용합니다. 필요한 필드만 수정할 수 있습니다.
   예시: PATCH /users/1 (ID가 1인 사용자 정보의 일부만 업데이트)

5. DELETE

설명: 서버에서 리소스를 삭제할 때 사용합니다.
예시: DELETE /users/1 (ID가 1인 사용자 삭제)

## 콜백 함수

콜백 함수는 다른 함수의 인자로 전달되어 특정 시점에 호출되는 함수를 의미합니다. 주로 비동기 작업이나 이벤트 처리에서 사용됩니다.

주요 특징

비동기 처리: 콜백 함수는 주로 비동기 작업이 완료된 후 실행되며, 예를 들어, AJAX 요청이 완료된 후 데이터를 처리하는데 사용됩니다.
유연성: 다른 함수에 인자로 전달됨으로써, 함수의 동작을 외부에서 조정할 수 있습니다.

## 데코레이터 패턴이란

데코레이터 패턴(Decorator Pattern)은 객체에 새로운 기능이나 행동을 동적으로 추가할 수 있는 구조적 디자인 패턴입니다. 이 패턴은 기존 객체를 수정하지 않고도 기능을 확장할 수 있게 해주며, 객체를 래핑(wrapping)하여 추가적인 기능을 부여합니다.

주요 특징
유연성: 기능을 추가할 때 기존 코드를 변경하지 않고 새로운 데코레이터 객체를 생성하여 필요한 기능을 추가할 수 있습니다.
확장성: 여러 데코레이터를 조합하여 객체의 기능을 다양하게 확장할 수 있습니다.
Single Responsibility Principle: 각 데코레이터는 특정 기능을 담당하므로, 코드의 책임을 분리할 수 있습니다.

## 싱글톤 패턴

싱글톤 패턴(Singleton Pattern)은 클래스의 인스턴스가 오직 하나만 생성되도록 보장하는 디자인 패턴입니다. 이 패턴은 애플리케이션 전체에서 공유되는 전역 상태나 자원을 관리할 때 유용합니다.

주요 특징
단일 인스턴스: 클래스의 인스턴스가 하나만 존재하며, 이를 전역적으로 접근할 수 있는 방법을 제공합니다.
전역 접근: 생성된 인스턴스에 전역적으로 접근할 수 있도록 static 메서드를 통해 제공됩니다.
지연 초기화: 필요할 때까지 인스턴스를 생성하지 않고, 최초 요청 시 생성하는 경우가 많습니다.

## IoC(Inversion of Control)(제어의 역전)

객체 지향 프로그래밍에서 객체의 생성과 의존성 관리를 개발자가 아닌 프레임워크나 컨테이너가 담당하게 하는 설계 원칙입니다. 이를 통해 코드의 결합도를 낮추고, 유연성과 테스트 용이성을 높이는 것을 목표로 합니다.

주요 특징

1. 제어의 역전: 전통적인 방식에서는 객체가 자신의 의존성을 직접 생성하고 관리하지만 , IoC에서는 외부에서 이 과정을 담당하게 됩니다.
2. 의존성 관리: IoC는 의존성 주입(Dependency Injection)과 밀접하게 관련되어 있으며, 객체가 필요로 하는 의존성을 외부에서 주입받도록 합니다.
3. 유연성 및 확장성: IoC를 사용하면 코드의 구조가 유연해지고, 변경이 용이해집니다. 새로운 기능이나 클래스의 추가가 쉬워집니다.

## 트랜잭션 데드락(Deadlock)

데이터베이스나 멀티스레딩 환경에서 발생하는 문제로 두 개 이상의 트랜잭션이 서로의 자원을 점유한 상태에서 서로의 자원을 기다리고 있어 진행이 불가능한 상황을 말합니다. 즉 트랜잭션 A가 자원 X를 점유하고 자원 Y를 요청하고 동시에 트랜잭션 B가 자원 Y를 점유하고 자원 X를 요청하는 경우가 데드락입니다.

주요 특징

1. 상호 배제: 최소한 하나의 자원은 다른 트랜잭션이 사용할 수 없어야 합니다.

2. 보유 및 대기: 트랜잭션이 최소한 하나의 자원을 보유하고 있으며, 다른 자원을 요청할 때 대기하고 있어야 합니다.
3. 비선점: 이미 보유하고 있는 자원은 강제로 다른 트랜잭션에 의해 빼앗길 수 없어야 합니다.
4. 순환 대기: 트랜잭션들 간에 자원을 점유하고 대기하는 순환구조가 형성되어야 합니다.

데드락 해결 방법

1. 시간 초과(Timeout): 일정 시간 내에 자원을 확보하지 못하면 트랜잭션을 종료하는 방법입니다.
2. 탐지 및 회복: 주기적으로 데드락 상태를 감지하고, 하나 이상의 트랜잭션을 종료하여 자원을 해제하는 방법입니다.
3. 예방: 트랜잭션이 자원을 요청할 때, 데드락이 발생하지 않도록 사전에 규칙을 설정하여 방지하는 방법입니다.
4. 순서환: 모든 트랜잭션이 자원을 요청하는 순서를 지정하여, 순환 대기를 방지하는 방법입니다.

## HTTP 상태 코드

HTTP 상태 코드는 클라이언트이 요청에 대한 서버의 응답 상태를 나타내는 3자리 숫자 코드입니다. 각 상태 코드는 특정 의미를 가지며 주로 5개의 카테고리로 나눌 수 있습니다.

1. 정보 응답 (1XX)
   100 Continue: 클라이언트가 요청을 계속해도 된다는 의미
   101 Switching Protocols: 클라이언트의 요청에 따라 프로토콜을 변경할 때 사용.

2. 성공 응답(2XX)
   200 OK: 요청이 성공적으로 처리되었음을 나타냄
   201 Creaded: 요청이 성공적으로 처리되어 새로운 자원이 생성되었음을 나타냄
   202 Accepted: 요청이 접수되었으나 처리가 완료되지 않았음을 나타냄.
   204 No Content: 요청은 성공적이지만 반환할 콘텐츠가 없음을 나타냄.

3. 리다이렉션(3XX)

300 Multiple Choices: 요청한 자원이 여러 개 있으며, 클라이언트가 선택해야 함
301 Moved Permanently: 요청한 자원이 영구적으로 다른 URI로 이동되었음을 나타냄
302 Found: 요청한 자원이 임시로 다른 URI로 이동되었음을 나타냄.
304 Not Modified: 클라이언트가 제공한 조건에 따라 자원이 수정되지 않았음을 나타냄

4. 클라이언트 오류 (4XX)
   400 Bad Request: 잘못된 요청으로 서버가 이해할 수 없음
   401 Unauthorized: 인증이 필요하거나 실패했음을 나타냄.
   403 Forbidden: 요청이 이해되었지만 서버가 요청을 거부함.
   404 Not Found: 요청한 자원을 찾을 수 없음
   405 Method Not Allowed: 요청한 HTTP 메서드가 지원되지 않음
   408 Request Timeout: 클라이언트의 요청 시간이 초과됨

5. 서버 오류 (5XX)
   500 Internal Server Error:: 서버 내부에서 오류가 발생하여 요청을 처리할 수없음.
   501 Not Implemented: 서버가 요청한 기능을 지원하지 않음.
   502 Bad Gateway: 서버가 게이트웨이 또는 프록시로서 다른 서버로부터 잘못된 응답을 받음
   503 Service Unavailable: 서버가 일시적 과부하 상태이거나 유지보수 중임
   504 Gateway Timeout: 게이트웨이가 타임아웃되어 다른 서버로부터 응답을 받지 못함.

## SSR, CSR

### SSR

정의
서버에서 HTML을 생성하여 클라이언트에 전달하는 방식입니다. 클라이언트가 요청을 보내면 서버가 데이터를 가져와 HTML을 생성하고, 그 결과를 클라이언에 반환합니다.

특징
초기 로딩 속도: 페이지가 서버에서 렌더링되어 클라이언트에 전달되므로, 초기 로딩 시 사용자에게 즉시 콘텐츠를 제공합니다.
SEO: 서버에서 렌더링된 HTML이 검색 엔진에 잘 인덱스되므로 SEO에 유리합니다.
JavaScript 비활성화 시: 클라이언트에서 JavaSript가 비활성화되어도 페이지가 정상적으로 표시됩니다.

단점
서버 부하: 모든 요청에 대해 서버가 HTML을 생성해야 하므로, 서버 부하가 증가할 수 있습니다.
상호작용 성능: 사용자 상호작용 후 페이지를 다시 렌더링할 때 서버에 요청을 해야 하므로, 반응 속도가 느려질 수 있습니다.

### CSR

정의
클라이언트(브라우저)에서 JavaScript를 사용하여 데이터를 가져오고, DOM을 조작하여 HTML을 생성하는 방식입니다. 초기에는 최소한의 HTML만 전단되고, 이후에 JavaScript가 실행되어 콘텐츠를 동적으로 렌더링합니다.

특징
빠른 사용자 경험: 초기 로딩 후 페이지 간 전환이 빠르며, 사용자 상호작용에 빠르게 반응합니다.
서버 부하 감소: 서버가 초기 요청에 대해 간단한 HTML과 JavaScript 파일만 전달하므로 서버 부하가 줄어듭니다.

단점
초기 로딩 시간: 클라이언트에서 JavaScript를 다운로드하고 실행해야 하므로 초기 로딩 시간이 길어질 수 있습니다.
SEO 문제: JavaScript로 동적으로 생성된 콘텐츠는 검색 엔진이 인덱스하기 어려울 수 있습니다. 하지만 현대 검색 엔진은 CSR을 점점 더 잘 처리하고 있습니다.
JavaScript 비활성화 시: 클라이언트에서 JavaScript가 비활성화되면 페이지가 제대로 표시되지 않을 수 있습니다.

### SEO

SEO(검색 엔진 최적화, Search Engine Optimization)는 웹사이트나 웹페이즈를 검색 엔진 결과 페이지(SERP)에서 높은 순위에 노출시키기 위한 전략과 기법을 읨합니다. SEO의 목표는 유기적(자연검색) 트래픽을 증가시키고, 웹사이트의 가시성을 높이는 것입니다.

주요 요소

1. 온페이지 SEO (On-page SEO):
   키워드 최적화: 사용자들이 검색할 가능성이 높은 키워드를 웹페이지에 포함시킵니다.
   메타 태그: 제목 태그(title), 설명 태그(meta description) 등을 최적화하여 검색 엔진과 사용자가 페이지의 내용을 이해할 수 있도록 합니다.
   콘텐츠 품질: 유용하고 독창적인 콘텐츠를 제공하여 방문자에게 가치를 제공합니다.
   URL 구조: 간결하고 이해하기 쉬운 URL을 사용합니다.
   내부 링크: 웹사이트 내 다른 페이지와의 연결을 통해 사용자와 검색 엔진이 웹사이트를 탐색하기 쉽게 합니다.

2. 오프페이지 SEO (Off-page SEO):
   백링크: 다른 웹사이트에서 자신의 웹사이트로 연결되는 링크를 확보하여 신뢰성을 높입니다.
   소셜 미디어: 소셜 미디어 플랫폼에서의 활동을 통해 트래픽을 유도하고 브랜드 인지도를 높입니다.

3. 기술적 SEO (Technical SEO):
   사이트 속도: 웹사이트의 로딩 속도를 최적화하여 사용자 경험을 향상시키고, 검색 엔진이 사이트를 더 잘 크롤링하도록 합니다.
   모바일 최적화: 모바일 사용자에게도 최적화된 경험을 제공하여 순위를 높입니다.
   사이트 구조: 검색 엔진이 웹사이트를 쉽게 크롤링하고 인덱싱할 수 있도록 사이트 구조를 최적화합니다.

4. 사용자 경험(UX)
   사용자 친화적인 디자인과 내비게이션을 통해 방문자가 사이트에서 머무는 시간을 늘리고 이탈률을 줄입니다.

SEO의 중요성
트래픽 증가:
검색 결과에서 상위에 노출되면 더 많은 방문자를 유도할 수 있습니다.
브랜드 신뢰성:
검색 결과 상위에 위치하면 사용자에게 신뢰감을 주고, 브랜드 인지도를 높입니다.
비용 효율성: 유기적 트래픽은 광고비용이 들지 않기 때문에 장기적으로 비용 효율적인 마케팅 전략이 될 수 있습니다.

## SRRP

SERP는 Search Engine Results Page의 약자로, 검색 엔진에서 사용자가 검색한 키워드에 대한 결과 페이지를 의미합니다. SERP는 사용자가 검색했을 때 표시되는 웹피이지 목로과 그에 대한 관련 정보를 포함하고 있습니다.

SERP의 주요 구성 요소

1. 유기적 검색 결과(Organic Results):
   검색엔진 최적화(SEO)에 의해 자연스럽게 노춛되는 웹페이지 목록입니다. 페이지의 품질, 광련성 백링크 등 다양한 요소에 따라 순위가 결정됩니다.

2. 광고(Paid Results)
   검색 엔진에 광고비를 지불하여 상단이나 하단에 표시되는 유료 광고입니다. Google Ads와 같은 플랫폼을 통해 설정할 수 있습니다. 보통 "광고" 또는 "Ad"라는 레이블이 붙습니다.

3. 스니펫(Feature Snippets):
   질문에 대한 직접적인 답변이나 요약을 제공하는 형태로 페이지의 일부가 SERP의 상단에 강조 표시됩니다. 이는 사용자에게 빠른 정보를 제공합니다.

4. 지역 정보(Local Results):
   특정 지역에 대한 검색일 경우, 지역 비즈니스 정보와 함께 지도와 주소가 표시됩니다. 예를 들어, "근처의 카페"와 같은 검색 결과입니다.

5. 관련 질문(People Also Ads):
   사용자가 검색한 주제와 관련된 질문 목록이 나열되어, 추가적인 정보를 쉽게 찾을 수 있도록 돕습니다.

6. 이미지/비디오 결과
   이미지나 비디오 콘텐츠가 검색 결과로 표시될 수 있으며, 이는 사용자의 검색 의도에 따라 다르게 나타납니다.

SERP의 중요성
가시성: 기업이나 웹사이트가 SERP의 상단에 노출될수록 더 많은 트래픽을 유도할 수 있습니다.
사용자 경험: SERP의 구성 요소가 사용자에게 다양한 정보를 제공함으로써 검색 경험을 향상시킵니다.
비즈니스 기회: 기업은 SERP에서 높은 순위를 차지하여 잠재 고객에게 노출될 기회를 극대화할 수 있습니다.

### 크롤링 (Crawling)

정의

크롤링은 검색 엔진 봇(크롤러 또는 스파이더)이 웹 페이지를 탐색하여 새로운 콘텐츠를 발견하고, 기존의 페이지를 업데이트하는 과정입니다. 크롤러는 링크를 따라 이동하면서 다양한 웹 페이지에 접근합니다.

과정

1. 시작점: 크롤러는 초기 URL 목록 (사이트맵 등)을 기반으로 시작합니다.
2. 페이지 수집: 지정된 URL에 접속하여 페이지의 콘텐츠를 가져옵니다.
3. 링크 추적: 페이지 내의 링크를 분석하고, 새로운 URL을 큐에 추가하여 지속적으로 크롤링을 진행합니다.
4. 재방문: 정기적으로 사이트를 재방문하여 업데이트된 콘텐츠를 확인합니다.

중요성
신규 콘텐츠 발견: 웹사이트에 추가된 새로운 페이지를 발견하는 데 필수적입니다.
업데이트 유지: 기존 콘텐츠이 변경 사항을 반영하여 검색 결과의 정확성을 유지합니다.

### 인덱싱 (Indexing)

정의
인덱싱은 크롤링을 통해 수집된 웹 페이지의 콘텐츠를 분석하고, 이를 검색 엔진의 데이터베이스에 저장하여 검색이 용이하도록 정리하는 과정입니다.

과정

1. 데이터 분석: 수집된 페이지의 텍스트, 메타 태그, 이미지 등을 분석하여 중요한 정보를 추출합니다.
2. 구조화: 각 페이지의 콘텐츠를 키워드와 관련된 구조로 정리하여 인덱스를 생성합니다.
3. 저장: 정리된 정보를 검색 엔진의 데이터베이스에 저장하여, 검색 시 빠르게 접근할 수 있도록 합니다.

중요성
검색 효율성: 사용자가 검색할 때, 인덱스된 정보를 빠르게 조회하여 관련된 결과를 제공합니다.
정확한 검색 결과: 인덱싱을 통해 사용자가 입력한 검색 쿼리에 대해 가장 관련성 높은 페이지를 찾아 제공합니다.

## 리팩토링

리팩토링(Refactoring)은 기존의 코드 구조를 개선하면서도 외부의 동작이나 기능은 변경하지 않는 과정을 의미합니다. 주로 코드의 가독성을 높이고, 유지보수성을 향상시키며, 성능을 개선하기 위해 수행합니다.

리팩토링의 목적

1. 가독성 향상: 코드를 더 읽기 쉽게 만들어 다른 개발자나 미래의 자신이 코드를 이해하는 데 소용되는 시간을 줄입니다.
2. 유지보수성 증대: 코드가 명확하고 체계적으로 구성되어 있으며 버그 수정이나 새로운 기능 추가가 용이해집니다.
3. 중복 제거: 중복된 코드를 통합하여 코드의 크기를 줄이고, 일관성을 유지합니다.
4. 성능 최적화: 비효율적인 코드 구조를 개선하여 실행 성능을 높일 수 있습니다.
5. 테스트 용이성: 코드를 모듈화하려면 유닛 테스트 및 자동화 테스트를 수행하기 쉬워집니다.

리팩토링의 기법

1. 코드 정리: 불필요한 주석이나 쓰이지 않는 변수를 제거합니다.
2. 함수 및 메서드 분리: 큰 함수나 메서드를 작고 단순한 단위로 분리하여 책임을 명확히 합니다.
3. 변수 및 함수 이름 개선: 의미 있는 이름으로 변경하여 코드의 의도를 명확히 합니다.
4. 클래스 추출: 기능이 많은 클래스를 더 작은 클래스로 나누어 응집도를 높입니다.
5. 중복 코드 통합: 비슷한 코드 블록을 하나의 메서드나 함수로 통합합니다.

리팩토링의 중요성
품질 향상: 코드의 품질이 향상되면 소프트웨어의 안정성도 높아집니다.
팀워크 개선: 다른 개발자들이 코드를 이해하고 수정하는데 더 용이해져 협업이 원활해집니다.
비용 절감: 초기 개발 단계에서 리팩토링을 통해 나중에 발생할 수 있는 큰 비용을 절감할 수 있습니다.

리팩토링의 주의점
기능 변경 없음: 리팩토링을 할 때는 반드시 기능이 변경되지 않도록 주의해야 합니다. 이를 위해 충분한 테스트가 필요합니다.
점진적 진행: 한 번에 대규모로 리팩토링하기보다는 작은 단위로 점진적으로 진행하는 것이 좋습니다.
버전 관리: 리팩토링 과정에서 코드를 변경하는 경우, 버전 관리 시스템을 사용하여 변경 사항을 기록하는 것이 중요합니다.

## 클린 코드와 리팩토링 차이

### 클린 코드

정의
읽기 쉽고 이해가기 쉬우며, 유지보수가 용이한 코드를 의미합니다. 로버트 C. 마틴 (Robert C. Martin) 등의 저자들이 이 개념을 주창하였습니다.

특징

1. 가독성: 코드가 쉽게 읽히고 이해할 수 있어햐 합니다.
2. 명확한 네이밍: 변수, 함수, 클래스의 이름이 그 용도나 기능을 명확히 설명해야 합니다.
3. 일관성: 코드 스타일이 일관되게 유지되어야 합니다.
4. 단일 책임 원칙(SRP): 각 함수나 클래스는 하나의 책임만 가져야 하며, 이를 통해 변경 시 영향을 최소화합니다.
5. 테스트 용이성: 테스트가 용이하게 설계되어야 합니다.

초점
클린 코드는 코드 작성 시부터 품질을 높이는 것을 목표로 하며, 좋은 코드 작성 습관과 원칙을 따릅니다.

### 리팩토링

정의
리팩토링은 기존의 코드를 개선하는 과정으로, 기능을 변경하지 않으면서 코드의 구조를 재조정하여 가독성이나 유지보수성을 높이는 작업입니다.

특징

1. 기존 코드 개선: 리팩토링은 이미 존재하는 코드를 대상으로 합니다.
2. 기능 불변성: 리팩토링 과정에서 기존의 기능은 변경되지 않아야 합니다.
3. 점진적 접근: 종종 소규모로 반복적으로 수행되어 코드의 품질을 점진적으로 개선합니다.

초점
리팩토링은 이미 작성된 코드의 품질을 향상시키기 위한 방법으로, 코드 작성 후 발생할 수 있는 문제를 해결하기 위해 사용됩니다.

## OSI 7계층

OSI 7계층(Open Systems Interconnection model)은 네트워크 통신을 표준화하기 위해 제안된 개념적 모델로 데이터 통신을 7개의 계층으로 나누어 각 계층의 역할을 정의합니다. 이 모델은 네트워크 설계와 구현의 복잡성을 줄이고, 다양한 시스템 간의 호환성을 높이기 위해 만들어졌습니다.

1. 물리 계층 (Physical Layer)
   역할: 전기적, 기계적, 절차적 특성을 정의하여 실제 데이터를 전송하는 계층입니다.
   예시: 케이블, 리피터, 허브, 전기 신호 등

2. 데이터 링크 계층 (Data Link Layer)
   역할: 물리적 네트워크에서 데이터의 오류 감지 및 수정, 그리고 MAC 주소를 사용한 노드 간의 데이터 전송을 담당합니다.
   예시: 이더넷, Wi-Fi, PPP(점대점 프로토콜)

3. 네트워크 계층 (Network Layer)
   역할: 데이터 패킷의 경로 설정 및 전달을 담당하며, 논리적 주소(예: IP 주소)를 사용하여 네트워크 간 통신을 가능하게 합니다.
   예시: IP(인터넷 프로토콜), ICMP(인터넷 제어 메시지 프로토콜)

4. 전송 계층 (Transport Layer)
   역할: 종단 간 (end-to-end) 통신을 관리하며, 데이터의 전송 오류를 감지하고 복구합니다. 흐름 제어 및 세분화된 데이터 전송도 지원합니다.
   예시: TCP(전송 제어 프로토콜), UDP(사용자 데이터그램 프로토콜)

5. 세션 계층 (Session Layer)
   역할: 통신 세션을 관리하고, 세션의 설정, 유지 및 종료를 담당합니다. 데이터 교환의 동기화도 지원합니다.
   예시: API(응용 프로그램 프로그래밍 인터페이스), 소켓

6. 표현 계층 (Presentation Layer)
   역할: 데이터의 형식과 표현을 변환하여 서로 다른 시스템 간의 데이터 호환성을 보장합니다. 데이터 압축 및 암호화도 이 계층에서 수행됩니다.
   예시: JPEG, GIF, ASCII

7. 응용 계층 (Application Layer)
   역할: 최종 사용자가 직접 사용하는 응용 프로그램과 네트워크 간의 인터페이스를 제공합니다. 사용자와 네트워크의 상호작용을 처리합니다.
   예시: HTTP, FTP, SMTP, DNS

### TCP/IP 4계층 및 5계층 모델

### TCP/IP 4계층 모델

TCP/IP 모델은 인터넷과 같은 네트워크에서 데이터 통신을 위한 프로토콜을 정의하는 구조로, OSI 모델과는 달리 일반적으로 4계층 또는 5계층으로 나누어 설명됩니다. 여기서는 4계층과 5계층 모델을 모두 설명하겠습니다.

TCP/IP 4계층 모델

1. 네트워크 인터페이스 계층 (Network Interface Layer)
   역할: 물리적 네트워크에서 데이터 전송을 담당하며, 하드웨어와 관련된 데이터 링크 및 물리적 전송을 포함합니다.
   예시: Ethernet, Wi-Fi, ARP (Address Resolution Protocol)

2. 인터넷 계층 (Internet Layer)
   역할: 데이터 패킷의 주소 지정 및 라우팅을 담당합니다.
   예시: IP (Internet Protocol), ICMP (Internet Control Message Protocol)

3. 전송 계층 (Transport Layer)
   역할: 종단 간 데이터 전송을 관리하며, 신뢰성, 흐름 제어 및 오류 검출을 제공합니다.
   예시: TCP (Transmission Control Protocol), UDP (User Datagram Protocol)

4. 응용 계층 (Application Layer)
   역할: 최종 사용자와의 상호작용을 처리하며, 애플리케이션 프로토콜을 포함합니다.
   예시: HTTP, FTP, SMTP, DNS

### TCP/IP 5계층 모델 (1계층부터)

1. 물리 계층 (Physical Layer):
   역할: 전기적 신호, 케이블 및 하드웨어와 관련된 요소를 다룹니다.

2. 데이터 링크 계층 (Data Link Layer)
   역할: 물리적 네트워크의 데이터 전송 및 오류 감지를 담당합니다.

3. 인터넷 계층 (Internet Layer)
   역할: 데이터 패킷의 주소 지정 및 라우팅을 담당합니다.

4. 전송 계층 (Transport Layer)
   역할: 종단 간 데이터 전송을 관리하며, 신뢰성, 흐름 제어 및 오류 검출을 제공합니다.

5. 응용 계층 (Application Layer)
   역할: 최종 사용자와의 상호작용을 처리하며, 애플리케이션 프로토콜을 포함합니다.

## 가비지 컬렉터(Garbage Collector, GC)

프로그래밍 언어에서 메모리 관리를 자동으로 수행하는 시스템입니다. 주로 Java, C#, JavaScript 등과 같은 언어에서 사용됩니다. 가비지 컬렉터의 주요 역할은 더 이상 필요하지 않은 객체를 찾아 메모리에서 해제함으로써 메모리 누수를 방지하고, 효율적으로 메모리를 관리하는 것입니다.

가비지 컬렉션의 원리

1. 메모리 할당: 프로그램에서 객체가 생성되면 메모리에 할당됩니다.
2. 참조 카운팅: 각 객체는 자신을 참조하는 다른 객체의 수를 추적합니다. 이 카운트가 0이 되면 해당 객체는 더 이상 사용되지 않는 것으로 간주됩니다.
3. 루트 검색: 가비지 컬렉터는 "루트"라 불리는 참조 집합(전역 변수, 스택 변수 등)을 기준으로 하여 여전히 참조되고 있는 객체들을 추적합니다. 루트에서 시작하여 접근 가능한 모든 객체를 찾습니다.
4. 가비지 식별: 루트에서 도달할 수 없는 객체는 가비지로 간주되어 메모리에서 해제됩니다.
5. 메모리 해제: 식별된 가비지는 메모리에서 제거되며, 그 공간은 새로운 객체의 할당을 위해 재사용될 수 있습니다.

가비지 컬렉션의 방식

1. Mark-and-Sweep
   객체를 마킹하여 사용 중인 객체와 사용하지 않은 객체를 구분한 후, 사용하지 않는 객체를 메모리에ㅔ서 해제합니다.
2. Generational Garbage Collection
   객체의 생애 주기에 따라 세대별로 구분하여 관리합니다. 일반적으로 새로 생성된 객체는 "young generation"에 배치되며, 일정 시간이 지나면 "old generation"에 배치되며, 일정 시간이 지나면 "old generation"으로 이동합니다. 대부분의 객체는 짧은 생애를 가지므로, young generation에서 자주 가비지 컬렉션이 수행됩니다.
3. Reference Counting
   각 객체의 참조 카운트를 유지하여, 카운트가 0이 되는 객체를 즉시 해제합니다. 하지만 순환 참조 문제를 해결하지 못하는 단점이 있습니다.

장점
메모리 관리의 자동화: 개발자는 메모리 해제를 걱정하지 않고 객체를 생성할 수 있습니다.
메모리 누수 방지: 더 이상 필요하지 않은 객체를 자동으로 해제하여 메모리 누수를 방지합니다.

단점
성능 저하: 가비지 컬렉션이 수행되는 동안 프로그램이 일시 중지될 수 있으며, 이로 인해 성능이 저하될 수 있습니다.
예측 불가능성: 가비지 컬렉션이 언제 발생할지 예측하기 어려워, 성능이 일관되지 않을 수 있습니다.

### 순환참조

순환 참조(Circular Reference)는 두 개이상의 객체가 서로를 참조하여 발생하는 상황을 말합니다. 이는 가비지 컬렉터가 객체를 메모리에서 해제하는 데 문제를 일으킬 수 있습니다. 일반적으로 가비지 컬렉션은 참조 카운팅 방식이나 마크 앤 스위프 방식으로 동작하는데, 순환 참조는 이러한 방식에서 예외적인 상황을 초래할 수 있습니다.

문제점

1. 메모리 누수: 순환 참조가 발생하면, 해당 객체들이 더 이상 사용되지 않더라도 메모리에서 해제 되지 않으므로, 메모리 누수로 이어질 수 있습니다.
2. 가비지 컬렉션의 비효율성: 참조 카운팅 방식의 가비지 컬렉터는 순환 참조를 인식하지 못하므로, 객체가 메모리에서 해제되지 않아 전체적인 메모리 관리 효율성이 떨어집니다.

해결방법

1. 마크 앤 스위프: 현대의 가비지 컬렉터는 마크 앤 스위프 방식을 사용하여 순환 참조 문제를 해결합니다. 이 방식은 루트에서 접근 가능한 객체를 마킹한 다음, 마킹되지 않은 객체를 해제합니다.
2. Weak References: 일부 언어에서는 약한 참조(Weak Reference)를 사용하여 순환 참조 문제를 완화할 수 있습니다. 약한 참조는 참조된 객체가 다른 강한 참조가 없을 경우 가비지 컬렉션 대상이 되도록 합니다.
3. 명시적 해제: 순환 참조를 생성하지 않도록 설계하거나, 객체의 참조를 명시적으로 해제하여 메모리 관리를 직접 수행할 수도 있습니다.

## 3-Way-HandShake 및 4-Way-Handshake

### 3-Way-HandShake (연결 설정)

3-way handshake는 TCP 연결을 설정하는 데 사용됩니다. 이 과정은 다음과 같은 3단계로 이루어집니다.

1. SYN: 클라이언트가 서버에 연결을 요청하기 위해 SYN(세그먼트 시작) 패킷을 전송합니다. 이 패킷에는 클라이언트의 초기 시퀸스 번호가 포함됩니다.

2. SYN-ACK: 서버는 클라이언트의 SYN 패킷을 수신하고, 연결을 수락하는 의미로 SYN-ACK 패킷을 클라이언트에게 보냅니다. 이 패킷은 서버의 초기 시퀸스 번호와 클라이언트의 시퀸스 번호를 확인하기 위해 ACK를 포함합니다

3. ACK: 클라이언트는 서버의 SYN-ACK패킷을 수신한 후, 연결이 완료되었음을 확인하기 위해 ACK 패킷을 서버에 전송합니다. 이 단계로 연결이 설정됩니다.

### 4-Way Handshake (연결 종료)

4-way handshake는 TCP 연결을 종료하는 데 사용됩니다. 이 과정은 다음과 같은 4단계로 이루어집니다.

1. FIN: 클라이언트가 서버와의 연결을 종료하고자 할 때, FIN(종료) 패킷을 서버에 전송합니다.
2. ACK: 서버는 클라이언틩 FIN 패킷을 수신하고, 연결 종료 요청을 확인하는 ACK 패킷을 클라이언트에 보냅니다. 이 단계에서는 클라이언트에서 서버로의 데이터 전송이 종료됩니다.
3. FIN: 서버는 클라이언트에게도 연결 종료를 요청하기 위해 FIN 패킷을 보냅니다. 이 패킷은 서버가 더 이상 데이터를 전송하지 않을 것임을 나타냅니다.

4. ACK: 클라이언트는 서버의 FIN 패킷을 수신하고, 연결 종료 요청을 확인하는 ACK 패킷을 서버에 전송합니다. 이 단계로 연결이 완전히 종료됩니다.
